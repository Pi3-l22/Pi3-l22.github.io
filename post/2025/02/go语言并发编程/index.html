<!doctype html><html lang=zh-cn><head><script>(function(){const e=localStorage.getItem("theme")||"light";document.documentElement.setAttribute("data-theme",e)})()</script><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=author content="LiuChao"><meta name=description content="Go 语言并发编程相关知识点：锁、channel、goroutine 以及 context"><link rel=icon href=https://blog.pi3.fun/favicon.ico><meta name=keywords content=" study  latex  life  academic "><meta property="og:url" content="https://blog.pi3.fun/post/2025/02/go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><meta property="og:site_name" content="Pi3's Notes"><meta property="og:title" content="Go语言并发编程"><meta property="og:description" content="Go 语言并发编程相关知识点：锁、channel、goroutine 以及 context"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-02-14T00:00:00+00:00"><meta property="article:modified_time" content="2025-02-14T00:00:00+00:00"><meta property="article:tag" content="技术"><meta property="article:tag" content="Golang"><link rel=canonical href=https://blog.pi3.fun/post/2025/02/go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/><meta itemprop=name content="Go语言并发编程"><meta itemprop=description content="Go 语言并发编程相关知识点：锁、channel、goroutine 以及 context"><meta itemprop=datePublished content="2025-02-14T00:00:00+00:00"><meta itemprop=dateModified content="2025-02-14T00:00:00+00:00"><meta itemprop=wordCount content="9006"><meta itemprop=keywords content="技术,Golang"><link media=screen rel=stylesheet href=https://blog.pi3.fun/css/common.css><link media=screen rel=stylesheet href=https://blog.pi3.fun/css/content.css><link media=screen rel=stylesheet href=https://blog.pi3.fun/css/theme.css><link media=screen rel=stylesheet href=https://blog.pi3.fun/css/iconfont/iconfont.css><link rel=stylesheet href=https://blog.pi3.fun/css/syntax/xcode.css data-theme-style=light media="(prefers-color-scheme: light)"><link rel=stylesheet href=https://blog.pi3.fun/css/syntax/catppuccin-mocha.css data-theme-style=dark media="not all"><title>Go语言并发编程 - Pi3's Notes</title>
<link rel=stylesheet href=https://blog.pi3.fun/css/single.css><link href=https://lf3-cdn-tos.bytecdntp.com/cdn/expire-100-y/KaTeX/0.15.2/katex.min.css rel=stylesheet><script defer src=https://lf3-cdn-tos.bytecdntp.com/cdn/expire-100-y/KaTeX/0.15.2/katex.min.js></script><script defer src=https://lf3-cdn-tos.bytecdntp.com/cdn/expire-100-y/KaTeX/0.15.2/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}],ignoredTags:["script","noscript","style","textarea","pre","code","option"],throwOnError:!1})})</script></head><body><div id=wrapper><header id=header><h1><a href=https://blog.pi3.fun/>Pi3's Notes</a></h1><nav><span class=nav-bar-item><a class=link href=/>文章</a>
</span><span class=nav-bar-item><a class=link href=/post/>归档</a>
</span><span class=nav-bar-item><a class=link href=/about/>关于</a>
</span><span class=nav-bar-item><a class=link href=/links/>友链</a>
</span><span class=nav-bar-item><a class="link theme-toggle" href=javascript:void(0);>黑暗</a></span></nav></header><main id=main class=post><h1>Go语言并发编程</h1><div><b>Keywords: </b><a class=link href=https://blog.pi3.fun/tags/%E6%8A%80%E6%9C%AF>#技术</a>
<a class=link href=https://blog.pi3.fun/tags/golang>#Golang</a></div><div><b>Release Date: </b><span>2025-02-14</span></div><details><summary><b>Table of Contents</b></summary><div class=toc><nav id=TableOfContents><ul><li><a href=#快速上手>快速上手</a></li><li><a href=#waitgroup>waitgroup</a></li><li><a href=#互斥锁>互斥锁</a></li><li><a href=#读写锁>读写锁</a></li><li><a href=#goroutine-互相通信>goroutine 互相通信</a></li><li><a href=#channel-的遍历>channel 的遍历</a></li><li><a href=#单向-channel>单向 channel</a></li><li><a href=#channel-实现交叉打印>channel 实现交叉打印</a></li><li><a href=#select-的用法>select 的用法</a></li><li><a href=#context-的用法>context 的用法</a></li><li><a href=#gmp-调度原理>GMP 调度原理</a></li><li><a href=#mpg-并发模型>MPG 并发模型</a></li><li><a href=#并发安全性>并发安全性</a></li></ul></nav></div></details><article class=content><p>Go 语言并发编程相关知识点：锁、channel、goroutine 以及 context</p><h2 id=快速上手>快速上手</h2><p>在其他编程语言中并发编程大多使用多线程、多进程编程，比如 python, java, php。多线程和多进程存在的问题主要是耗费内存，线程切换成本高。</p><p>随着 web 技术的不断发展，所需要的并发要求更高，因此出现了用户级线程、绿程、轻量级线程、协程。python 中的 syncio，php 的 swoole，java 的 netty。协程内存占用小、切换快，所以后续都使用协程来代替线程进程操作。</p><p>而 Go 语言则使用的是更加简单的 Goroutine 机制。Go 语言是没有线程的，因为 Go 语言的诞生时间较晚，协程已经广泛应用在并发编程中，所以它不再设置线程进程等旧技术。同时 Go 语言使用协程进行并发编程是非常方便的。</p><p>Go 语言中的任何函数，只要在调用之前使用 <code>go</code> 关键字就可以把这个函数使用协程执行，非常方便。</p><p>需要注意的是，Go 语言中的协程也是一样的，如果主进程 <code>main</code> 结束了，它其中的所有协程都会结束，因此需要保证主进程 <code>main</code> 不退出。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>//主协程
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//主死随从
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//匿名函数启动goroutine
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span><span class=p>&lt;</span><span class=mi>100</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}(</span><span class=nx>i</span><span class=p>)</span> <span class=c1>//值传递
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;main goroutine&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>10</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=waitgroup>waitgroup</h2><p>在并发编程中，子 goroutine 如何通知到主 goroutine 自己结束了？同时主 goroutine 如何知道子 goroutine 已经结束了？</p><p>Go 语言为了解决这个问题，提供了 sync. waitgroup 这个结构体功能。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;sync&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>wg</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>
</span></span><span class=line><span class=cl>    <span class=c1>//我要监控多少个goroutine执行结束
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span><span class=p>&lt;</span><span class=mi>100</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>//等到
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;all done&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>//waitgroup主要用于goroutine的执行等待， Add方法要和Done方法配套
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h2 id=互斥锁>互斥锁</h2><p><strong class=chinese>互斥锁</strong>就是为了解决共享资源（共享变量）相互竞争的问题。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>total</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>wg</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>add</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span><span class=p>&lt;</span><span class=mi>1000000</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>total</span> <span class=o>+=</span> <span class=mi>1</span> <span class=c1>//竞争
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>sub</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span><span class=p>&lt;</span><span class=mi>1000000</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>total</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>add</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>sub</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>total</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>运行以上示例程序，我们会发现输出的 total 值是在 <code>-100000~100000</code> 之间随机出现的，这是因为进行 <code>total+=1</code> 和 <code>total-=1</code> 这两个操作并不是<strong class=chinese>原子</strong>的，并且两个协程的执行是完全随机的，有可能上个操作还没写入变量，另一个操作就读取了变量。</p><p>如果将 for 循环的次数改为 10，输出的 total 就为 0 了。这并不是因为这两个操作不竞争了，而是因为 10 次太少了，先进行的 <code>add()</code> 非常迅速就将 10 次加完了，速度块到 <code>sub()</code> 还没有开始执行，因此这两个操作没有互相影响。</p><p>要解决两个操作互相影响的问题，就需要让这两个加减操作不能同时进行，即需要加锁操作。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>total</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>wg</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>lock</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>add</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span><span class=p>&lt;</span><span class=mi>1000000</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>lock</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>    
</span></span><span class=line><span class=cl>        <span class=nx>total</span> <span class=o>+=</span> <span class=mi>1</span> <span class=c1>//竞争
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>lock</span><span class=p>.</span><span class=nf>UnLock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>sub</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span><span class=p>&lt;</span><span class=mi>1000000</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>lock</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>   
</span></span><span class=line><span class=cl>        <span class=nx>total</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=nx>lock</span><span class=p>.</span><span class=nf>UnLock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>add</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>sub</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>total</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>需要保证两个操作使用的是同一个锁。</p><p>本质上 <code>sync.Mutex</code> 是一个 struct 类型，是可以复制的，但是一旦复制了就失去了锁的效果。相当于创建了一个新的锁（新的变量），两个操作使用的就不是同一个锁了。</p><p>在上面这个例子中，我们是针对一个共享的全局变量进行两个加减操作，它们由于不是原子化的，因此会相互影响。为了避免两个加减操作同时操作共享变量，我们可以使用互斥锁，另外也可以使用 <code>atomic</code> 包的原子化函数，将加减操作变成原子化的形式。这样就可以不使用锁操作了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;sync&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;sync/atomic&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>total</span> <span class=kt>int32</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>wg</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>add</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span><span class=p>&lt;</span><span class=mi>1000000</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>atomic</span><span class=p>.</span><span class=nf>AddInt32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>total</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>sub</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span><span class=p>&lt;</span><span class=mi>1000000</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>atomic</span><span class=p>.</span><span class=nf>AddInt32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>total</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>add</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>sub</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>total</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=读写锁>读写锁</h2><p>锁本质上是将并行的代码串行化了，使用 lock 肯定会影响性能。因此在 Go 语言并发编程中，我们应该尽量减少使用锁，除非必须要使用。</p><p>即使是设计锁，那么也应该尽量的保证并行。串行是最后没有办法的方式。</p><p>常见的场景：我们有两组协程，其中一组负责写数据，另一个组负责读数据，web 系统中绝大部分场景都是<strong class=chinese>读多写少</strong>。</p><p>虽然有多个 goroutine，但是仔细分析我们会发现，读协程之间应该并发，读和写之间应该串行，写和写之间也不应该并行。这就是读写锁的一些特性。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>rwlock</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>RWMutex</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>wg</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>6</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>//写的goroutine
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=o>*</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=nx>rwlock</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span> <span class=c1>//加写锁，写锁会防止别的写锁获取，和读锁获取
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>defer</span> <span class=nx>rwlock</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;get write lock&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=o>*</span><span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 读的goroutine
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=nx>i</span><span class=o>:=</span><span class=mi>0</span><span class=p>;</span> <span class=nx>i</span><span class=p>&lt;</span><span class=mi>5</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>rwlock</span><span class=p>.</span><span class=nf>RLock</span><span class=p>()</span> <span class=c1>//加读锁， 读锁不会阻止别人的读
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>500</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;get read lock&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=nx>rwlock</span><span class=p>.</span><span class=nf>RUnlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}()</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>写锁 <code>rwlock.Lock() </code>，会阻止别的<strong class=chinese>写入</strong>和<strong class=chinese>读取</strong>。</li><li>读锁 <code>rwlock.RLock()</code>，不会阻止别的<strong class=chinese>读取</strong>。</li></ul><p>上面的示例程序模拟了读写之间的操作。一开始读取的协程不断执行读取操作，直到写入的协程拿到写锁，则读取操作就被阻塞，一直不能被执行，直到写锁被释放。</p><h2 id=goroutine-互相通信>goroutine 互相通信</h2><p>通过 channel 在不同的 goroutine 之间进行通信。</p><p>Go 语言编程的哲学：<strong>不要通过共享内存来通信，而要通过通信来实现内存共享</strong>。</p><p>php、python、java 等其他语言进行多线程编程时，两个线程之间通信最常用的方式就是使用一个全局变量。也会提供消息队列的机制，比如 python 中的 queue，最常见的模式就是<strong class=chinese>消费者和生产者</strong>的模型。</p><p>Go 语言也是首选这种消息队列的模式，它是使用 channel 通道来实现这些功能。</p><p>Go 语言为了推广这种模式在 channel 的基础上，加上语法糖 <code>&lt;-</code>，让 channel 的使用更加简单。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>msg</span> <span class=kd>chan</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//有缓冲和无缓冲的channel
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>msg</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>string</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=c1>//channel的初始化值 如果为0的话，你放值进去会阻塞
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//msg = make(chan string, 0) //无缓冲的channel
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//msg = make(chan string, 10) //有缓冲的channel
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>msg</span> <span class=kd>chan</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>        <span class=nx>data</span> <span class=o>:=</span> <span class=o>&lt;-</span> <span class=nx>msg</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}(</span><span class=nx>msg</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>msg</span> <span class=o>&lt;-</span> <span class=s>&#34;bobby&#34;</span><span class=c1>//放值到channel中
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// waitgroup 如果少了done调用，容易出现deadlock， 无缓冲的channel也容易出现
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=o>*</span><span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>无缓冲的 channel 必须使用一个 goroutine 来读取通道中的值，否则会死锁。goroutine 有一种 happen-before 的机制，可以保障无缓冲的通道中的读取数据和写入数据的先后顺序。</p><ul><li>无缓冲 channel 适用于通知， B 要第一时间知道 A 是否已经完成。</li><li>有缓冲 channel 适用于消费者和生产者之间的通信。</li></ul><p>Go 中 channel 的应用场景：</p><ol><li>消息传递、消息过滤</li><li>信号广播</li><li>事件订阅和广播</li><li>任务分发</li><li>结果汇总</li><li>并发控制</li><li>同步和异步</li></ol><h2 id=channel-的遍历>channel 的遍历</h2><p>如果生产者和消费者都不断地往通道 channel 中发送和接收数据，则需要使用循环来遍历这个 channel。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>msg</span> <span class=kd>chan</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=c1>//又缓冲和无缓冲的channel
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//channel的初始化值 如果为0的话，你放值进去会阻塞
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>msg</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=c1>//go有一种happen-before的机制， 可以保障
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>msg</span> <span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>data</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>msg</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;all done&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}(</span><span class=nx>msg</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>msg</span> <span class=o>&lt;-</span> <span class=mi>1</span><span class=c1>//放值到channel中
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>msg</span> <span class=o>&lt;-</span> <span class=mi>2</span><span class=c1>//放值到channel中
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nb>close</span><span class=p>(</span><span class=nx>msg</span><span class=p>)</span> <span class=c1>//其他的编程语言有很大的区别
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>d</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>msg</span> <span class=c1>//已经关闭的channel可以继续取值，但是不能再放值了
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>d</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>//msg &lt;- 3//放值到channel中， 已经关闭的channel不能再放值了
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=o>*</span><span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在以上的例子中，如果不使用，</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>for</span> <span class=nx>data</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>msg</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>打印输出，只是使用 <code>d := &lt;- msg</code> 读出一个数据，则 <code>msg &lt;- 2</code> 就会一直在阻塞中，不会被打印出来。</p><p>同理，如果只放入了一个数据 <code>msg &lt;- 1</code>，并且有两次读出 <code>d := &lt;-msg</code>，则第二次读出会被阻塞。</p><p>因此，直接使用 <code>for range</code> 方法是最方便的，正如例子中的写法一样。</p><p>在使用 <code>for range</code> 遍历通道时，可以通过 <code>close(msg)</code> 关闭通道来告诉循环，不需要再取值了，循环就可以退出了，打印出 <code>all done</code> 否则循环将阻塞等待下一个数据的到来。</p><p>这里的 <code>close(msg)</code> 关闭通道的用法是与其他语言有很大的区别。</p><p>已经关闭的 channel 可以继续取值，但是不能再放值了。即放值会报错，而取值不会报错。</p><h2 id=单向-channel>单向 channel</h2><p>默认情况下， channel 是双向的。但是，我们经常一个 channel 作为参数进行传递，希望对方是单向使用。</p><p>比如，我传递一个 channel 给对方，我只希望对象从 channel 中读取数据而不会写入数据，这时候就需要使用单向 channel 了。</p><p>单向 channel 的定义方式与默认的双向 channel 定义方式有所不同。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>ch1</span> <span class=kd>chan</span> <span class=kt>int</span> <span class=c1>// 双向channel
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>ch2</span> <span class=kd>chan</span><span class=o>&lt;-</span> <span class=kt>float64</span> <span class=c1>// 单向channel，只能写入float64类型的数据
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>ch3</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>int</span> <span class=c1>// 单向channel， 只能读取int类型的数据
</span></span></span></code></pre></div><p>当然还有一种方式，定义的是默认双向 channel ，但是可以转换成单向 channel。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>c</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span> <span class=c1>// 定义缓冲区为3的双向channel
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>send</span> <span class=kd>chan</span><span class=o>&lt;-</span> <span class=kt>int</span> <span class=p>=</span> <span class=nx>c</span> <span class=c1>// 只能发送数据
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>read</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>int</span> <span class=p>=</span> <span class=nx>c</span> <span class=c1>// 只能接收数据
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>send</span> <span class=o>&lt;-</span> <span class=mi>1</span>  <span class=c1>// 发送数据1 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>&lt;-</span> <span class=nx>read</span>  <span class=c1>// 接收数据
</span></span></span></code></pre></div><p>值得注意的是，双向 channel 可以转成单向 channel，正如上述这种方式（自动完成转换）。但是单向 channel 不能转回双向 channel。</p><p>此外，单向 channel 只能执行单向操作，反向操作则会报错。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>send</span> <span class=kd>chan</span><span class=o>&lt;-</span> <span class=kt>int</span> <span class=p>=</span> <span class=nx>c</span> <span class=c1>// 只能发送数据
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>&lt;-</span> <span class=nx>send</span> <span class=c1>// send不能接收数据，编译器会报错
</span></span></span></code></pre></div><p>下面是一个单向 channel 常用的应用场景。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>producer</span><span class=p>(</span><span class=nx>out</span> <span class=kd>chan</span><span class=o>&lt;-</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span><span class=o>:=</span><span class=mi>0</span><span class=p>;</span> <span class=nx>i</span><span class=p>&lt;</span><span class=mi>10</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>out</span> <span class=o>&lt;-</span> <span class=nx>i</span><span class=o>*</span><span class=nx>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nb>close</span><span class=p>(</span><span class=nx>out</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>consumer</span><span class=p>(</span><span class=nx>in</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>num</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>in</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;num=%d\r\n&#34;</span><span class=p>,</span> <span class=nx>num</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>producer</span><span class=p>(</span><span class=nx>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>consumer</span><span class=p>(</span><span class=nx>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>10</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span> <span class=c1>// 防止主函数先结束
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>在上述的例子中，定义了一个双向 channel <code>c</code>，传入两个不同的函数 <code>producer</code> 和 <code>consumer</code> 中，系统自动将 <code>c</code> 转换成对应的单向 channel。</p><p>以上例子这样写法的优点，在于可以约束函数中的 channel 操作方式，在 producer 中就只能<strong class=chinese>写</strong>而不能<strong class=chinese>读</strong>，在 consumer 中就只能<strong class=chinese>写</strong>而不能<strong class=chinese>读</strong>，即使它们传递都是同一个双向通道 <code>c</code>。</p><h2 id=channel-实现交叉打印>channel 实现交叉打印</h2><p>这是一道常见的<strong class=chinese>面试题</strong>。</p><p>题目如下所示。</p><blockquote><p>使⽤两个 goroutine 交替打印序列，⼀个 goroutine 打印数字，另外⼀个 goroutine 打印字⺟，最终效果如下：<code>12AB34CD56EF78GH910IJ1112KL1314MN1516OP1718QR1920ST2122UV2324WX2526YZ2728</code></p></blockquote><p>这道题目的难点在于，如何通知到两个 goroutine 对方已经结束，可以进行输出，来保证输出的交替顺序。</p><p>最好的方式就是通过 channel 来通知。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>number</span><span class=p>,</span> <span class=nx>letter</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>bool</span><span class=p>),</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>printNum</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=p>;</span> <span class=nx>i</span> <span class=o>+=</span> <span class=mi>2</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=o>&lt;-</span> <span class=nx>number</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%d%d&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>i</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>letter</span> <span class=o>&lt;-</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>printLetter</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>str</span> <span class=o>:=</span> <span class=s>&#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=p>;</span> <span class=nx>i</span> <span class=o>+=</span> <span class=mi>2</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=o>&lt;-</span> <span class=nx>letter</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>i</span> <span class=o>&gt;=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>str</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Print</span><span class=p>(</span><span class=nx>str</span><span class=p>[</span><span class=nx>i</span><span class=p>:</span><span class=nx>i</span><span class=o>+</span><span class=mi>2</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=nx>number</span> <span class=o>&lt;-</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>printNum</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>printLetter</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>number</span> <span class=o>&lt;-</span> <span class=kc>true</span>  <span class=c1>// 首先打印数字
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span> <span class=o>*</span><span class=mi>100</span><span class=p>)</span>  <span class=c1>// 防止主函数先退出
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h2 id=select-的用法>select 的用法</h2><p>在并发编程中，select 常常用于监控 goroutine 执行。</p><p>select 语句类似于 switch case 语句，select 的功能和我们操作 linux 中网络 io 的 select、poll、epoll 类似，但是 select 更多地作用于多个 channel 中。</p><p>例如，现在有个需求，同时有两个 goroutine 都在执行，在主的 goroutine 中，我们如何立刻知道任何一个 goroutine 执行完成。</p><p>有一种非常简单的思路就是，通过一个全局的变量来标识子 goroutine 是否完成。但是这就需要主函数中有一个循环不断地检查这个全局变量是否改变，十分消耗电脑的资源。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>done</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>lock</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>g1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>lock</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>lock</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>done</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>g2</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>lock</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>lock</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>done</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>g1</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>g2</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>done</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;done&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>10</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>以上使用共享变量的方式是不被推荐的，遇到类似的这种需求，我们应该使用 select 配合 channel 来实现。</p><p><strong class=chinese>思路</strong>：给两个 goroutine 分配一个共享 channel（Go 语言中的 channel 是多线程安全的，所以不用担心冲突），当 goroutine 完成时就往 channel 中写入一个数据，代表已完成。而主函数中则通过 select 语言来监控 channel 是否更新（被写入数据），如果写入了数据则说明这个 goroutine 已经完成了。</p><p>channel 的类型，常用的有 <code>bool</code> 类型，但是实际上我们也可以使用空结构体类型 <code>struct{}</code>，这样将会更加<strong class=chinese>省空间</strong>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// var done chan struct{} // 未初始化
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>done</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span> <span class=c1>// channel一定要初始化
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>g1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>done</span> <span class=o>&lt;-</span> <span class=kd>struct</span><span class=p>{}{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>g2</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>done</span> <span class=o>&lt;-</span> <span class=kd>struct</span><span class=p>{}{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>g1</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>g2</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;-</span> <span class=nx>done</span> <span class=c1>// 阻塞接收
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;done&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>以上例子的需求是，只需要通知到有任何一个 goroutine 完成了就可以了。但是在实际情况中，我们可能需要分别区别两个 goroutine 是否完成。</p><p>这时候不能再使用一个全局的共享 channel，而是需要用到两个 channel 来分别标识两个 goroutine 的完成情况。</p><p>此时，就不用使用之前的 <code>&lt;- done</code> 来同时阻塞接收两个不同的 channel，因此就需要使用 select 语句了，类似于网络 io 的轮询策略（select、poll、epoll）。</p><p>select 会先选择已经就绪的 channel（数据先传递过来），然后接着执行后续语句。</p><p>同时需要注意的点：</p><ol><li>某一个分支就绪了就执行该分支</li><li>如果两个都就绪了，先执行哪个？ <strong class=chinese>随机的</strong>。目的是什么： <strong class=chinese>防止饥饿</strong>（有一个 channel 一直不能被接收）</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>g1</span><span class=p>(</span><span class=nx>ch</span> <span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>2</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>ch</span> <span class=o>&lt;-</span> <span class=kd>struct</span><span class=p>{}{}</span> <span class=c1>// 结构体实例
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>g2</span><span class=p>(</span><span class=nx>ch</span> <span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>3</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>ch</span> <span class=o>&lt;-</span> <span class=kd>struct</span><span class=p>{}{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>g1Channel</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{},</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>g2Channel</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{},</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>//g1Channel &lt;- struct{}{}
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//g2Channel &lt;- struct{}{}
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>go</span> <span class=nf>g1</span><span class=p>(</span><span class=nx>g1Channel</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>g2</span><span class=p>(</span><span class=nx>g2Channel</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>timer</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>NewTimer</span><span class=p>(</span><span class=mi>5</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=o>&lt;-</span> <span class=nx>g1Channel</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;g1 done&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=o>&lt;-</span> <span class=nx>g2Channel</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;g2 done&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=o>&lt;-</span> <span class=nx>timer</span><span class=p>.</span><span class=nx>C</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;timeout&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>为了防止两个子 goroutine 同时阻塞，导致主函数也一直阻塞，select 语句也可以使用 default 分支，但是 default 分支会导致其他 case 不会被执行。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=o>&lt;-</span> <span class=nx>g1Channel</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;g1 done&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=o>&lt;-</span> <span class=nx>g2Channel</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;g2 done&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;default&#34;</span><span class=p>)</span> <span class=c1>// 程序只会输出default
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>一种的解决方式就是在 select 外再套一层 for 循环，使用 timer 的定时功能</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>deadline</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Add</span><span class=p>(</span><span class=mi>5</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span> <span class=c1>// 设置超时时间
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=o>&lt;-</span> <span class=nx>g1Channel</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;g1 done&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=o>&lt;-</span> <span class=nx>g2Channel</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;g2 done&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>After</span><span class=p>(</span><span class=nx>deadline</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// 检查是否超时
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;timeout&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>10</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=p>)</span> <span class=c1>// 防止CPU占用过高
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>一种更加<strong class=chinese>简洁且常用</strong>的方式是使用 <code>timer.C</code>，来设置超时退出。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>timer</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>NewTimer</span><span class=p>(</span><span class=mi>5</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span> <span class=c1>// 使用time.Timer实现超时控制
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>defer</span> <span class=nx>timer</span><span class=p>.</span><span class=nf>Stop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>g1Channel</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;g1 done&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>g2Channel</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;g2 done&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>timer</span><span class=p>.</span><span class=nx>C</span><span class=p>:</span> <span class=c1>// 超时
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;timeout&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=context-的用法>context 的用法</h2><p>context 是 Go 语言并发编程中最重要的一个知识点。它与现有其他编程语言有着十分明显的差异。</p><p>考虑下面这个需求：我们需要有一个 goroutine 来监控 CPU 的信息。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>wg</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>cpuInfo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>2</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;cpu的信息&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>cpuInfo</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;监控完成&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>以上代码可以完成一个及其简单的模拟获取 CPU 信息的程序。现在我们有一个新的需求：我可以主动退出监控程序。</p><p>这时候我们可以想到的最简单的方式就是使用<strong class=chinese>共享变量</strong>（虽然并不推荐）。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>wg</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>stop</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>cpuInfo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>stop</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>2</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;cpu的信息&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>cpuInfo</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>6</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>stop</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;监控完成&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><blockquote><p>需要注意的是，在操作共享变量 <code>stop</code> 时最好加上读写锁。</p></blockquote><p>然而，共享变量的方式是不被推荐的，最推荐的方法还是应该使用 channel。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>wg</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>stop</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>cpuInfo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=o>&lt;-</span> <span class=nx>stop</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;退出CPU监控&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>2</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;cpu的信息&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>cpuInfo</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>6</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>stop</span> <span class=o>&lt;-</span> <span class=kd>struct</span><span class=p>{}{}</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;监控完成&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>以上这种代码在实际的开发中是十分常见的。我们将 select 语句放入子 goruntine 中而不是上一节讲解的主函数中，上一节是通过 select 来监控子 goruntine 的完成情况，而这一部分代码则是在子 goroutine 中接收主函数传递的控制信息，根据控制信息来执行对应的操作。</p><p>由此可知，select 语言既可以写在主 goroutine 中，也可以写在子 goroutine 中，两者的作用是不一样的。说明 select 语句可以监控双向的 channel。</p><blockquote><p>需要注意的是，如果将上述代码中的全局变量 stop 改为主函数中的变量，通过参数传递让子 goroutine 能够访问到，这种方式更加<strong class=chinese>优雅</strong>。</p></blockquote><p>如果想要让当前这个程序编写得更加优雅，更加符合实际的开发。这时候就需要使用到 context 了。</p><p>使用了 context 就不需要将控制信息通过 channel 进行传递了，而是使用 context 中自带的<strong class=chinese>监控</strong>和<strong class=chinese>控制</strong>方法。</p><p>context 包提供了三种函数：<code>WithCancel</code>， <code>WithTimeout</code>，<code>WithValue</code>。本质上就是返回三个不同的结构体。</p><p>如果在你的 goroutine / 函数中，希望被<strong>控制，超时、传值</strong>，但不希望影响原来的<strong class=chinese>接口信息</strong>时，函数参数中<strong class=chinese>第一个参数</strong>就尽量的要加上一个<strong>ctx</strong>。</p><p>比如，我希望 6 秒后通过主函数发送一个<strong class=chinese>取消</strong>指令，让子 goroutine 取消监控 CPU，则可以使用 <code>WithCancel</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>wg</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>cpuInfo</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=o>&lt;-</span> <span class=nx>ctx</span><span class=p>.</span><span class=nf>Done</span><span class=p>():</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;退出cpu监控&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>2</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;cpu的信息&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 1. 主动取消
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>ctx</span><span class=p>,</span> <span class=nx>cancel</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithCancel</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>cpuInfo</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>6</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>cancel</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;监控完成&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>context 是一个树形结构，<code>context.Background()</code> 就是根节点的 context。我们传递子 context 也依旧可以满足需求。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>wg</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>cpuInfo</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=o>&lt;-</span> <span class=nx>ctx</span><span class=p>.</span><span class=nf>Done</span><span class=p>():</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;退出cpu监控&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>2</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;cpu的信息&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 1. WithCancel 主动取消
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>ctx1</span><span class=p>,</span> <span class=nx>cancel1</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithCancel</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=nx>ctx2</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithCancel</span><span class=p>(</span><span class=nx>ctx1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>cpuInfo</span><span class=p>(</span><span class=nx>ctx2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>6</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>cancel1</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;监控完成&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在上述这个代码中，我们通过参数传递返回了一个子的 context <code>ctx2</code>，将 <code>ctx2</code> 传递给子 goroutine 依旧可以成功运行。这是因为 context 是一个树形结构，当我们调用了根的 <code>cancel1()</code>，它会逐层将子的 context 的 <code>cancel</code> 方法一起调用，因此传递 <code>ctx2</code> 也可以起作用。</p><p>context 还其他几个用法，如下面的例子所示，可以通过 <code>WithTimeout</code> 方法来代替手动写的 <code>time.Sleep(6 * time.Second)</code>。也可以使用 <code>WithDeadline</code> 方法来指定在某个时间取消。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>wg</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>cpuInfo</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=o>&lt;-</span> <span class=nx>ctx</span><span class=p>.</span><span class=nf>Done</span><span class=p>():</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;退出cpu监控&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>2</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;cpu的信息&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>//2. WithTimeout 主动超时取消
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>ctx</span><span class=p>,</span> <span class=nx>cancel</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithTimeout</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>(),</span> <span class=mi>6</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>//3. WithDeadline 在时间点取消
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(6*time.Second))
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>defer</span> <span class=nf>cancel</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>cpuInfo</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;监控完成&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>下面的例子展示的是，通过 <code>WithValue</code> 方法来代替 channel 向 goroutine 中传递数据。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>wg</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>ctxKey</span> <span class=kt>string</span> <span class=c1>// 自定义一个string类型 防止上下文冲突
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>cpuInfo</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 我们希望在这里能拿到一个请求的id
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;tracid: %s\r\n&#34;</span><span class=p>,</span> <span class=nx>ctx</span><span class=p>.</span><span class=nf>Value</span><span class=p>(</span><span class=nf>ctxKey</span><span class=p>(</span><span class=s>&#34;traceid&#34;</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 常用于 记录一些日志 这次请求是哪个traceid打印的 方便调试
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=o>&lt;-</span> <span class=nx>ctx</span><span class=p>.</span><span class=nf>Done</span><span class=p>():</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;退出cpu监控&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>2</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;cpu的信息&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>//2. WithTimeout 主动超时取消
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>ctx</span><span class=p>,</span> <span class=nx>cancel</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithTimeout</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>(),</span> <span class=mi>6</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nf>cancel</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1>//4. WithValue 传递数据
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>valueCtx</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithValue</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nf>ctxKey</span><span class=p>(</span><span class=s>&#34;traceid&#34;</span><span class=p>),</span> <span class=s>&#34;gjw12j&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>cpuInfo</span><span class=p>(</span><span class=nx>valueCtx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;监控完成&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><blockquote><p>这里推荐自己定义一个自定义类型作为<strong>键值（Key）</strong>，如 <code>type ctxKey string</code>。</p><p>这是因为在 Go 中，<code>context.WithValue</code> 的键（key）通常是一个接口类型，但为了确保键的唯一性，建议使用自定义类型（通常是结构体类型）。如果直接使用内置类型（如 <code>string</code>），可能会导致不同代码片段之间使用相同的键值对，从而引发冲突。</p><p>例如，如果多个开发者在不同的地方都使用了 <code>"id"</code> 作为键，那么上下文中的值可能会被意外覆盖，导致不可预测的行为。</p></blockquote><p>在上述这个代码中，我们通过 <code>WithValue</code> 避免了通过函数参数或者 channel 来向函数中传递数据，如果使用函数参数来传递数据，则会使整个程序代码不好维护和阅读。</p><p>并且将 ctx 作为 <code>WithValue</code> 参数传递进去，使得 valueCtx 是 ctx 的子 context，这样就可以同时完成两种操作（<strong class=chinese>超时取消</strong>和<strong class=chinese>传递数据</strong>）。</p><blockquote><p>valueCtx 会集成 ctx 的超时功能，同时携带所需要的数据，而 ctx 只带有超时取消的功能，因此只能是 <code>go cpuInfo(valueCtx)</code>，否则使用 ctx 将无法获取到传递的数据。</p><p>这不同于<strong>根 cancel 方法</strong>会触发<strong>子 cancel 方法</strong>一同执行。</p></blockquote><p>通过以上几个示例代码，我们可以很清楚地了解到 context 的优点：我们几乎没有对业务代码进行较大的改动，只是通过更换 context 的不同方法，就可以实现不同的功能。</p><h2 id=gmp-调度原理>GMP 调度原理</h2><p><img src=https://cdn.pi3.fun/blog/202502142311963.png alt=image.png></p><p>尽量减少了全局锁带来的时间成本，利用排队和挂起机制，当有一个耗时 goroutine 时则将其挂起，把处理器和线程之间解除绑定，让线程可以空出来去执行其他 goroutine 操作，让处理器继续跟进它的后续执行流程。</p><p>GMP 的调度避免了线程之间的频繁切换，造成巨大的切换成本。它转而使用处理器来灵活处理 goroutine 和处理器之前的逻辑，提高了协程执行的速度。</p><p>GMP 是一个非常复杂的调用原理，这里只是进行简单的入门介绍，后续在其他笔记中会进行详细的说明解释和学习。</p><h2 id=mpg-并发模型>MPG 并发模型</h2><p>说到并发，初学者对于这个概念经常和并行混淆。其实我们可以从字面意思很容易的理解他们。并发，就是同时发生，而并行，就是同时进行。</p><p>以咖啡店为例，两人排两队同时点咖啡，而接到订单一个咖啡师做两杯咖啡，这是并发。两个咖啡师同时工作，每人做一杯咖啡，这是并行。同理回到程序中，多线程程序在单核上运行，就是并发；多线程程序在多核上运行，就是并行。</p><p>在操作系统提供的内核线程之上，Go 搭建了一个特有的两级线程模型。Go 的独立控制流不是内核级线程而是 goroutine 协程。Go 不推荐用共享内存的方式传递数据，而推荐使用 channel（或称“通道”）。channel 主要用来在多个 goroutine 之间传递数据，并且还会保证整个过程的并发安全性。</p><p>Go 语言的线程模型，也叫做 MPG 模型。它有 3 个核心元素，它们共同支撑起了这个模型的主框架。</p><ul><li><strong>M</strong>：<em>machine</em>的缩写。一个 M 代表一个内核线程，或称“工作线程”。</li><li><strong>P</strong>：<em>processor</em>的缩写。一个 P 代表执行一个 goroutine 和 Go 代码片段（函数）所必需的资源（或称“上下文环境”）。</li><li><strong>G</strong>：<em>goroutine</em>的缩写。一个 G 代表一个用户级线程，它由 go 程序调度而不由内核调度。</li></ul><p>首先<strong class=chinese>一个</strong>内核级线程<strong>M</strong>会与<strong class=chinese>一个</strong>或<strong class=chinese>多个</strong>上下文环境<strong>P</strong>关联，<strong>每个 P</strong>都会包含<strong class=chinese>一个</strong>可运行的<strong>G</strong>的队列（runq），因此<strong>一个 P</strong>下会有<strong>多个 G</strong>排队运行。该队列中的 G 会被依次传递给与本地 P 关联的 M，并获得运行时机。</p><p>把运行当前 G 的那个 M 称为“<strong>当前 M</strong>”，并把与当前 M 关联的那个 P 称为“<strong>本地 P</strong>”。因此一个 M 会包含和管理多个 G。</p><p>M、P 和 G 之间的联系如图所示。</p><p><img src=https://cdn.pi3.fun/blog/202502142312582.png alt=image.png></p><p>M 与 KSE 之间总是一对一的关系，一个 M 能且仅能代表一个内核线程。Go 的运行时系统（runtime system）用 M 代表一个内核调度实体。M 与 KSE 之间的关联非常稳固，一个 M 在其生命周期内，会且仅会与一个 KSE 产生关联。</p><p>M 与 P 之间也总是一对一的（<strong>在运行过程中 M 可能会从本来的关联 P 1 变为关联 P 2，但同一时刻一个 M 总是只关联一个 P</strong>），而 P 与 G 之间则是一对多的关系（这些 G 被放在了 P 的一个队列中）。所以 M 和 G 是一对多关系，但是同一时刻一个 M 只能运行一个 G。M、P 和 G 之间的关系在实际调度过程中是多变的。</p><p>Go 如何控制 M 对 G 的调度是由 Go 的运行时系统（runtime system）决定的。运行时系统就是 goroutine 的调度器 (<a href=#GMP%20%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86>GMP 调度原理</a>)，它的代码在 go 的 runtime 包中，充当着类似内核的作用。</p><p>对于一个运行的 GO 程序，在调度器内部存在着：</p><ol start=3><li>全局 M，P，G 列表，分别用于记录当前所有的 M，P，G 信息；</li><li>空闲 M，P，G 列表，分别用于记录当前空闲可调度的 M，P，G 信息，以减少 M，P，G 的创建从而提升性能；</li><li>可运行 G 列表，存放等待调度器分配给 P 的 G。</li></ol><p>MPG 调度器只关注单独的 Go 程序中的 Goroutine。Go 语言的 Goroutine 采用的是<strong class=chinese>半抢占式</strong>的协作调度，只有在 <code>G0</code> 发生阻塞时才会导致调度，否则会依次执行 P 绑定的其他 G。</p><p>当 <code>G0</code> 阻塞时，调度器会将 P 与当前的 <code>M0</code> 和 <code>G0</code> 解绑，同时去空闲 M 列表中找新的 M，如果没有则创建 <code>M1</code>，绑定 P，顺序执行P下的G。</p><p><img src=https://cdn.pi3.fun/blog/202502142312479.png alt=image.png></p><p>当 <code>G0</code> 阻塞结束后，调度器会到空闲 P 列表中为 <code>M0</code> 找空闲可绑定的 P，如果恰巧有 P，则继续执行 <code>G0</code>。</p><p><img src=https://cdn.pi3.fun/blog/202502142312809.png alt=image.png></p><p>如果没有可用的 P，则如下图所示：（注意：这个过程中，<code>M1</code> 和 <code>M0</code> 可能并行）</p><p><img src=https://cdn.pi3.fun/blog/202502142312558.png alt=image.png></p><p><code>M0</code> 被放入空闲列表，等待调度给需要的 G；<code>G0</code> 被放入可运行的 G 列表，列表中的 G 会经由调度再次放入某个 P 的可运行 G 队列（等待再次运行）。</p><p>至此一个简单的 MPG 流程就完成了。实际程序运行在多核下，同时会创建更多的协程，但是 MPG 的调度流程是一样的。</p><h2 id=并发安全性>并发安全性</h2><p>Go 语言的并发安全性，依旧是通过<strong class=chinese>锁机制</strong>和<strong class=chinese>原子操作</strong>来实现的。正如笔记前半部分中的 <a href=#waitgroup>waitgroup</a>、<a href=#%E4%BA%92%E6%96%A5%E9%94%81>互斥锁</a>、<a href=#%E8%AF%BB%E5%86%99%E9%94%81>读写锁</a>以及 sync 包和 atomic 包的用法，在并发编程中十分常见，目的就是保证并发的安全性。</p><p>虽然在代码中加入锁可能会影响性能，但是实际上影响并没有想象中的那么严重。切不可以一味追求程序运行性能而舍弃了并发的安全性，该加锁时还是应该加锁。当然能够通过其他方式优化，避免锁的使用，那是再好不过了。</p><ul><li><a href=https://blog.csdn.net/weixin_57023347/article/details/137814308>Go并发安全，锁和原子操作</a></li><li><a href=https://mytechshares.com/2021/02/01/talk-go-concurrency-safe/>聊聊 Go 并发安全 | 董泽润的技术笔记</a></li></ul></article><div class=paginator><a class=link href=https://blog.pi3.fun/post/2025/01/go%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/>← prev</a>
<a class=link href=https://blog.pi3.fun/post/2025/02/grpc%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/>next →</a></div><div class=comment><div id=tcomment></div><script src=https://registry.npmmirror.com/twikoo/1.6.39/files/dist/twikoo.min.js></script><script async>twikoo.init({envId:"https://twikoo.pi3.fun/.netlify/functions/twikoo",el:"#tcomment",lang:"zh-CN"})</script></div></main><footer id=footer><div><span style=display:flex;align-items:center><span style=margin-right:.5rem>© 2021 - 2025</span><img src=https://cdn.pi3.fun/static/rainbow.gif loading=lazy width=20 alt=rainbow><span style=margin-left:.5rem>By Liu Chao</span></span></div><div class=footnote><span><a href=https://www.foreverblog.cn/ target=_blank><img src=https://img.foreverblog.cn/logo_en_default.png style=width:auto;height:16px></a> | <a class=link href=https://blogscn.fun/ target=_blank><img src=https://photo.xiangming.site/img/blogscn.png style=width:auto;height:15px></a><br><a class=link href=/index.xml><span class="iconfont icon-RSS"></span></a> | <a class=link href=https://github.com/Pi3-l22 target=_ blank><span class="iconfont icon-GitHub"></span></a> | <a class=link href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank rel=noopener><span class="iconfont icon-creative-commons-fill"></span></a></span></div><div class=blog-icon></div></footer></div><script>document.addEventListener("DOMContentLoaded",function(){const n=localStorage.getItem("theme")||"light",e=document.querySelector('link[data-theme-style="light"]'),t=document.querySelector('link[data-theme-style="dark"]'),i=window.matchMedia("(prefers-color-scheme: dark)");i.addListener(function(n){if(!localStorage.getItem("theme")){const s=n.matches?"dark":"light";document.documentElement.setAttribute("data-theme",s),localStorage.setItem("theme",s),s==="light"?(e.media="all",t.media="not all"):(e.media="not all",t.media="all");const o=document.querySelector("iframe.giscus-frame");if(o){const e=s==="light"?"light_tritanopia":"dark_tritanopia";o.contentWindow.postMessage({giscus:{setConfig:{theme:e}}},"https://giscus.app")}}}),n==="light"?(e.media="all",t.media="not all"):(e.media="not all",t.media="all");function o(){const e=document.querySelector("iframe.giscus-frame");if(e){const t=n==="light"?"light_tritanopia":"dark_tritanopia";e.contentWindow.postMessage({giscus:{setConfig:{theme:t}}},"https://giscus.app")}else setTimeout(o,1e3)}o();const s=document.querySelector(".theme-toggle");s&&(s.textContent=n==="light"?"黑暗":"明亮",s.addEventListener("click",function(){const o=document.documentElement.getAttribute("data-theme"),n=o==="light"?"dark":"light";document.documentElement.setAttribute("data-theme",n),localStorage.setItem("theme",n),n==="light"?(e.media="all",t.media="not all"):(e.media="not all",t.media="all");const s=document.querySelector("iframe.giscus-frame");if(s){const e=n==="light"?"light_tritanopia":"dark_tritanopia";s.contentWindow.postMessage({giscus:{setConfig:{theme:e}}},"https://giscus.app")}this.textContent=n==="light"?"黑暗":"明亮"}))})</script><script src=https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){confetti({particleCount:150,spread:100})})</script></body></html>