<!doctype html><html lang=zh-cn><head><script>(function(){const e=localStorage.getItem("theme")||"light";document.documentElement.setAttribute("data-theme",e)})()</script><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=author content="LiuChao"><meta name=description content="gRPC基础入门知识点笔记"><link rel=icon href=https://blog.pi3.fun/favicon.ico><meta name=keywords content=" study  latex  life  academic "><meta property="og:url" content="https://blog.pi3.fun/post/2025/02/grpc-notes-basics/"><meta property="og:site_name" content="Pi3's Notes"><meta property="og:title" content="gRPC基础入门"><meta property="og:description" content="gRPC基础入门知识点笔记"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-02-25T00:00:00+00:00"><meta property="article:modified_time" content="2025-02-25T00:00:00+00:00"><meta property="article:tag" content="技术"><meta property="article:tag" content="Golang"><meta property="article:tag" content="GRPC"><link rel=canonical href=https://blog.pi3.fun/post/2025/02/grpc-notes-basics/><meta itemprop=name content="gRPC基础入门"><meta itemprop=description content="gRPC基础入门知识点笔记"><meta itemprop=datePublished content="2025-02-25T00:00:00+00:00"><meta itemprop=dateModified content="2025-02-25T00:00:00+00:00"><meta itemprop=wordCount content="14709"><meta itemprop=keywords content="技术,Golang,GRPC"><link media=screen rel=stylesheet href=https://blog.pi3.fun/css/common.css><link media=screen rel=stylesheet href=https://blog.pi3.fun/css/content.css><link media=screen rel=stylesheet href=https://blog.pi3.fun/css/theme.css><link media=screen rel=stylesheet href=https://blog.pi3.fun/css/iconfont/iconfont.css><link rel=stylesheet href=https://blog.pi3.fun/css/syntax/xcode.css data-theme-style=light media="(prefers-color-scheme: light)"><link rel=stylesheet href=https://blog.pi3.fun/css/syntax/catppuccin-mocha.css data-theme-style=dark media="not all"><title>gRPC基础入门 - Pi3's Notes</title>
<link rel=stylesheet href=https://blog.pi3.fun/css/single.css><link href=https://lf3-cdn-tos.bytecdntp.com/cdn/expire-100-y/KaTeX/0.15.2/katex.min.css rel=stylesheet><script defer src=https://lf3-cdn-tos.bytecdntp.com/cdn/expire-100-y/KaTeX/0.15.2/katex.min.js></script><script defer src=https://lf3-cdn-tos.bytecdntp.com/cdn/expire-100-y/KaTeX/0.15.2/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}],ignoredTags:["script","noscript","style","textarea","pre","code","option"],throwOnError:!1})})</script></head><body><div id=wrapper><header id=header><link rel=stylesheet href=https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkaibright/dist/LXGWBright-Regular/result.css><link rel=stylesheet href=https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkaibright/dist/LXGWBright-Italic/result.css><link rel=stylesheet href=https://chinese-fonts-cdn.deno.dev/packages/maple-mono-cn/dist/MapleMono-CN-Regular/result.css><h1><a href=https://blog.pi3.fun/>Pi3's Notes</a></h1><nav><span class=nav-bar-item><a class=link href=/>文章</a>
</span><span class=nav-bar-item><a class=link href=https://www.boyouquan.com/planet-shuttle>穿梭</a>
</span><span class=nav-bar-item><a class=link href=/about/>关于</a>
</span><span class=nav-bar-item><a class=link href=/links/>友链</a>
</span><span class=nav-bar-item><a class="link theme-toggle" href=javascript:void(0);>黑暗</a></span></nav></header><main id=main class=post><h1>gRPC基础入门</h1><div><b>Keywords: </b><a class=link href=https://blog.pi3.fun/tags/%E6%8A%80%E6%9C%AF>#技术</a>
<a class=link href=https://blog.pi3.fun/tags/golang>#Golang</a>
<a class=link href=https://blog.pi3.fun/tags/grpc>#gRPC</a></div><div><b>Release Date: </b><span>2025-02-25</span></div><details><summary><b>Table of Contents</b></summary><div class=toc><nav id=TableOfContents><ul><li><a href=#什么是-rpc>什么是 RPC</a></li><li><a href=#实现简单的-rpc>实现简单的 RPC</a></li><li><a href=#rpc-与-rest-对比>RPC 与 REST 对比</a></li><li><a href=#rpc-架构技术要点>RPC 架构技术要点</a></li><li><a href=#netrpc-快速上手>net/rpc 快速上手</a><ul><li><a href=#序列化协议改为-json>序列化协议改为 json</a></li><li><a href=#网络传输协议改为-http>网络传输协议改为 http</a></li><li><a href=#封装为本地调用的效果>封装为本地调用的效果</a></li></ul></li><li><a href=#什么是-grpc>什么是 gRPC</a></li><li><a href=#什么是-protobuf>什么是 protobuf</a></li><li><a href=#grpc-快速上手>gRPC 快速上手</a><ul><li><a href=#开发环境搭建>开发环境搭建</a></li><li><a href=#proto-文件编写>proto 文件编写</a></li><li><a href=#生成-api-接口>生成 API 接口</a></li><li><a href=#grpc-快速体验>gRPC 快速体验</a></li><li><a href=#grpc-四种数据模式>gRPC 四种数据模式</a></li></ul></li></ul></nav></div></details><article class=content><p>gRPC基础入门知识点笔记</p><h2 id=什么是-rpc>什么是 RPC</h2><p>RPC（Remote Procedure Call）远程过程调用，简单的理解是一个节点请求另一个节点提供的服务。</p><p>对应 RPC 的是本地过程调用，<strong class=chinese>函数调用</strong>是最常见的本地过程调用。</p><p>将<strong class=chinese>本地过程调用</strong>变成<strong class=chinese>远程过程调用</strong>也会面临各种问题。这些问题正是 RPC 和分布式服务需要解决的问题。</p><p>对于本地过程调用，就比如下方 Python 的一个函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>add</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>total</span> <span class=o>=</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>total</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>total</span> <span class=o>=</span> <span class=n>add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>total</span><span class=p>)</span>
</span></span></code></pre></div><p>函数调用的过程：</p><ol><li>将 1 和 2 压入 add 函数的栈中。</li><li>进入 add 函数，从栈中去除 1 和 2 分别赋值给 a 和 b。</li><li>执行 <code>a + b</code>，将结果赋值给局部的 total，并压栈。</li><li>将栈中的值取出来，赋值给全局的 total。</li></ol><p>如果将以上本地函数调用过程，转化成远程过程调用，就远远没有这么简单了，会复杂很多。</p><p>在远程调用时，我们需要执行的函数体是在远程的机器上的，也就是说，add 是在另一个进程中执行的。这就带来了几个新问题：</p><ol><li><strong>Call ID 映射</strong></li></ol><p>我们怎么告诉远程机器，我们要调用 <code>add</code>，而不是 <code>sub</code> 或者 <code>Foo</code> 呢？</p><p>在本地调用中，函数体是直接通过函数指针来指定的，我们调用 add，编译器就自动帮我们调用它相应的函数指针。</p><p>但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。所以，在 RPC 中，所有的函数都必须有自己的一个 ID。这个 ID 在所有进程中都是唯一确定的。</p><p>客户端在做远程过程调用时，必须附上这个 ID。然后我们还需要在客户端和服务端分别维护一个 <code>{函数 &lt;–> Call ID}</code> 的对应表。两者的表不一定需要完全相同，但相同的函数对应的 Call ID 必须相同。</p><p>当客户端需要进行远程调用时，它就查一下这个表，找出相应的 Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。</p><ol><li><strong class=chinese>序列化和反序列化</strong>⭐</li></ol><p>客户端怎么把参数值传给远程的函数呢？</p><p>在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。</p><p>但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言（比如服务端用 C++，客户端用 Java 或者 Python）。</p><p>这时候就需要客户端把参数先转成一个<strong class=chinese>字节流</strong>，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫<strong class=chinese>序列化</strong>和<strong class=chinese>反序列化</strong>。同理，从服务端返回的值也需要序列化反序列化的过程。</p><ol><li><strong class=chinese>网络传输</strong>⭐</li></ol><p>远程调用往往用在网络上，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。</p><p>网络传输层需要把 Call ID 和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。只要能完成这两者的，都可以作为传输层使用。</p><p>因此，它所使用的协议其实是不限的，能完成传输就行。尽管大部分 RPC 框架都使用<strong>TCP 协议</strong>，但其实<strong>UDP</strong>也可以，而<strong>gRPC</strong>干脆就用了<strong>HTTP 2</strong>（可以保持长连接，性能更好，更好的选择），Java 的 Netty 也属于这层的东西。也可以基于 UDP/TCP 协议自行封装网络传输协议。</p><p><img src=https://cdn.pi3.fun/blog/202502252023180.png alt=image.png></p><p>解决了上面三个机制，就能实现 RPC 了。</p><p>总的来说，RPC 最重要的两个点就是：<strong class=chinese>网络传输协议</strong>和<strong class=chinese>数据编码协议</strong>。</p><hr><p>举个例子，我们有一个电商系统，有一段扣减库存的逻辑，但是库存服务是一个独立的系统（运行在另一个远程服务器中），那么需要进行扣减库存操作就需要远程调用库存服务中的扣减函数，这样就一定会牵扯到网络传输方面的操作，因此需要做成一个 Web 服务（gin、beego、net/httpserver）</p><p>这个函数的调用参数就需要用序列化的字节流进行传递，比如常见的 json 格式，当然也有很多其他的协议规范：xml、protobuf、msgpack 等等。</p><p>序列化和反序列化是可以选择的，不一定要采用 json、xml、protobuf、msgpack，一些大型公司甚至会采用自己设计实现的传输协议。</p><blockquote><p>需要注意的是，json 协议虽然十分简单，但是它并不是一个高效的协议，因此对于微服务等大型项目中，它不是首选协议。</p></blockquote><p>总结来说，就是将函数调用的过程分布在两台服务器上，两台服务器需要先建立网络连接。调用方将所需要的函数 ID 和函数参数通过某一个协议序列化转递给执行方，执行方接收到序列化的数据流，先进行反序列化，再根据具体的要求执行函数，最后将执行后的结果同样通过序列化数据流传递回调用方。</p><p>调用方也可以称为是 client（客户端），执行方也可以称为 server（服务端）。、</p><p>客户端：</p><ol><li>建立连接 tcp/http</li><li>将 employee 对象序列化成 json 字符串 - 序列化</li><li>发送 json 字符串 - 调用成功后实际上你接收到的是一个二进制的数据</li><li>等待服务器发送结果</li><li>将服务器返回的数据解析成 PrintResult 对象 - 反序列化</li></ol><p>服务端：</p><ol><li>监听网络端口 80</li><li>读取数据 - 二进制的 json 数据</li><li>对数据进行反序列化 Employee 对象</li><li>开始处理业务逻辑</li><li>将处理的结果 PrintResult 序列化成 json 二进制数据 - 序列化</li><li>将数据返回</li></ol><hr><p>以下是客户端和服务端具体解决的问题。</p><p>client 端解决的问题：</p><ol><li>将这个调用映射为 Call ID。这里假设用最简单的字符串当 Call ID 的方法</li><li>将 Call ID，a 和 b 序列化。可以直接将它们的值以二进制形式打包</li><li>把 2 中得到的数据包发送给 ServerAddr，这需要使用网络传输层</li><li>等待服务器返回结果</li><li>如果服务器调用成功，那么就将结果反序列化，并赋给 total</li></ol><p>server 端解决的问题</p><ol><li>在本地维护一个 Call ID 到函数指针的映射 call_id_map，可以用 dict 完成</li><li>等待请求，包括多线程的并发处理能力</li><li>得到一个请求后，将其数据包反序列化，得到 Call ID</li><li>通过在 call_id_map 中查找，得到相应的函数指针</li><li>将 a 和 rb 反序列化后，在本地调用 add 函数，得到结果</li><li>将结果序列化后通过网络返回给 Client</li></ol><p>所以要实现一个 RPC 框架，其实只需要按以上流程实现就基本完成了。</p><p>其中：</p><ul><li>Call ID 映射可以直接使用函数字符串，也可以使用整数 ID。映射表一般就是一个哈希表。</li><li>序列化反序列化可以自己写，也可以使用 Protobuf 或者 FlatBuffers 之类的。</li><li>网络传输库可以自己写 socket，或者用 asio，ZeroMQ，Netty 之类。</li></ul><p>实际上真正的开发过程中，除了上面的基本功能以外还需要更多的细节：网络错误、流量控制、超时和重试等。</p><h2 id=实现简单的-rpc>实现简单的 RPC</h2><p>使用 Go 语言内置的 net/http 包来实现简单的 RPC 请求和返回（客户端和服务端）。</p><p>这里我们设计客户端通过 URL 来指定需要请求的函数 ID，通过 get 参数来指定传递的函数参数。当然也可以是通过 get 参数传递需要请求的函数 ID，通过 post 来传递函数的参数。</p><p>网络传输协议为 HTTP（底层是 TCP），数据编码协议为 json，数据传输协议为 URL 参数传递协议。</p><p>这里只使用最简单的方式进行演示。后续将直接使用 gRPC 包来进行 RPC 的编写。</p><p>服务端的代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 请求格式: http://127.0.0.1:8000/add?a=1&amp;b=2
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 返回格式: json {&#34;code&#34;:200,&#34;data&#34;:3}
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 1. CallID: r.URL.Path
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 2. 网络传输协议: http
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 3. 数据传输格式: URL
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>http</span><span class=p>.</span><span class=nf>HandleFunc</span><span class=p>(</span><span class=s>&#34;/add&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>_</span> <span class=p>=</span> <span class=nx>r</span><span class=p>.</span><span class=nf>ParseForm</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>URL</span><span class=p>.</span><span class=nx>Path</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>a</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>Atoi</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>Form</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=s>&#34;a&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=nx>b</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>Atoi</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>Form</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=s>&#34;b&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=nx>w</span><span class=p>.</span><span class=nf>Header</span><span class=p>().</span><span class=nf>Set</span><span class=p>(</span><span class=s>&#34;Content-Type&#34;</span><span class=p>,</span> <span class=s>&#34;application/json&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>jsonData</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Marshal</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span><span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;code&#34;</span><span class=p>:</span> <span class=mi>200</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;data&#34;</span><span class=p>:</span> <span class=nx>a</span> <span class=o>+</span> <span class=nx>b</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>})</span>
</span></span><span class=line><span class=cl>        <span class=nx>_</span><span class=p>,</span> <span class=nx>_</span> <span class=p>=</span> <span class=nx>w</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=nx>jsonData</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=nx>_</span> <span class=p>=</span> <span class=nx>http</span><span class=p>.</span><span class=nf>ListenAndServe</span><span class=p>(</span><span class=s>&#34;:8000&#34;</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>客户端请求的方式，可以是直接通过浏览器输入 <code>http://127.0.0.1:8000/add?a=1&amp;b=2</code> 进行 get 请求，返回结果会直接在浏览器中显示。</p><p><img src=https://cdn.pi3.fun/blog/202502252023641.png alt=image.png></p><p>同时也可以写一个客户端的程序，通过 Go 语言的 net/http 包完成 get 请求，当然使用第三方包 <code>github/kirinlabs/HttpRequest</code> 对于这种简单的请求会更加得方便。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>resp</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>http</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=s>&#34;http://127.0.0.1:8000/add?a=1&amp;b=2&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;请求失败: %v\n&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>resp</span><span class=p>.</span><span class=nx>Body</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>body</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>io</span><span class=p>.</span><span class=nf>ReadAll</span><span class=p>(</span><span class=nx>resp</span><span class=p>.</span><span class=nx>Body</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;读取响应失败: %v\n&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>result</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Unmarshal</span><span class=p>(</span><span class=nx>body</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>result</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;JSON 解析失败: %v\n&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>但是这样的写法，并不好，我们需要将<strong class=chinese>远程函数调用</strong>转化成<strong class=chinese>本地函数调用</strong>的形式，这样会更加方便复用。比如以下的写法，更加优秀。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>respData</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Data</span> <span class=kt>int</span> <span class=s>`json:&#34;data&#34;`</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>rpcAdd</span><span class=p>(</span><span class=nx>a</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>b</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>resp</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>http</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;http://127.0.0.1:8000/add?a=%d&amp;b=%d&#34;</span><span class=p>,</span> <span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;请求失败: %v\n&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>resp</span><span class=p>.</span><span class=nx>Body</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>body</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>io</span><span class=p>.</span><span class=nf>ReadAll</span><span class=p>(</span><span class=nx>resp</span><span class=p>.</span><span class=nx>Body</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;读取响应失败: %v\n&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>data</span> <span class=o>:=</span> <span class=nx>respData</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=nx>_</span> <span class=p>=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Unmarshal</span><span class=p>(</span><span class=nx>body</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>data</span><span class=p>.</span><span class=nx>Data</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span> <span class=o>:=</span> <span class=nf>rpcAdd</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>将网络请求和解析的逻辑封装在 <code>rpcAdd</code> 函数中，当主程序需要调用这个远程的函数时，只需要像本地函数一样，将参数通过函数形参传递给 <code>rpcAdd</code> 函数，就可以完成远程的函数调用。同时网络连接部分也可以进行进一步的封装。这也是 RPC 的精髓所在。</p><p>当然，以上的示例程序，只是一个非常简单的模拟代码，目的在于学习 RPC 基础的服务端和客户端调用逻辑，距离真正可用的 RPC 框架还有着很大的一段距离，实际工程的 RPC 是不可能这样编写的，还需要考虑性能、网络连接、数据传输等等问题，这里只是为了演示网络传输的流程。</p><h2 id=rpc-与-rest-对比>RPC 与 REST 对比</h2><ul><li><strong>RPC 与 REST 的区别是什么？</strong></li></ul><p>你一定会觉得这个问题很奇怪，是的，包括我。但是你在网络上一搜，会发现类似对比的文章比比皆是，我在想可能很多初学者由于基础不牢固，才会将不相干的二者拿出来对比吧。既然是这样，那为了让你更加了解陌生的 RPC，就从你熟悉得不能再熟悉的 REST 入手吧。</p><p>REST，是 Representational State Transfer 的简写，中文描述表述性状态传递（是指某个瞬间状态的资源数据的快照，包括资源数据的内容、表述格式 (XML、JSON) 等信息。）<br>REST 是一种软件架构风格。这种风格的典型应用，就是 HTTP。其因为简单、扩展性强的特点而广受开发者的青睐。</p><p>而 RPC 呢，是 Remote Procedure Call Protocol 的简写，中文描述是远程过程调用，它可以实现客户端像调用本地服务 (方法) 一样调用服务器的服务 (方法)。<br>而 RPC 可以基于 TCP/UDP，也可以基于 HTTP 协议进行传输的，按理说它和 REST 不是一个层面意义上的东西，不应该放在一起讨论，但是谁让 REST 这么流行呢，它是目前最流行的一套互联网应用程序的 API 设计标准，某种意义下，我们说 REST 可以其实就是指代 HTTP 协议。</p><ol><li><strong class=chinese>使用方式不同</strong></li></ol><p>从使用上来看，HTTP 接口只关注服务提供方，对于客户端怎么调用并不关心。
接口只要保证有客户端调用时，返回对应的数据就行了。而 RPC 则要求客户端接口保持和服务端的一致。</p><p>REST 是服务端把方法写好，客户端并不知道具体方法。客户端只想获取资源，所以发起 HTTP 请求，而服务端接收到请求后根据 URI 经过一系列的路由才定位到方法上面去 RPC 是服务端提供好方法给客户端调用，客户端需要知道服务端的具体类，具体方法，然后像调用本地方法一样直接调用它。</p><ol><li><strong class=chinese>面向对象不同</strong></li></ol><p>从设计上来看，RPC，所谓的远程过程调用，是面向方法的。REST，所谓的 Representational state transfer ，是面向资源的。</p><p>除此之外，还有一种叫做 SOA，所谓的面向服务的架构，它是面向消息的，这个接触不多，就不多说了。</p><ol><li><strong class=chinese>序列化协议不同</strong></li></ol><p>接口调用通常包含两个部分，<em>序列化</em>和<em>通信协议</em>。</p><p>通信协议，上面已经提及了，REST 是基于 HTTP 协议，而 RPC 可以基于 TCP/UDP，也可以基于 HTTP 协议进行传输的。</p><p>常见的序列化协议，有：json、xml、hession、protobuf、thrift、text、bytes 等，REST 通常使用的是 JSON 或者 XML，而 RPC 使用的是 JSON-RPC，或者 XML-RPC。</p><p>通过以上几点，我们知道了 REST 和 RPC 之间有很明显的差异。</p><ul><li><strong>为什么要采用 RPC 呢？</strong></li></ul><p>那到底为何要使用 RPC，单纯的依靠 RESTful API 不可以吗？为什么要搞这么多复杂的协议，渣渣表示真的学不过来了。</p><p>关于这一点，以下几点仅是我的个人猜想，仅供交流：</p><p>RPC 和 REST 两者的定位不同，REST 面向资源，更注重接口的规范，因为要保证通用性更强，所以对外最好通过 REST。而 RPC 面向方法，主要用于函数方法的调用，可以适合更复杂通信需求的场景。RESTful API 客户端与服务端之间采用的是同步机制，当发送 HTTP 请求时，客户端需要等待服务端的响应。当然对于这一点是可以通过一些技术来实现异步的机制的。采用 RESTful API，客户端与服务端之间虽然可以独立开发，但还是存在耦合。比如，客户端在发送请求的时，必须知道服务器的地址，且必须保证服务器正常工作。而 rpc + ralbbimq 中间件可以实现低耦合的分布式集群架构。</p><p>说了这么多，我们该如何选择这两者呢？我总结了如下两点，供你参考：</p><p>REST 接口更加规范，通用适配性要求高，建议对外的接口都统一成 REST。而组件内部的各个模块，可以选择 RPC，一个是不用耗费太多精力去开发和维护多套的 HTTP 接口，一个 RPC 的调用性能更高（见下条）从性能角度看，由于 HTTP 本身提供了丰富的状态功能与扩展功能，但也正由于 HTTP 提供的功能过多，导致在网络传输时，需要携带的信息更多，从性能角度上讲，较为低效。而 RPC 服务网络传输上仅传输与业务内容相关的数据，传输数据更小，性能更高。</p><ul><li><strong>为什么一定要 rpc，不能只学 http 协议和 restful 协议吗？</strong></li></ul><ol><li>rpc 可以基于 tcp 直接开发自己的协议，这个是可以保持长连接的，tcp 的传输效率高，并且可以一直维持链接</li><li>自定义协议可以优化数据的传输</li></ol><p>如果我们只是开发 web 网站或者一些服务的使用者，那么我们用 restful 看起来已经足够了，但是 rpc 的这种模式在大量的服务中都有，比如 redis 协议， rabbitmq 的 AMQP 协议，聊天软件的协议，也就是说我们想要开发一个 redis 的客户端，我们只需要用我们喜欢的语言实现 redis 定义的协议就行了，这对于开发服务来说非常有用，一般这种协议的价值在于我们自己开发的服务之间需要通信的时候 - 那你会问了，自己开发的组件之间协作，直接调用函数不就行了吗？</p><p>对了，有些人已经反映过来了：<strong class=chinese>分布式系统</strong>，分布式系统中非常常用，比如 openstack 中。还有就是微服务！</p><p>所以掌握 rpc 开发，对于进阶和分布式开发就变得非常重要。</p><p>http 协议 1. x 一般情况下一个来回就关闭连接，虽然提供了 keep-alive 可以保持长连接，但是依然不方便，所以就出现了 http 2.0， http 2.0 基本上可以当做 tcp 协议使用了。所以后面讲解到的 grpc 就会使用 http 2.0 开发</p><h2 id=rpc-架构技术要点>RPC 架构技术要点</h2><p>RPC 技术在架构设计上有四部分组成，分别是：<strong>客户端、客户端存根、服务端、服务端存根。</strong></p><ul><li><strong>客户端 (Client)</strong>：服务调用发起方，也称为服务消费者。</li><li><strong>客户端存根 (Client Stub)</strong>：该程序运行在客户端所在的计算机机器上，主要用来存储要调用的服务器的地址，另外，该程序还负责将客户端请求远端服务器程序的数据信息打包成数据包，通过网络发送给服务端 Stub 程序；其次，还要接收服务端 Stub 程序发送的调用结果数据包，并解析返回给客户端。</li><li><strong>服务端 (Server)</strong>：远端的计算机机器上运行的程序，其中有客户端要调用的方法。</li><li><strong>服务端存根 (Server Stub)</strong>：接收客户 Stub 程序通过网络发送的请求消息数据包，并调用服务端中真正的程序功能方法，完成功能调用；其次，将服务端执行调用的结果进行数据处理打包发送给客户端 Stub 程序。</li></ul><p>了解完了 RPC 技术的组成结构我们来看一下具体是如何实现客户端到服务端的调用的。实际上，如果我们想要在网络中的任意两台计算机上实现远程调用过程，要解决很多问题，比如：</p><ul><li>两台物理机器在网络中要建立稳定可靠的通信连接。</li><li>两台服务器的通信协议的定义问题，即两台服务器上的程序如何识别对方的请求和返回结果。也就是说两台计算机必须都能够识别对方发来的信息，并且能够识别出其中的请求含义和返回含义，然后才能进行处理。这其实就是通信协议所要完成的工作。</li></ul><p><img src=https://cdn.pi3.fun/blog/202502252023195.png alt=image.png></p><p>在上述图中，通过 1-10 的步骤图解的形式，说明了 RPC 每一步的调用过程。具体描述为：</p><ul><li>1、客户端想要发起一个远程过程调用，首先通过调用本地客户端 Stub 程序的方式调用想要使用的功能方法名；</li><li>2、客户端 Stub 程序接收到了客户端的功能调用请求，<strong>将客户端请求调用的方法名，携带的参数等信息做序列化操作，并打包成数据包。</strong></li><li>3、客户端 Stub 查找到远程服务器程序的 IP 地址，调用 Socket 通信协议，通过网络发送给服务端。</li><li>4、服务端 Stub 程序接收到客户端发送的数据包信息，并<strong>通过约定好的协议将数据进行反序列化，得到请求的方法名和请求参数等信息。</strong></li><li>5、服务端 Stub 程序准备相关数据，<strong>调用本地 Server 对应的功能方法进行，并传入相应的参数，进行业务处理。</strong></li><li>6、服务端程序根据已有业务逻辑执行调用过程，待业务执行结束，将执行结果返回给服务端 Stub 程序。</li><li>7、服务端 Stub 程序<strong class=chinese>将程序调用结果按照约定的协议进行序列化</strong>，并通过网络发送回客户端 Stub 程序。</li><li>8、客户端 Stub 程序接收到服务端 Stub 发送的返回数据，<strong class=chinese>对数据进行反序列化操作</strong>，并将调用返回的数据传递给客户端请求发起者。</li><li>9、客户端请求发起者得到调用结果，整个 RPC 调用过程结束。</li></ul><p>以下是 rpc 需要使用到的术语</p><p>通过上文一系列的文字描述和讲解，我们已经了解了 RPC 的由来和 RPC 整个调用过程。我们可以看到 RPC 是一系列操作的集合，其中涉及到很多对数据的操作，以及网络通信。因此，我们对 RPC 中涉及到的技术做一个总结和分析：</p><ul><li><strong>1、动态代理技术：</strong> 上文中我们提到的 Client Stub 和 Sever Stub 程序，在具体的编码和开发实践过程中，都是使用动态代理技术自动生成的一段程序。</li><li><strong>2、序列化和反序列化：</strong> 在 RPC 调用的过程中，我们可以看到数据需要在一台机器上传输到另外一台机器上。在互联网上，所有的数据都是以字节的形式进行传输的。而我们在编程的过程中，往往都是使用数据对象，因此想要在网络上将数据对象和相关变量进行传输，就需要对数据对象做序列化和反序列化的操作。<ul><li><strong class=chinese>序列化</strong>：把对象转换为字节序列的过程称为对象的序列化，也就是编码的过程。</li><li><strong class=chinese>反序列化</strong>：把字节序列恢复为对象的过程称为对象的反序列化，也就是解码的过程。</li></ul></li></ul><p>我们常见的 Json，XML 等相关框架都可以对数据做序列化和反序列化编解码操作。后面我们要学习的 Protobuf 协议，这也是一种数据编解码的协议，在 RPC 框架中使用的更广泛。</p><h2 id=netrpc-快速上手>net/rpc 快速上手</h2><p>Go 语言是有一个内置的 RPC 包：<code>net/rpc</code>，它虽然功能简单但是十分灵活。</p><p>以下是一个简单的服务端程序例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>HelloService</span> <span class=kd>struct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// HelloService的结构体方法
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>HelloService</span><span class=p>)</span> <span class=nf>Hello</span><span class=p>(</span><span class=nx>request</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>reply</span> <span class=o>*</span><span class=kt>string</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//返回值是通过修改reply的值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>*</span><span class=nx>reply</span> <span class=p>=</span> <span class=s>&#34;hello, &#34;</span> <span class=o>+</span> <span class=nx>request</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//1. 实例化一个server
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>listener</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>net</span><span class=p>.</span><span class=nf>Listen</span><span class=p>(</span><span class=s>&#34;tcp&#34;</span><span class=p>,</span> <span class=s>&#34;:1234&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>//2. 注册处理逻辑 handler
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>_</span> <span class=p>=</span> <span class=nx>rpc</span><span class=p>.</span><span class=nf>RegisterName</span><span class=p>(</span><span class=s>&#34;HelloService&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>HelloService</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>    <span class=c1>//3. 启动服务
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>conn</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>listener</span><span class=p>.</span><span class=nf>Accept</span><span class=p>()</span> <span class=c1>// 只处理一次逻辑
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>rpc</span><span class=p>.</span><span class=nf>ServeConn</span><span class=p>(</span><span class=nx>conn</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这里将处理的函数方法封装成一个<strong class=chinese>结构体方法</strong>，这是为了方便后续建立更多<strong class=chinese>同名方法</strong>，通过结构体可以区分不同的同名方法，起到限制作用域的功能。</p><p>对于客户端程序也是十分简单：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//建立连接
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>client</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>rpc</span><span class=p>.</span><span class=nf>Dial</span><span class=p>(</span><span class=s>&#34;tcp&#34;</span><span class=p>,</span> <span class=s>&#34;localhost:1234&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>panic</span><span class=p>(</span><span class=s>&#34;连接失败&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// var reply *string = new(string) 也是可以的，&amp;可以去掉
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>var</span> <span class=nx>reply</span> <span class=kt>string</span> <span class=c1>//string有默认值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>err</span> <span class=p>=</span> <span class=nx>client</span><span class=p>.</span><span class=nf>Call</span><span class=p>(</span><span class=s>&#34;HelloService.Hello&#34;</span><span class=p>,</span> <span class=s>&#34;bobby&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>reply</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>panic</span><span class=p>(</span><span class=s>&#34;调用失败&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>reply</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>观察以上两个服务端和客户端的程序代码，我们可以发现一连串的代码大部分都是 net 包，比如 <code>net.Listen</code> 、<code>listener.Accept()</code>、 <code>net.Dial</code> ，好像和 rpc 没有关系，那么我们能不能只使用 net 包呢？</p><p><strong class=chinese>当然不行</strong>。RPC 调用中有几个重要的问题需要解决：</p><ol><li>Call ID</li><li>序列化和反序列化（编码和解码）</li></ol><p>而这几个重要的问题，则是通过 <code>net/rpc</code> 内部自动完成了，所以一定还需要一个 rpc 框架，而不能只是使用网络传输的框架。</p><p>同时，以上的代码还有一个问题，就是客户端的函数调用并没有封装为本地函数调用的形式。在后续客户端有大量方法需要调用的时候，写起来就十分麻烦，没有一个统一的接口来处理逻辑。</p><p>而在上面的客户端代码中，我们始终是通过 <code>client.Call</code> 这个接口来调用所有的远程函数方法，这样的代码是不好的。我们希望调用方式改为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>client</span><span class=p>.</span><span class=nf>Hello</span><span class=p>(</span><span class=s>&#34;bobby&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>reply</span><span class=p>)</span>
</span></span></code></pre></div><p>而不是上述的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>client</span><span class=p>.</span><span class=nf>Call</span><span class=p>(</span><span class=s>&#34;HelloService.Hello&#34;</span><span class=p>,</span> <span class=s>&#34;bobby&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>reply</span><span class=p>)</span>
</span></span></code></pre></div><p>前面部分我们讲过，RPC 的精髓就是将远程函数调用封装为像本地函数调用一样方便，没有割裂感。因此，后续我们还需要对上面的代码调用进行一定程度的封装，使 RPC 调用更加方便。</p><h3 id=序列化协议改为-json>序列化协议改为 json</h3><p>这里还有一个问题值得思考：既然上述的 RPC 程序主要都是网络请求，那么是否可以跨语言调用呢？<strong class=chinese>本质上可以跨语言</strong></p><p>这里就需要注意两点：</p><ol><li>Go 语言的 RPC 的序列化协议是什么？<strong>Gob 协议</strong></li><li>能否将 Go 语言的 Gob 协议替换成常见的序列化协议？<strong class=chinese>可以的</strong></li></ol><p>实际上，将 Go 语言内置的 RPC 框架的序列化协议改成常见的 json 格式十分简单，只需要将上方服务端中的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>rpc</span><span class=p>.</span><span class=nf>ServeConn</span><span class=p>(</span><span class=nx>conn</span><span class=p>)</span>
</span></span></code></pre></div><p>更改为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>rpc</span><span class=p>.</span><span class=nf>ServeCodec</span><span class=p>(</span><span class=nx>jsonrpc</span><span class=p>.</span><span class=nf>NewServerCodec</span><span class=p>(</span><span class=nx>conn</span><span class=p>))</span>
</span></span></code></pre></div><p>再将客户端的代码更改为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>conn</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>net</span><span class=p>.</span><span class=nf>Dial</span><span class=p>(</span><span class=s>&#34;tcp&#34;</span><span class=p>,</span> <span class=s>&#34;localhost:1234&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>panic</span><span class=p>(</span><span class=s>&#34;连接失败&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>reply</span> <span class=kt>string</span> <span class=c1>//string有默认值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>client</span> <span class=o>:=</span> <span class=nx>rpc</span><span class=p>.</span><span class=nf>NewClientWithCodec</span><span class=p>(</span><span class=nx>jsonrpc</span><span class=p>.</span><span class=nf>NewClientCodec</span><span class=p>(</span><span class=nx>conn</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=nx>err</span> <span class=p>=</span> <span class=nx>client</span><span class=p>.</span><span class=nf>Call</span><span class=p>(</span><span class=s>&#34;HelloService.Hello&#34;</span><span class=p>,</span> <span class=s>&#34;bobby&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>reply</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>panic</span><span class=p>(</span><span class=s>&#34;调用失败&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>reply</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>即改为使用 <code>jsonrpc</code> 包的功能。</p><p>以上的服务端依旧只能处理一个请求，就会自动结束，可以加上一个死循环让它能够不断接收请求。同时为了让多个请求到达时并发处理，可以将 RPC 调用改成 goruntine。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>listener</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>net</span><span class=p>.</span><span class=nf>Listen</span><span class=p>(</span><span class=s>&#34;tcp&#34;</span><span class=p>,</span> <span class=s>&#34;:1234&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>_</span> <span class=p>=</span> <span class=nx>rpc</span><span class=p>.</span><span class=nf>RegisterName</span><span class=p>(</span><span class=s>&#34;HelloService&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>HelloService</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>conn</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>listener</span><span class=p>.</span><span class=nf>Accept</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>go</span> <span class=nx>rpc</span><span class=p>.</span><span class=nf>ServeCodec</span><span class=p>(</span><span class=nx>jsonrpc</span><span class=p>.</span><span class=nf>NewServerCodec</span><span class=p>(</span><span class=nx>conn</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>既然 RPC 程序可以跨语言调用，那么我们就可以使用 Python 来完成上述客户端调用的例子。</p><p>只需要通过 Python 传递一个固定的 json 格式数据给 Go 的服务端，就可以完成。打印传递的 json 格式参数，可以清楚传递的格式为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span><span class=nt>&#34;method&#34;</span><span class=p>:</span> <span class=s2>&#34;HelloService.Hello&#34;</span><span class=p>,</span> <span class=nt>&#34;params&#34;</span><span class=p>:</span> <span class=p>[</span><span class=s2>&#34;bobby&#34;</span><span class=p>],</span> <span class=nt>&#34;id&#34;</span><span class=p>:</span> <span class=mi>0</span><span class=p>}</span>
</span></span></code></pre></div><p>返回格式为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span><span class=err>&#39;id&#39;:</span> <span class=err>0,</span> <span class=err>&#39;result&#39;:</span> <span class=err>&#39;hello,</span> <span class=err>bobby&#39;,</span> <span class=err>&#39;error&#39;:</span> <span class=err>None</span><span class=p>}</span>
</span></span></code></pre></div><p>由于 Python 中的 request 库是 http 协议的，而我们的 go 服务端是使用 tcp 协议的，因此不匹配，我们则需要使用 socket 库进行网络编程。</p><p>Python 代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>json</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>socket</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>data</span> <span class=o>=</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;id&#34;</span><span class=p>:</span><span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;params&#34;</span><span class=p>:[</span><span class=s2>&#34;bobby&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;method&#34;</span><span class=p>:</span><span class=s2>&#34;HelloService.Hello&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>client</span> <span class=o>=</span> <span class=n>socket</span><span class=o>.</span><span class=n>create_connection</span><span class=p>((</span><span class=s2>&#34;localhost&#34;</span><span class=p>,</span> <span class=mi>1234</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>client</span><span class=o>.</span><span class=n>sendall</span><span class=p>(</span><span class=n>json</span><span class=o>.</span><span class=n>dumps</span><span class=p>(</span><span class=n>data</span><span class=p>)</span><span class=o>.</span><span class=n>encode</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>resp</span> <span class=o>=</span> <span class=n>client</span><span class=o>.</span><span class=n>recv</span><span class=p>(</span><span class=mi>1024</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>resp</span> <span class=o>=</span> <span class=n>json</span><span class=o>.</span><span class=n>loads</span><span class=p>(</span><span class=n>resp</span><span class=o>.</span><span class=n>decode</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>resp</span><span class=p>[</span><span class=s1>&#39;result&#39;</span><span class=p>])</span>
</span></span></code></pre></div><p>因此，只要是<strong class=chinese>数据编码协议</strong>与<strong class=chinese>网络传输协议</strong>一致，任何编程语言都可以进行 RPC 互相调用。</p><h3 id=网络传输协议改为-http>网络传输协议改为 http</h3><p>只需要将服务端和客户端使用的的 <code>net</code> 改为 <code>net/http</code> ，再将相应的代码进行一定的更改，就可以把 tcp 协议更改为 http 协议。正如在<a href=#%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%20RPC>实现简单的 RPC</a> 中做的一样。当然 gin 框架也是可以的。</p><p>Go 语言的服务端代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>HelloService</span> <span class=kd>struct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>HelloService</span><span class=p>)</span> <span class=nf>Hello</span><span class=p>(</span><span class=nx>request</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>reply</span> <span class=o>*</span><span class=kt>string</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=nx>reply</span> <span class=p>=</span> <span class=s>&#34;hello, &#34;</span> <span class=o>+</span> <span class=nx>request</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>_</span> <span class=p>=</span> <span class=nx>rpc</span><span class=p>.</span><span class=nf>RegisterName</span><span class=p>(</span><span class=s>&#34;HelloService&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>HelloService</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>    <span class=nx>http</span><span class=p>.</span><span class=nf>HandleFunc</span><span class=p>(</span><span class=s>&#34;/hello&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>var</span> <span class=nx>conn</span> <span class=nx>io</span><span class=p>.</span><span class=nx>ReadWriteCloser</span> <span class=p>=</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>io</span><span class=p>.</span><span class=nx>Writer</span>
</span></span><span class=line><span class=cl>            <span class=nx>io</span><span class=p>.</span><span class=nx>ReadCloser</span>
</span></span><span class=line><span class=cl>        <span class=p>}{</span>
</span></span><span class=line><span class=cl>            <span class=nx>ReadCloser</span><span class=p>:</span> <span class=nx>r</span><span class=p>.</span><span class=nx>Body</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nx>Writer</span><span class=p>:</span>     <span class=nx>w</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>rpc</span><span class=p>.</span><span class=nf>ServeRequest</span><span class=p>(</span><span class=nx>jsonrpc</span><span class=p>.</span><span class=nf>NewServerCodec</span><span class=p>(</span><span class=nx>conn</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=c1>// rpc.ServeCodec(jsonrpc.NewServerCodec(conn))
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>http</span><span class=p>.</span><span class=nf>ListenAndServe</span><span class=p>(</span><span class=s>&#34;:1234&#34;</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>注意：<code>rpc.ServeCodec</code> 变为了 <code>rpc.ServeRequest</code>。</p><p>Go 语言的客户端代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>data</span> <span class=o>:=</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>Id</span>     <span class=kt>int</span>      <span class=s>`json:&#34;id&#34;`</span> <span class=c1>// 注意：字段需要大写开头才能被序列化
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>Params</span> <span class=p>[]</span><span class=kt>string</span> <span class=s>`json:&#34;params&#34;`</span>
</span></span><span class=line><span class=cl>        <span class=nx>Method</span> <span class=kt>string</span>   <span class=s>`json:&#34;method&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=p>}{</span>
</span></span><span class=line><span class=cl>        <span class=nx>Id</span><span class=p>:</span>     <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>Params</span><span class=p>:</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;bobby&#34;</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=nx>Method</span><span class=p>:</span> <span class=s>&#34;HelloService.Hello&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>jsonData</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Marshal</span><span class=p>(</span><span class=nx>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>resp</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>http</span><span class=p>.</span><span class=nf>Post</span><span class=p>(</span><span class=s>&#34;http://localhost:1234/hello&#34;</span><span class=p>,</span> <span class=s>&#34;application/json&#34;</span><span class=p>,</span> <span class=nx>bytes</span><span class=p>.</span><span class=nf>NewBuffer</span><span class=p>(</span><span class=nx>jsonData</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>panic</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>resp</span><span class=p>.</span><span class=nx>Body</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>body</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>io</span><span class=p>.</span><span class=nf>ReadAll</span><span class=p>(</span><span class=nx>resp</span><span class=p>.</span><span class=nx>Body</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>panic</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nb>println</span><span class=p>(</span><span class=nb>string</span><span class=p>(</span><span class=nx>body</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Python 语言的客户端代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>requests</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>data</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;id&#34;</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;params&#34;</span><span class=p>:</span> <span class=p>[</span><span class=s1>&#39;bobby&#39;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;method&#34;</span><span class=p>:</span> <span class=s2>&#34;HelloService.Hello&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>resp</span> <span class=o>=</span> <span class=n>requests</span><span class=o>.</span><span class=n>post</span><span class=p>(</span><span class=s2>&#34;http://localhost:1234/hello&#34;</span><span class=p>,</span> <span class=n>json</span><span class=o>=</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>resp</span><span class=o>.</span><span class=n>text</span><span class=p>)</span>
</span></span></code></pre></div><p>后续还可以有改进的空间，即将代码进一步封装，调用时将不用传递 <code>CallID</code> 等参数，使其调用过程更接近本地的函数调用。</p><h3 id=封装为本地调用的效果>封装为本地调用的效果</h3><p>在以上的代码中，我们都是使用 <code>client.Call</code> 这个方法配合函数名称作为参数，才能正确调用远程的函数。但是在 Python 中却可以直接使用例如 <code>client.Hello</code> 这样的方法直接调用远程对应的函数（这里的 <code>Hello</code> 就是远程函数的名称或者叫做函数调用 ID），而不需要将函数 ID 作为参数传递，这是怎么实现的呢？</p><p>熟悉 Python 的高级特性就可以知道，Python 可以通过 <code>_getattr_</code> 这个魔法方法去 hook 住这个逻辑，而这在 Go 中是会报错的。</p><p>Go 语言本身没有像 Python 这样的魔法方法和特性，因此需要自己编写这样的方式。怎么写才比较合理？</p><p>以 <a href=#net/rpc%20%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B>net/rpc 快速上手</a> 一开始的第一个程序代码为例。</p><p>我们可以先把 <code>HelloService.Hello</code> 中的 <code>HelloService</code> 的固定名称提出为一个全局常量。因为服务端和客户端的代码在实际运行时是在两个不同的服务器中，因此如果需要两个程序都能访问到这个全局常量，就需要新创建一个 <code>handler/handler.go</code> 文件，在其中编写这个全局常量，并且运行时在客户端和服务端都带上这个文件。</p><p>后续将原先的 <code>HelloService.Hello</code> 改为 <code>handle.HelloService+".Hello"</code> 这样的形式。</p><p>这样改进的目的就是，我们只想编写业务逻辑的代码，而不想过多关注每个远程函数的名称。</p><p>进一步，我们也可以把网络请求传输和 RPC 的部分，也封装成一个新的文件中，这样就可以把不同的逻辑代码拆开，而服务端和客户端的代码只需要关注业务逻辑代码。</p><p>比如，可以创建一个 <code>client_proxy/client_proxy.go</code> 文件，在其中编写以下代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>HelloServiceStub</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=nx>rpc</span><span class=p>.</span><span class=nx>Client</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>NewHelloServiceClient</span><span class=p>(</span><span class=nx>protcol</span><span class=p>,</span> <span class=nx>address</span> <span class=kt>string</span><span class=p>)</span> <span class=nx>HelloServiceStub</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>conn</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>rpc</span><span class=p>.</span><span class=nf>Dial</span><span class=p>(</span><span class=nx>protcol</span><span class=p>,</span> <span class=nx>address</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>panic</span><span class=p>(</span><span class=s>&#34;connect error!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>HelloServiceStub</span><span class=p>{</span><span class=nx>conn</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>HelloServiceStub</span><span class=p>)</span> <span class=nf>Hello</span><span class=p>(</span><span class=nx>request</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>reply</span> <span class=o>*</span><span class=kt>string</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Call</span><span class=p>(</span><span class=nx>hanlder</span><span class=p>.</span><span class=nx>HelloServiceName</span><span class=o>+</span><span class=s>&#34;.Hello&#34;</span><span class=p>,</span> <span class=nx>request</span><span class=p>,</span> <span class=nx>reply</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><blockquote><p>值得注意的是，在 Go 语言中没有类、对象就意味着没有初始化方法。因此对一个结构体类进行初始化，常常使用一个函数 （开头为 <code>New</code>），比如上方的 <code>NewHelloServiceClient</code>，如果需要初始化一个对象，就可以通过这个函数返回一个该类型的对象。<strong>这在 Go 语言中十分十分常见</strong>！</p></blockquote><p>接着，<code>client/client.go</code> 的代码就可以写为以下的形式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>client</span> <span class=o>:=</span> <span class=nx>client_proxy</span><span class=p>.</span><span class=nf>NewHelloServiceClient</span><span class=p>(</span><span class=s>&#34;tcp&#34;</span><span class=p>,</span> <span class=s>&#34;localhost:1234&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>reply</span> <span class=kt>string</span> 
</span></span><span class=line><span class=cl>    <span class=nx>err</span> <span class=o>:=</span> <span class=nx>client</span><span class=p>.</span><span class=nf>Hello</span><span class=p>(</span><span class=s>&#34;bobby&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>reply</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>panic</span><span class=p>(</span><span class=s>&#34;调用失败&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>reply</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这样就可以像本地函数调用一样的方式，去调用远程的函数。</p><p>对于服务端代码，我们同样可以把函数具体的处理逻辑放入 <code>handler/handler.go</code> 中，再把服务端网络连接与 RPC 注册返回的处理逻辑放入 <code>server_proxy/server_proxy.go</code> 中。</p><p>于是，<code>handler/handler.go</code> 的代码内容如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 防止名称冲突的问题
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>const</span> <span class=nx>HelloServiceName</span> <span class=p>=</span> <span class=s>&#34;handler/HelloService&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>NewHelloService</span> <span class=kd>struct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 我们更加关注这个方法名而不是它的结构体名
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>NewHelloService</span><span class=p>)</span> <span class=nf>Hello</span><span class=p>(</span><span class=nx>request</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>reply</span> <span class=o>*</span><span class=kt>string</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//返回值是通过修改reply的值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>*</span><span class=nx>reply</span> <span class=p>=</span> <span class=s>&#34;hello, &#34;</span> <span class=o>+</span> <span class=nx>request</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>server_proxy/server_proxy.go</code> 的代码内容如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>HelloServicer</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>Hello</span><span class=p>(</span><span class=nx>request</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>reply</span> <span class=o>*</span><span class=kt>string</span><span class=p>)</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>RegisterHelloService</span><span class=p>(</span><span class=nx>srv</span> <span class=nx>HelloServicer</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>rpc</span><span class=p>.</span><span class=nf>RegisterName</span><span class=p>(</span><span class=nx>hanlder</span><span class=p>.</span><span class=nx>HelloServiceName</span><span class=p>,</span> <span class=nx>srv</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这样的写法是为了将 <code>server_proxy.go</code> 与 <code>handler.go</code> 进行解耦，使其耦合性降低。</p><p>我们关心的是函数方法名而不是结构体名，这就需要<strong class=chinese>妙用接口</strong>。在 Go 语言中，只要实现了这个接口中的所有方法，就默认自动实现了这个接口。</p><p>在上方的代码中，<code>NewHelloService</code> 拥有这个 <code>Hello</code> 方法，则它就实现了 <code>HelloServicer</code> 这个接口，所以在使用这个 <code>RegisterHelloService</code> 函数时，只需要传递 <code>NewHelloService</code> 这个结构体，到了 <code>server_proxy.go</code> 代码中就可以使用接口代替。</p><p>这样就实现了两个程序的解耦，当 <code>handler.go</code> 中的 <code>NewHelloService</code> 结构体更改了名称，只要还有 <code>hello</code> 这个方法，在 <code>server_proxy.go</code> 中就不需要做任何的代码修改。</p><p><code>server/server.go</code> 的代码内容如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//1. 实例化一个server
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>listener</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>net</span><span class=p>.</span><span class=nf>Listen</span><span class=p>(</span><span class=s>&#34;tcp&#34;</span><span class=p>,</span> <span class=s>&#34;:1234&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>//2. 注册处理逻辑 handler
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>_</span> <span class=p>=</span> <span class=nx>server_proxy</span><span class=p>.</span><span class=nf>RegisterHelloService</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>hanlder</span><span class=p>.</span><span class=nx>NewHelloService</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>    <span class=c1>//3. 启动服务
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>conn</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>listener</span><span class=p>.</span><span class=nf>Accept</span><span class=p>()</span> <span class=c1>//当一个新的连接进来的时候，
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>go</span> <span class=nx>rpc</span><span class=p>.</span><span class=nf>ServeConn</span><span class=p>(</span><span class=nx>conn</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>以上这些概念在 grpc 中都有对应，实际上我们简单模拟了 gRPC 的调用流程。在后续学习就会简单一些。</p><p>这时我们会有个问题：server_proxy 和 client_proxy 能否自动生成？并且为多种语言生成？</p><p><strong class=chinese>答</strong>：这些都能满足！这就是 <code>protobuf + gRPC</code> 的一整套解决方案。这也是后续学习的内容。</p><h2 id=什么是-grpc>什么是 gRPC</h2><p>gRPC 是 Google 开源的一个高性能、开源和通用的 RPC 框架，面向移动和 HTTP/2 设计。目前提供 C、Java 和 Go 语言版本，分别是：<a href=https://github.com/grpc/grpc>grpc</a>, <a href=https://github.com/grpc/grpc-java>grpc-java</a>, <a href=https://github.com/grpc/grpc-go>grpc-go</a>. 其中 C 版本支持 <a href=https://github.com/grpc/grpc>C</a>, <a href=https://github.com/grpc/grpc/tree/master/src/cpp>C++</a>, <a href=https://github.com/grpc/grpc/tree/master/src/node>Node.js</a>, <a href=https://github.com/grpc/grpc/tree/master/src/python>Python</a>, <a href=https://github.com/grpc/grpc/tree/master/src/ruby>Ruby</a>, <a href=https://github.com/grpc/grpc/tree/master/src/objective-c>Objective-C</a>, <a href=https://github.com/grpc/grpc/tree/master/src/php>PHP</a> 和 <a href=https://github.com/grpc/grpc/tree/master/src/csharp>C#</a> 支持。</p><p>我们不需要担心使用 http 2.0 会出现性能问题，因为 http 2.0 相对于 http 1.0 已经针对性能进行了很深的改进。</p><p>同时在 gRPC 框架中也使用了一个高性能的序列化协议 protobuf，比 json 的性能高很多。</p><p><img src=https://cdn.pi3.fun/blog/202502252026836.svg alt=landing-2.svg></p><h2 id=什么是-protobuf>什么是 protobuf</h2><p><code>protobuf</code> 全称是 <code>Protocol Buffer</code> ，它是 Google 设计的一种轻量高效的结构化数据存储格式，性能比 <code>Json、XML</code> 强很多。它同样也是一个通用性的协议，并不是只有 Go 语言才能用。</p><p>习惯用 <code>Json、XML</code> 数据存储格式的大家，相信大多都没听过 <code>Protocol Buffer</code>。</p><p><code>protobuf</code> 经历了 <code>protobuf2</code> 和 <code>protobuf3</code>，pb 3 比 pb 2 简化了很多，目前主流的版本是 pb 3。</p><p>对应 <code>protobuf</code> 的还有很多协议，比如 java 中的 <code>dubbo</code>、<code>rmi</code>、<code>hessian</code>，还有 python 中的 <code>messagepack</code> ，这些协议都比 <code>Json</code> 和 <code>XML</code> 更高效。如果你懂了这些协议，完全有能力自己去实现一个类似的高性能协议。</p><p><img src=https://cdn.pi3.fun/blog/202502252026109.png alt=image.png></p><p>根据以上的优缺点，我们可以想到：一般对于内部接口、微服务、RPC 等场景，我们推荐使用像 <code>protobuf</code> 这样的高性能协议。而对于外部接口、网络传输、开放接口等场景，就更推荐使用像是 <code>Json</code> 、<code>XML</code> 这样通用性高的协议。</p><h2 id=grpc-快速上手>gRPC 快速上手</h2><h3 id=开发环境搭建>开发环境搭建</h3><p><a href=https://grpc.io/docs/languages/go/quickstart/>Quick start | Go | gRPC</a></p><p>先在 Github 中 <a href=https://github.com/protocolbuffers/protobuf/releases>protobuf Releases</a> 下载对应工具。并将 <code>/bin/protoc.exe</code> 添加进环境变量中。</p><p>注意：protoc 的版本需要和 golang/protobuf 保持一致。</p><p>下载 Go 依赖库：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>go</span> <span class=nx>install</span> <span class=nx>google</span><span class=p>.</span><span class=nx>golang</span><span class=p>.</span><span class=nx>org</span><span class=o>/</span><span class=nx>protobuf</span><span class=o>/</span><span class=nx>cmd</span><span class=o>/</span><span class=nx>protoc</span><span class=o>-</span><span class=nx>gen</span><span class=o>-</span><span class=k>go</span><span class=err>@</span><span class=nx>latest</span>
</span></span><span class=line><span class=cl><span class=k>go</span> <span class=nx>install</span> <span class=nx>google</span><span class=p>.</span><span class=nx>golang</span><span class=p>.</span><span class=nx>org</span><span class=o>/</span><span class=nx>grpc</span><span class=o>/</span><span class=nx>cmd</span><span class=o>/</span><span class=nx>protoc</span><span class=o>-</span><span class=nx>gen</span><span class=o>-</span><span class=k>go</span><span class=o>-</span><span class=nx>grpc</span><span class=err>@</span><span class=nx>latest</span>
</span></span></code></pre></div><p>注意：安装过程中会提示说 <code>go get</code> 会慢慢被弃用，不是错误只是提示，Go 的新版本依赖安装会慢慢弃用 <code>go get</code> 方式安装，以后一律采用 <code>go install</code> 方式安装第三方依赖。</p><p>导入 gRPC 自动下载所需要的文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;google.golang.org/grpc&#34;</span>
</span></span></code></pre></div><p>为什么会需要 protoc 这个工具以及 protoc-gen-go 这个插件包呢？</p><p>这是因为 protobuf 与 Json、XML 都是通用性的协议，它不关注使用什么编程语言，任何编程语言只要遵守这个协议，都能实现这个协议。如果每个语言每次用到 protobuf 协议都需要写一次协议的实现，就会十分麻烦，因此官方给出了 protoc 这个工具，配合各个语言官方的第三方包，就可以帮助我们生成对应语言实现该协议的源代码。</p><p>同时为什么需要做成插件的形式？这是因为方便让我们自己生成所需要的源码，并可以根据自身的需求修改这个源码。如果像是 Go 语言第三方库这样的形式引入代码中，我们便不能对生成的代码进行自定义的修改。</p><h3 id=proto-文件编写>proto 文件编写</h3><p>你可以将 protobuf 简单地理解为一个新的语言和结构，它以 <code>.proto</code> 结尾。</p><p>如果在代码编辑器中没有该语言的提示和高亮，则可以在插件商店中安装一个 proto 插件，如 vscode 中的 <code>vscode-proto3</code>。</p><p>接着就可以编写一个 <code>helloworld.proto</code> 文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=n>syntax</span> <span class=o>=</span> <span class=s>&#34;proto3&#34;</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>option</span> <span class=n>go_package</span> <span class=o>=</span> <span class=s>&#34;.;proto&#34;</span><span class=p>;</span> <span class=c1>// 必须要指定包名
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>service</span> <span class=n>Greeter</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=k>rpc</span> <span class=n>SayHello</span> <span class=p>(</span><span class=n>HelloRequest</span><span class=p>)</span> <span class=k>returns</span> <span class=p>(</span><span class=n>HelloReply</span><span class=p>);</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=kd>message</span> <span class=nc>HelloRequest</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=kt>string</span> <span class=n>name</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>  <span class=c1>//1表示字段的序号不是值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=kd>message</span> <span class=nc>HelloReply</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=kt>string</span> <span class=kd>message</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=p>}</span><span class=err>
</span></span></span></code></pre></div><p>第二行，新版本的 protoc 和 protobuf 应该写成 <code>option go_package = "./;proto";</code></p><p>可以使用以下命令行指令，生成 Go 语言文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>protoc --go_out<span class=o>=</span>. --go-grpc_out<span class=o>=</span><span class=nv>require_unimplemented_servers</span><span class=o>=</span>false:. helloworld.proto
</span></span></code></pre></div><p>这样在当前目录下就会生成一个 <code>helloworld.pb.go</code> 和 <code>helloworld_grpc.pb.go</code> 的 Go 语言文件。</p><p>使用时只需要在代码中引入 <code>proto</code> 这个包，就可以使用 <code>HelloRequest</code> 和 <code>HelloReply</code> 这两个结构体，这两个结构体会将其中的信息自动转换为 <code>protobuf</code> 协议的数据。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;main/proto&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>req</span> <span class=o>:=</span> <span class=nx>proto</span><span class=p>.</span><span class=nx>HelloRequest</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>Name</span><span class=p>:</span> <span class=s>&#34;Bobby&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>req</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>接下来，我们可以将数据变得更加复杂一些。</p><p><code>helloworld.proto</code> 中的 <code>HelloRequest</code> 增加一些字段：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=kd>message</span> <span class=nc>HelloRequest</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=kt>string</span> <span class=n>name</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>  <span class=c1>//1表示字段的序号不是值
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int32</span> <span class=n>age</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=k>repeated</span> <span class=kt>string</span> <span class=n>courses</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>  <span class=c1>//repeated表示是一个数组
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=err>
</span></span></span></code></pre></div><p>编写以下 protobuf 和 Json 协议对比的代码，两者都使用相同的结构体数据。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;encoding/json&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nx>pb</span> <span class=s>&#34;main/proto&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=s>&#34;google.golang.org/protobuf/proto&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>protobufStruct</span> <span class=o>:=</span> <span class=nx>pb</span><span class=p>.</span><span class=nx>HelloRequest</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>Name</span><span class=p>:</span>    <span class=s>&#34;Bobby&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>Age</span><span class=p>:</span>     <span class=mi>20</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>Courses</span><span class=p>:</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;Math&#34;</span><span class=p>,</span> <span class=s>&#34;Science&#34;</span><span class=p>,</span> <span class=s>&#34;English&#34;</span><span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>jsonStruct</span> <span class=o>:=</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>Name</span>    <span class=kt>string</span>   <span class=s>`json:&#34;name&#34;`</span>
</span></span><span class=line><span class=cl>        <span class=nx>Age</span>     <span class=kt>int32</span>    <span class=s>`json:&#34;age&#34;`</span>
</span></span><span class=line><span class=cl>        <span class=nx>Courses</span> <span class=p>[]</span><span class=kt>string</span> <span class=s>`json:&#34;courses&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=p>}{</span>
</span></span><span class=line><span class=cl>        <span class=nx>Name</span><span class=p>:</span>    <span class=nx>protobufStruct</span><span class=p>.</span><span class=nx>Name</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>Age</span><span class=p>:</span>     <span class=nx>protobufStruct</span><span class=p>.</span><span class=nx>Age</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>Courses</span><span class=p>:</span> <span class=nx>protobufStruct</span><span class=p>.</span><span class=nx>Courses</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>protobufByte</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>proto</span><span class=p>.</span><span class=nf>Marshal</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>protobufStruct</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>jsonByte</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Marshal</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>jsonStruct</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;protobuf协议的数据长度: %d\n&#34;</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>protobufByte</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;json协议的数据长度: %d\n&#34;</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>jsonByte</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>最终输出为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>protobuf协议的数据长度: <span class=m>33</span>
</span></span><span class=line><span class=cl>json协议的数据长度: <span class=m>64</span>
</span></span></code></pre></div><p>我们可以很直观地发现，protobuf 协议的压缩比远远高于 Json 协议，大致为两倍的差距，这也是为什么我们在微服务等内部场景中，更推荐使用 protobuf 协议。</p><p>那么 protobuf 协议具体是如何做到高性能和高压缩比的，可以作为后续学习的路径。</p><p>同时从上方的代码写法中可以发现，<code>google.golang.org/protobuf/proto</code> 这个工具的用法与 <code>encoding/json</code> 的用法相似，都可以通过 <code>Marshal</code> 和 <code>Unmarshal</code> 将数据编码与反编码。</p><h3 id=生成-api-接口>生成 API 接口</h3><p>在上方的实例中，我们实际上只是使用了 <code>helloworld.proto</code> 文件中的</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=kd>message</span> <span class=nc>HelloRequest</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=kt>string</span> <span class=n>name</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>  <span class=c1>//1表示字段的序号不是值
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int32</span> <span class=n>age</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=k>repeated</span> <span class=kt>string</span> <span class=n>courses</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>  <span class=c1>//repeated表示是一个数组
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=err>
</span></span></span></code></pre></div><p>结构体，那么其他代码是干什么用的呢？</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=kd>service</span> <span class=n>Greeter</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err> </span> <span class=k>rpc</span> <span class=n>SayHello</span> <span class=p>(</span><span class=n>HelloRequest</span><span class=p>)</span> <span class=k>returns</span> <span class=p>(</span><span class=n>HelloReply</span><span class=p>);</span> <span class=c1>// SayHello接口
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=err>
</span></span></span></code></pre></div><p>比如上方这段代码，可以为服务端和客户端生成一个接口，在 <code>helloworld_grpc.pb.go</code> 文件中。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>GreeterClient</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>SayHello</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>in</span> <span class=o>*</span><span class=nx>HelloRequest</span><span class=p>,</span> <span class=nx>opts</span> <span class=o>...</span><span class=nx>grpc</span><span class=p>.</span><span class=nx>CallOption</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>HelloReply</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>GreeterServer</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>SayHello</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=o>*</span><span class=nx>HelloRequest</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>HelloReply</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>根据上面的学习，我们清楚 protobuf 只是一个序列化协议，那么为什么我们通过编写 <code>helloworld.proto</code> 这样一个 proto 文件就可以为我们同时生成客户端和服务端的 API 接口？</p><p>实际上，这是通过 gRPC 生成的，而不是原本 protobuf 的功能。我们在<a href=#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA>开发环境搭建</a>中安装的 <code>google.golang.org/grpc/cmd/protoc-gen-go-grpc</code> 包帮助我们生成了 API 接口，而 protobuf 只是专注于将数据编码按照协议规范进行转化，它只是提供了我们在 proto 文件中编写的那个结构体。</p><p>当我们去除了 <code>google.golang.org/grpc/cmd/protoc-gen-go-grpc</code> 这个包，执行上述生成指令，它依旧可以生成 Go 语言代码，但是只有一个 <code>helloworld.pb.go</code> 文件。</p><p>总的来说：</p><ul><li><code>google.golang.org/protobuf/cmd/protoc-gen-go</code> 帮助生成了 <code>helloworld.pb.go</code> 文件，其中包含 <code>HelloRequest</code> 和 <code>HelloReply</code> 结构体信息。</li><li><code>google.golang.org/grpc/cmd/protoc-gen-go-grpc</code> 帮助生成了 <code>helloworld_grpc.pb.go</code> 文件，其中包含 <code>SayHello</code> 的接口信息。</li></ul><p><code>protoc-gen-go-grpc</code> 是 <code>protoc-gen-go</code> 的一个插件。</p><p>因此，我们在执行以下生成命令时，需要指定使用什么插件，如 <code>grpc</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>protoc --go_out<span class=o>=</span>. --go-grpc_out<span class=o>=</span><span class=nv>require_unimplemented_servers</span><span class=o>=</span>false:. helloworld.proto
</span></span></code></pre></div><ul><li><code>--go_out=.</code>：指定生成 Go 语言文件，并放置在当前目录 <code>.</code></li><li><code>--go-grpc_out=require_unimplemented_servers=false:.</code>：指定生成 gRPC 服务代码，并且即使某些服务方法没有实现，代码也可以正常编译。生成的 gRPC 代码将被放置在当前目录 <code>.</code></li><li><code>helloworld.proto</code>：指定输入的 <code>.proto</code> 文件</li></ul><p>在完全掌握微服务后，我们可以尝试阅读 <code>protoc-gen-go</code> 的源码，并编写一个对应的插件程序，用于满足我们项目的生成代码需求。</p><h3 id=grpc-快速体验>gRPC 快速体验</h3><p>在搞懂 proto 生成原理后，我们就可以开始学习 gRPC 的使用。</p><p>同样我们在项目根目录先建立一个 <code>proto</code> 文件夹，在其中编写 <code>helloworld.proto</code> 文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=n>syntax</span> <span class=o>=</span> <span class=s>&#34;proto3&#34;</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>option</span> <span class=n>go_package</span> <span class=o>=</span> <span class=s>&#34;.;proto&#34;</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=kd>service</span> <span class=n>Greeter</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>    <span class=k>rpc</span> <span class=n>SayHello</span> <span class=p>(</span><span class=n>HelloRequest</span><span class=p>)</span> <span class=k>returns</span> <span class=p>(</span><span class=n>HelloReply</span><span class=p>);</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=kd>message</span> <span class=nc>HelloRequest</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>    <span class=kt>string</span> <span class=n>name</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=kd>message</span> <span class=nc>HelloReply</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>    <span class=kt>string</span> <span class=kd>message</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=p>}</span><span class=err>
</span></span></span></code></pre></div><p>执行生成指令，生成 <code>helloworld.pb.go</code> 和 <code>helloworld_grpc.pb.go</code> 文件。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>protoc --go_out<span class=o>=</span>. --go-grpc_out<span class=o>=</span><span class=nv>require_unimplemented_servers</span><span class=o>=</span>false:. helloworld.proto
</span></span></code></pre></div><p>接着就可以在项目根目录中分布创建 <code>server/server.go</code> 和 <code>client/client.go</code>，开始编写服务端和客户端代码。</p><p>服务端代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Server</span> <span class=kd>struct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 实现helloworld_grpc.pb.go中的GreeterServer接口
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>Server</span><span class=p>)</span> <span class=nf>SayHello</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>request</span> <span class=o>*</span><span class=nx>proto</span><span class=p>.</span><span class=nx>HelloRequest</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>proto</span><span class=p>.</span><span class=nx>HelloReply</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>&amp;</span><span class=nx>proto</span><span class=p>.</span><span class=nx>HelloReply</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>Message</span><span class=p>:</span> <span class=s>&#34;hello &#34;</span> <span class=o>+</span> <span class=nx>request</span><span class=p>.</span><span class=nx>Name</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 1. 实例化一个服务
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>g</span> <span class=o>:=</span> <span class=nx>grpc</span><span class=p>.</span><span class=nf>NewServer</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 2. 注册处理逻辑
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>proto</span><span class=p>.</span><span class=nf>RegisterGreeterServer</span><span class=p>(</span><span class=nx>g</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>Server</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 3. 启动服务
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>lis</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>net</span><span class=p>.</span><span class=nf>Listen</span><span class=p>(</span><span class=s>&#34;tcp&#34;</span><span class=p>,</span> <span class=s>&#34;0.0.0.0:8088&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>panic</span><span class=p>(</span><span class=s>&#34;failed to listen:&#34;</span> <span class=o>+</span> <span class=nx>err</span><span class=p>.</span><span class=nf>Error</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>err</span> <span class=p>=</span> <span class=nx>g</span><span class=p>.</span><span class=nf>Serve</span><span class=p>(</span><span class=nx>lis</span><span class=p>)</span> <span class=c1>// 不会直接退出
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>panic</span><span class=p>(</span><span class=s>&#34;failed to start grpc:&#34;</span> <span class=o>+</span> <span class=nx>err</span><span class=p>.</span><span class=nf>Error</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>服务端的代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>conn</span><span class=p>,</span><span class=nx>err</span> <span class=o>:=</span> <span class=nx>grpc</span><span class=p>.</span><span class=nf>Dial</span><span class=p>(</span><span class=s>&#34;127.0.0.1:8080&#34;</span><span class=p>,</span><span class=nx>grpc</span><span class=p>.</span><span class=nf>WithInsecure</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span><span class=o>!=</span><span class=kc>nil</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>panic</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>conn</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nx>c</span> <span class=o>:=</span> <span class=nx>hello</span><span class=p>.</span><span class=nf>NewGreeterClient</span><span class=p>(</span><span class=nx>conn</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>r</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>SayHello</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>(),</span><span class=o>&amp;</span><span class=nx>hello</span><span class=p>.</span><span class=nx>HelloRequest</span><span class=p>{</span><span class=nx>Name</span><span class=p>:</span><span class=s>&#34;bobby&#34;</span><span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span><span class=o>!=</span><span class=kc>nil</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>panic</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>Message</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>通过以上代码，我们可以发现，其主逻辑与 Go 语言内置的 RPC 框架是几乎一样的，但是 gRPC 帮我们封装好了客户端和服务端的 API 接口，我们只需要实现并调用。</p><p>Go 语言内置 RPC 框架的服务端注册绑定写法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>rpc</span><span class=p>.</span><span class=nf>RegisterName</span><span class=p>(</span><span class=s>&#34;HelloService&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>HelloService</span><span class=p>{})</span>
</span></span></code></pre></div><p>Go 语言内置 RPC 框架的客户端调用逻辑写法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>client</span><span class=p>.</span><span class=nf>Call</span><span class=p>(</span><span class=s>&#34;HelloService.Hello&#34;</span><span class=p>,</span> <span class=s>&#34;bobby&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>reply</span><span class=p>)</span>
</span></span></code></pre></div><p>gRPC 服务端注册绑定写法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>proto</span><span class=p>.</span><span class=nf>RegisterGreeterServer</span><span class=p>(</span><span class=nx>g</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>Server</span><span class=p>{})</span>
</span></span></code></pre></div><p>gRPC 客户端调用逻辑写法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>c</span><span class=p>.</span><span class=nf>SayHello</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>(),</span><span class=o>&amp;</span><span class=nx>hello</span><span class=p>.</span><span class=nx>HelloRequest</span><span class=p>{</span><span class=nx>Name</span><span class=p>:</span><span class=s>&#34;bobby&#34;</span><span class=p>})</span>
</span></span></code></pre></div><p>对比发现，gRPC 的风格更加简洁方便，不再需要通过<strong class=chinese>设置参数</strong>的方式来指定所需要执行的函数名，这在远程调用的场景中十分重要。</p><p>同时 gRPC 结合 protobuf 协议，帮我们完成了数据编码的序列化与反序列化的过程，简化了开发流程，我们只需要专注于业务逻辑的编写。</p><h3 id=grpc-四种数据模式>gRPC 四种数据模式</h3><p>以上简单介绍了 gRPC 的简单使用，接着再介绍 gRPC 中的 stream (流模式)。srteam 顾名思义就是一种流，可以源源不断的推送数据，很适合传输一些大数据，或者服务端和客户端长时间数据交互，比如客户端可以向服务端订阅一个数据，服务端就可以利用 stream ，源源不断地推送数据。</p><p>gRPC 共有四种数据模式：</p><ol><li>简单模式（Simple RPC）</li><li>服务端数据流模式（Server-side streaming RPC）</li><li>客户端数据流模式（Client-side streaming RPC）</li><li>双向数据流模式（Bidrectional streaming RPC）</li></ol><p><strong class=chinese>简单模式</strong>：这种模式最为传统，即客户端发起一次请求，服务端响应一个数据，这和大家平时熟悉的 RPC 没有什么大的区别，所以不再详细介绍。</p><p><strong class=chinese>服务端数据流模式</strong>：这种模式是客户端发起一次请求，服务端返回一段连续的数据流。典型的例子是客户端向服务端发送一个股票代码，服务端就把该股票的实时数据源源不断地返回给客户端。</p><p><strong class=chinese>客户端数据流模式</strong>：与服务端数据流模式相反，客户端源源不断的向服务端发送数据流，而在发送结束后，由服务端返回一个响应。典型的例子是物联网终端向服务器报送数据。</p><p><strong class=chinese>双向数据流模式</strong>：顾名思义，客户端和服务端都可以向对方发送数据流，这个时候双方的数据可以同时互相发送，也就是可以实现实时交互。典型的例子是聊天机器人。</p><p>具体的代码如何编写，如下所示。</p><p>如果要使用流模式，则需要在编写 proto 文件时，加上 <code>stream</code> 关键字。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=n>syntax</span> <span class=o>=</span> <span class=s>&#34;proto3&#34;</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>option</span> <span class=n>go_package</span><span class=o>=</span><span class=s>&#34;./;proto&#34;</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=kd>service</span> <span class=n>Greeter</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>    <span class=c1>//服务端流模式
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>rpc</span> <span class=n>GetStream</span><span class=p>(</span><span class=n>StreamReqData</span><span class=p>)</span> <span class=k>returns</span> <span class=p>(</span><span class=n>stream</span> <span class=n>StreamResData</span><span class=p>);</span> <span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>    <span class=c1>//客户端流模式
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>rpc</span> <span class=n>PutStream</span><span class=p>(</span><span class=n>stream</span> <span class=n>StreamReqData</span><span class=p>)</span> <span class=k>returns</span> <span class=p>(</span><span class=n>StreamResData</span><span class=p>);</span> <span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>    <span class=c1>//双向流模式
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>rpc</span> <span class=n>AllStream</span><span class=p>(</span><span class=n>stream</span> <span class=n>StreamReqData</span><span class=p>)</span> <span class=k>returns</span> <span class=p>(</span><span class=n>stream</span> <span class=n>StreamResData</span><span class=p>);</span> <span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=kd>message</span> <span class=nc>StreamReqData</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>    <span class=kt>string</span> <span class=n>data</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=kd>message</span> <span class=nc>StreamResData</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>    <span class=kt>string</span> <span class=n>data</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=p>}</span><span class=err>
</span></span></span></code></pre></div><p>使用 protoc 指令生成 Go 语言文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>protoc --go_out<span class=o>=</span>. --go-grpc_out<span class=o>=</span><span class=nv>require_unimplemented_servers</span><span class=o>=</span>false:. stream.proto
</span></span></code></pre></div><p>接着就可以开始编写服务端和客户端的代码。</p><p>服务端代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>const</span> <span class=nx>PORT</span> <span class=p>=</span> <span class=s>&#34;:12345&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Server</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 服务端流模式
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>Server</span><span class=p>)</span> <span class=nf>GetStream</span><span class=p>(</span><span class=nx>req</span> <span class=o>*</span><span class=nx>proto</span><span class=p>.</span><span class=nx>StreamReqData</span><span class=p>,</span> <span class=nx>res</span> <span class=nx>proto</span><span class=p>.</span><span class=nx>Greeter_GetStreamServer</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span> <span class=c1>// 发送10次数据
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 发送当前时间数据
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>res</span><span class=p>.</span><span class=nf>Send</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>proto</span><span class=p>.</span><span class=nx>StreamResData</span><span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>Data</span><span class=p>:</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;server: %s&#34;</span><span class=p>,</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Format</span><span class=p>(</span><span class=s>&#34;2006-01-02 15:04:05&#34;</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>        <span class=p>})</span>
</span></span><span class=line><span class=cl>        <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span> <span class=c1>// 每隔一秒发送一次
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 客户端流模式
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>Server</span><span class=p>)</span> <span class=nf>PutStream</span><span class=p>(</span><span class=nx>res</span> <span class=nx>proto</span><span class=p>.</span><span class=nx>Greeter_PutStreamServer</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>data</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>res</span><span class=p>.</span><span class=nf>Recv</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>data</span><span class=p>.</span><span class=nx>Data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 双向流模式
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>Server</span><span class=p>)</span> <span class=nf>AllStream</span><span class=p>(</span><span class=nx>res</span> <span class=nx>proto</span><span class=p>.</span><span class=nx>Greeter_AllStreamServer</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span> <span class=o>:=</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 接收数据的goroutine
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>data</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>res</span><span class=p>.</span><span class=nf>Recv</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>data</span><span class=p>.</span><span class=nx>Data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}()</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 发送数据的goroutine
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span> <span class=c1>// 发送10次数据
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>_</span> <span class=p>=</span> <span class=nx>res</span><span class=p>.</span><span class=nf>Send</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>proto</span><span class=p>.</span><span class=nx>StreamResData</span><span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>Data</span><span class=p>:</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;server: 双向数据流 %d&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=p>})</span>
</span></span><span class=line><span class=cl>            <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span> <span class=c1>// 每隔一秒发送一次
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}()</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span> <span class=c1>// 等待两个goroutine结束
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//监听端口
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>lis</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>net</span><span class=p>.</span><span class=nf>Listen</span><span class=p>(</span><span class=s>&#34;tcp&#34;</span><span class=p>,</span> <span class=nx>PORT</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>panic</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>//创建一个grpc 服务器
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>s</span> <span class=o>:=</span> <span class=nx>grpc</span><span class=p>.</span><span class=nf>NewServer</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1>//注册事件
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>proto</span><span class=p>.</span><span class=nf>RegisterGreeterServer</span><span class=p>(</span><span class=nx>s</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>Server</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>    <span class=c1>//处理链接
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>err</span> <span class=p>=</span> <span class=nx>s</span><span class=p>.</span><span class=nf>Serve</span><span class=p>(</span><span class=nx>lis</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>panic</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong class=chinese>需要注意的是</strong>，流模式中实现接口的这三个方法，其<em>参数</em>与简单模式中的并不相同。</p><p>简单模式中的参数形式如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>Server</span><span class=p>)</span> <span class=nf>SayHello</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>request</span> <span class=o>*</span><span class=nx>proto</span><span class=p>.</span><span class=nx>HelloRequest</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>proto</span><span class=p>.</span><span class=nx>HelloReply</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>而流模式中的参数形式如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>Server</span><span class=p>)</span> <span class=nf>GetStream</span><span class=p>(</span><span class=nx>req</span> <span class=o>*</span><span class=nx>proto</span><span class=p>.</span><span class=nx>StreamReqData</span><span class=p>,</span> <span class=nx>res</span> <span class=nx>proto</span><span class=p>.</span><span class=nx>Greeter_GetStreamServer</span><span class=p>)</span> <span class=kt>error</span>
</span></span></code></pre></div><p>客户端的代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>const</span> <span class=nx>ADDRESS</span> <span class=p>=</span> <span class=s>&#34;localhost:12345&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>conn</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>grpc</span><span class=p>.</span><span class=nf>Dial</span><span class=p>(</span><span class=nx>ADDRESS</span><span class=p>,</span> <span class=nx>grpc</span><span class=p>.</span><span class=nf>WithInsecure</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>panic</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>conn</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span> <span class=o>:=</span> <span class=nx>proto</span><span class=p>.</span><span class=nf>NewGreeterClient</span><span class=p>(</span><span class=nx>conn</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 1. 服务端流模式
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>reqStreamData</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>proto</span><span class=p>.</span><span class=nx>StreamReqData</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>Data</span><span class=p>:</span> <span class=s>&#34;client&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>res</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>GetStream</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>(),</span> <span class=nx>reqStreamData</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>data</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>res</span><span class=p>.</span><span class=nf>Recv</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>data</span><span class=p>.</span><span class=nx>Data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 2. 客户端流模式
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>putRes</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>PutStream</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span> <span class=c1>// 发送10次数据
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>_</span> <span class=p>=</span> <span class=nx>putRes</span><span class=p>.</span><span class=nf>Send</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>proto</span><span class=p>.</span><span class=nx>StreamReqData</span><span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>Data</span><span class=p>:</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;client: %s&#34;</span><span class=p>,</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Format</span><span class=p>(</span><span class=s>&#34;2006-01-02 15:04:05&#34;</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>        <span class=p>})</span>
</span></span><span class=line><span class=cl>        <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span> <span class=c1>// 每隔一秒发送一次
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 3. 双向流模式
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>allRes</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>AllStream</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span> <span class=o>:=</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 接收数据的goroutine
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>data</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>allRes</span><span class=p>.</span><span class=nf>Recv</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>data</span><span class=p>.</span><span class=nx>Data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}()</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 发送数据的goroutine
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span> <span class=c1>// 发送10次数据
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>_</span> <span class=p>=</span> <span class=nx>allRes</span><span class=p>.</span><span class=nf>Send</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>proto</span><span class=p>.</span><span class=nx>StreamReqData</span><span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>Data</span><span class=p>:</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;client: 双向数据流 %d&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=p>})</span>
</span></span><span class=line><span class=cl>            <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span> <span class=c1>// 每隔一秒发送一次
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}()</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span> <span class=c1>// 等待两个goroutine结束
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 也可以使用select{}阻塞主goroutine
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// select{}
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><ol><li>在使用<strong class=chinese>服务端数据流模式</strong>时，服务端会源源不断向客户端发送<strong class=chinese>当前时间</strong>数据。</li><li>在使用<strong class=chinese>客户端数据流模式</strong>时，客户端会源源不断向服务端发送<strong class=chinese>当前时间</strong>数据。</li><li>在使用<strong class=chinese>双向数据流模式</strong>时，服务端和客户端都能向对方源源不断地发送<strong class=chinese>字符</strong>数据。</li></ol><p>客户端输出：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>PS D:<span class=se>\D</span>esktop<span class=se>\s</span>tream_gprc<span class=se>\c</span>lient&gt; go run client.go
</span></span><span class=line><span class=cl>server: 2025-02-22 17:13:13
</span></span><span class=line><span class=cl>server: 2025-02-22 17:13:14
</span></span><span class=line><span class=cl>server: 2025-02-22 17:13:15
</span></span><span class=line><span class=cl>server: 2025-02-22 17:13:16
</span></span><span class=line><span class=cl>server: 2025-02-22 17:13:17
</span></span><span class=line><span class=cl>server: 2025-02-22 17:13:18
</span></span><span class=line><span class=cl>server: 2025-02-22 17:13:19
</span></span><span class=line><span class=cl>server: 2025-02-22 17:13:20
</span></span><span class=line><span class=cl>server: 2025-02-22 17:13:21
</span></span><span class=line><span class=cl>server: 2025-02-22 17:13:22
</span></span><span class=line><span class=cl>EOF
</span></span><span class=line><span class=cl>server: 双向数据流 <span class=m>0</span>
</span></span><span class=line><span class=cl>server: 双向数据流 <span class=m>1</span>
</span></span><span class=line><span class=cl>server: 双向数据流 <span class=m>2</span>
</span></span><span class=line><span class=cl>server: 双向数据流 <span class=m>3</span>
</span></span><span class=line><span class=cl>server: 双向数据流 <span class=m>4</span>
</span></span><span class=line><span class=cl>server: 双向数据流 <span class=m>5</span>
</span></span><span class=line><span class=cl>server: 双向数据流 <span class=m>6</span>
</span></span><span class=line><span class=cl>server: 双向数据流 <span class=m>7</span>
</span></span><span class=line><span class=cl>server: 双向数据流 <span class=m>8</span>
</span></span><span class=line><span class=cl>server: 双向数据流 <span class=m>9</span>
</span></span></code></pre></div><p>服务端输出：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>PS D:<span class=se>\D</span>esktop<span class=se>\s</span>tream_gprc<span class=se>\s</span>erver&gt; go run server.go
</span></span><span class=line><span class=cl>client: 2025-02-22 17:13:23
</span></span><span class=line><span class=cl>client: 2025-02-22 17:13:24
</span></span><span class=line><span class=cl>client: 2025-02-22 17:13:25
</span></span><span class=line><span class=cl>client: 2025-02-22 17:13:26
</span></span><span class=line><span class=cl>client: 2025-02-22 17:13:27
</span></span><span class=line><span class=cl>client: 2025-02-22 17:13:28
</span></span><span class=line><span class=cl>client: 2025-02-22 17:13:29
</span></span><span class=line><span class=cl>client: 2025-02-22 17:13:30
</span></span><span class=line><span class=cl>client: 2025-02-22 17:13:31
</span></span><span class=line><span class=cl>client: 2025-02-22 17:13:32
</span></span><span class=line><span class=cl>client: 双向数据流 <span class=m>0</span>
</span></span><span class=line><span class=cl>client: 双向数据流 <span class=m>1</span>
</span></span><span class=line><span class=cl>client: 双向数据流 <span class=m>2</span>
</span></span><span class=line><span class=cl>client: 双向数据流 <span class=m>3</span>
</span></span><span class=line><span class=cl>client: 双向数据流 <span class=m>4</span>
</span></span><span class=line><span class=cl>client: 双向数据流 <span class=m>5</span>
</span></span><span class=line><span class=cl>client: 双向数据流 <span class=m>6</span>
</span></span><span class=line><span class=cl>client: 双向数据流 <span class=m>7</span>
</span></span><span class=line><span class=cl>client: 双向数据流 <span class=m>8</span>
</span></span><span class=line><span class=cl>client: 双向数据流 <span class=m>9</span>
</span></span></code></pre></div><p>项目代码结构：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>├───client
</span></span><span class=line><span class=cl>│       client.go
</span></span><span class=line><span class=cl>│       go.mod
</span></span><span class=line><span class=cl>│       go.sum
</span></span><span class=line><span class=cl>│
</span></span><span class=line><span class=cl>├───proto
</span></span><span class=line><span class=cl>│       go.mod
</span></span><span class=line><span class=cl>│       go.sum
</span></span><span class=line><span class=cl>│       stream.pb.go
</span></span><span class=line><span class=cl>│       stream.proto
</span></span><span class=line><span class=cl>│       stream_grpc.pb.go
</span></span><span class=line><span class=cl>│
</span></span><span class=line><span class=cl>└───server
</span></span><span class=line><span class=cl>        go.mod
</span></span><span class=line><span class=cl>        go.sum
</span></span><span class=line><span class=cl>        server.go
</span></span></code></pre></div><p><strong class=chinese>值得一提的是</strong>，在使用双向数据流模式的代码中，服务端和客户端都使用了两个 goroutine 来发送和接收数据，这样就可以使程序更加灵活，不要求接收和发送的顺序，即使是网络阻塞使发送和接收数据的顺序变化，依然可以成功执行这段逻辑代码。</p><p>观察以上服务端和客户端的代码，我们可以发现，这与传统的 socket 编程十分类似，比如都使用了 <code>Send</code> 和 <code>Recv</code> 两个方法来发送和接收数据。</p><p>实际上，这段代码底层就是使用 socket 编程的模式，只是在 socket 的基础上再封装了一层，加上了 RPC 相关的功能，同时数据编码格式使用了 protobuf 协议，而在传统 socket 编程中，并没有规定需要使用什么数据格式，也就是说 gRPC 流模式就是建立在 socket 层上的一个应用层封装。</p></article><div class=paginator><a class=link href=https://blog.pi3.fun/post/2025/02/go-concurrency-programming/>← prev</a>
<a class=link href=https://blog.pi3.fun/post/2025/02/grpc-notes-advanced/>next →</a></div><div class=comment><div id=tcomment></div><script src=https://registry.npmmirror.com/twikoo/1.6.39/files/dist/twikoo.min.js></script><script async>twikoo.init({envId:"https://twikoo.pi3.fun/.netlify/functions/twikoo",el:"#tcomment",lang:"zh-CN"})</script></div></main><footer id=footer><div><span style=display:flex;align-items:center><span style=margin-right:.5rem>© 2021 - 2025</span><img src=https://cdn.pi3.fun/static/rainbow.gif loading=lazy width=20 alt=rainbow><span style=margin-left:.5rem>By Liu Chao</span></span></div><div class=footnote><span><a href=https://foreverblog.cn/go.html target=_blank><img src=https://img.foreverblog.cn/logo_en_default.png style=width:auto;height:16px></a> |
<a data-accent-color href=https://www.boyouquan.com/planet-shuttle style="font-size:16px;background-image:linear-gradient(to right,#d55b5b,#4d14e6);background-clip:text;color:transparent">博友圈·星球穿梭</a><br><a class=link href=/index.xml><span class="iconfont icon-RSS"></span></a> | <a class=link href=https://github.com/Pi3-l22 target=_ blank><span class="iconfont icon-GitHub"></span></a> | <a class=link href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank rel=noopener><span class="iconfont icon-creative-commons-fill"></span></a></span></div><div class=blog-icon></div></footer></div><script>document.addEventListener("DOMContentLoaded",function(){const n=localStorage.getItem("theme")||"light",e=document.querySelector('link[data-theme-style="light"]'),t=document.querySelector('link[data-theme-style="dark"]'),i=window.matchMedia("(prefers-color-scheme: dark)");i.addListener(function(n){if(!localStorage.getItem("theme")){const s=n.matches?"dark":"light";document.documentElement.setAttribute("data-theme",s),localStorage.setItem("theme",s),s==="light"?(e.media="all",t.media="not all"):(e.media="not all",t.media="all");const o=document.querySelector("iframe.giscus-frame");if(o){const e=s==="light"?"light_tritanopia":"dark_tritanopia";o.contentWindow.postMessage({giscus:{setConfig:{theme:e}}},"https://giscus.app")}}}),n==="light"?(e.media="all",t.media="not all"):(e.media="not all",t.media="all");function o(){const e=document.querySelector("iframe.giscus-frame");if(e){const t=n==="light"?"light_tritanopia":"dark_tritanopia";e.contentWindow.postMessage({giscus:{setConfig:{theme:t}}},"https://giscus.app")}else setTimeout(o,1e3)}o();const s=document.querySelector(".theme-toggle");s&&(s.textContent=n==="light"?"黑暗":"明亮",s.addEventListener("click",function(){const o=document.documentElement.getAttribute("data-theme"),n=o==="light"?"dark":"light";document.documentElement.setAttribute("data-theme",n),localStorage.setItem("theme",n),n==="light"?(e.media="all",t.media="not all"):(e.media="not all",t.media="all");const s=document.querySelector("iframe.giscus-frame");if(s){const e=n==="light"?"light_tritanopia":"dark_tritanopia";s.contentWindow.postMessage({giscus:{setConfig:{theme:e}}},"https://giscus.app")}this.textContent=n==="light"?"黑暗":"明亮"}))})</script><script src=https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){confetti({particleCount:150,spread:100})})</script></body></html>