<!doctype html><html lang=zh-cn><head><script>(function(){const e=localStorage.getItem("theme")||"light";document.documentElement.setAttribute("data-theme",e)})()</script><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=author content="LiuChao"><meta name=description content="汇总了几个 Go 语言常用的标准库用法笔记，方便学习查阅。"><link rel=icon href=https://blog.pi3.fun/favicon.ico><meta name=keywords content=" study  latex  life  academic "><meta property="og:url" content="https://blog.pi3.fun/post/2025/01/go-standard-library/"><meta property="og:site_name" content="Pi3's Notes"><meta property="og:title" content="Go语言常用标准库"><meta property="og:description" content="汇总了几个 Go 语言常用的标准库用法笔记，方便学习查阅。"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-01-13T00:00:00+00:00"><meta property="article:modified_time" content="2025-01-13T00:00:00+00:00"><meta property="article:tag" content="技术"><meta property="article:tag" content="Golang"><link rel=canonical href=https://blog.pi3.fun/post/2025/01/go-standard-library/><meta itemprop=name content="Go语言常用标准库"><meta itemprop=description content="汇总了几个 Go 语言常用的标准库用法笔记，方便学习查阅。"><meta itemprop=datePublished content="2025-01-13T00:00:00+00:00"><meta itemprop=dateModified content="2025-01-13T00:00:00+00:00"><meta itemprop=wordCount content="19951"><meta itemprop=keywords content="技术,Golang"><link media=screen rel=stylesheet href=https://blog.pi3.fun/css/common.css><link media=screen rel=stylesheet href=https://blog.pi3.fun/css/content.css><link media=screen rel=stylesheet href=https://blog.pi3.fun/css/theme.css><link media=screen rel=stylesheet href=https://blog.pi3.fun/css/iconfont/iconfont.css><link rel=stylesheet href=https://blog.pi3.fun/css/syntax/xcode.css data-theme-style=light media="(prefers-color-scheme: light)"><link rel=stylesheet href=https://blog.pi3.fun/css/syntax/catppuccin-mocha.css data-theme-style=dark media="not all"><title>Go语言常用标准库 - Pi3's Notes</title>
<link rel=stylesheet href=https://blog.pi3.fun/css/single.css><link href=https://lf3-cdn-tos.bytecdntp.com/cdn/expire-100-y/KaTeX/0.15.2/katex.min.css rel=stylesheet><script defer src=https://lf3-cdn-tos.bytecdntp.com/cdn/expire-100-y/KaTeX/0.15.2/katex.min.js></script><script defer src=https://lf3-cdn-tos.bytecdntp.com/cdn/expire-100-y/KaTeX/0.15.2/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}],ignoredTags:["script","noscript","style","textarea","pre","code","option"],throwOnError:!1})})</script></head><body><div id=wrapper><header id=header><link rel=stylesheet href=https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkaibright/dist/LXGWBright-Regular/result.css><link rel=stylesheet href=https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkaibright/dist/LXGWBright-Italic/result.css><link rel=stylesheet href=https://chinese-fonts-cdn.deno.dev/packages/maple-mono-cn/dist/MapleMono-CN-Regular/result.css><h1><a href=https://blog.pi3.fun/>Pi3's Notes</a></h1><nav><span class=nav-bar-item><a class=link href=/>文章</a>
</span><span class=nav-bar-item><a class=link href=https://www.boyouquan.com/planet-shuttle>穿梭</a>
</span><span class=nav-bar-item><a class=link href=/about/>关于</a>
</span><span class=nav-bar-item><a class=link href=/links/>友链</a>
</span><span class=nav-bar-item><a class="link theme-toggle" href=javascript:void(0);>黑暗</a></span></nav></header><main id=main class=post><h1>Go语言常用标准库</h1><div><b>Keywords: </b><a class=link href=https://blog.pi3.fun/tags/%E6%8A%80%E6%9C%AF>#技术</a>
<a class=link href=https://blog.pi3.fun/tags/golang>#Golang</a></div><div><b>Release Date: </b><span>2025-01-13</span></div><details><summary><b>Table of Contents</b></summary><div class=toc><nav id=TableOfContents><ul><li><a href=#常用标准库>常用标准库</a></li><li><a href=#fmt>fmt</a></li><li><a href=#nethttp>net/http</a></li><li><a href=#os>os</a></li><li><a href=#io>io</a></li><li><a href=#ioioutil>io/ioutil</a></li><li><a href=#bufio>bufio</a></li><li><a href=#encodingjson>encoding/json</a></li><li><a href=#time>time</a></li><li><a href=#testing>testing</a></li><li><a href=#sync>sync</a><ul><li><a href=#mutex>Mutex</a></li><li><a href=#rwmutex>RWMutex</a></li><li><a href=#waitgroup>WaitGroup</a></li><li><a href=#map>Map</a></li><li><a href=#pool>Pool</a></li><li><a href=#once>Once</a></li><li><a href=#cond>Cond</a></li></ul></li><li><a href=#context>context</a><ul><li><a href=#context-的使用场景>Context 的使用场景</a></li><li><a href=#注意事项>注意事项</a></li><li><a href=#最佳实践>最佳实践</a></li><li><a href=#常见问题>常见问题</a></li></ul></li><li><a href=#errors>errors</a></li><li><a href=#log>log</a></li><li><a href=#pathfilepath>path/filepath</a></li><li><a href=#flag>flag</a></li><li><a href=#slices-maps>slices maps</a></li></ul></nav></div></details><article class=content><p>汇总了几个 Go 语言常用的标准库用法笔记，方便学习查阅。</p><h2 id=常用标准库>常用标准库</h2><ul><li><strong><code>fmt</code></strong> - 格式化输入输出，类似于 C 语言中的 <code>printf</code> 和 <code>scanf</code>。</li><li><strong><code>net/http</code></strong> - 用于构建 HTTP 客户端和服务器。学习如何处理 HTTP 请求和响应。</li><li><strong><code>net/rpc</code></strong> - 提供了通过网络或其他 I/O 连接对一个对象的导出方法的访问。</li><li><strong><code>os</code></strong> - 提供与操作系统交互的功能，比如文件和目录的操作。</li><li><strong><code>io</code></strong> 和 <strong><code>io/ioutil</code></strong> - 用于处理输入输出操作，读取和写入文件。</li><li><strong><code>encoding/json</code></strong> - 用于处理 JSON 数据的编码和解码。</li><li><strong><code>time</code></strong> - 处理时间和日期的功能，包括时间格式化和时间计算。</li><li><strong><code>strings</code></strong> - 提供字符串处理的常用函数。</li><li><strong><code>strconv</code></strong> - 字符串与基本数据类型之间的转换。</li><li><strong><code>testing</code></strong> - 提供对 Go 包的自动化测试的支持。</li><li><strong><code>math</code></strong> - 提供基本的数学常数和函数。</li><li><strong><code>math/bits</code></strong> - Go 1.19 新增，用于 bit 操作。</li><li><strong><code>sync</code></strong> - 提供同步原语，如互斥锁和等待组，适用于并发编程。</li><li><strong><code>context</code></strong> - 用于处理请求的上下文，特别是在处理并发和超时操作时非常重要。</li><li><strong><code>errors</code></strong> - 用于创建和处理错误。</li><li><strong><code>log</code></strong> - 提供简单的日志记录功能。</li><li><strong><code>path/filepath</code></strong> - 操作文件路径的工具，适用于跨平台的路径处理。</li><li><strong><code>flag</code></strong> - 用于解析命令行参数，定义和处理命令行标志（flags）。</li><li><strong><code>slices</code> 和 <code>maps</code></strong> - Go 1.21 新增，用于切片和集合的操作。</li></ul><p><a href=https://studygolang.com/pkgdoc>Go语言标准库文档中文版</a></p><p><a href=https://pkg.go.dev/std>Standard library - Go Packages</a></p><h2 id=fmt>fmt</h2><p><strong>Printing</strong></p><p>通用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=o>%</span><span class=nx>v</span>	<span class=nx>值的默认格式表示</span>
</span></span><span class=line><span class=cl><span class=o>%+</span><span class=nx>v</span>	<span class=nx>类似</span><span class=o>%</span><span class=nx>v</span><span class=err>，</span><span class=nx>但输出结构体时会添加字段名</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=err>#</span><span class=nx>v</span>	<span class=nx>值的Go语法表示</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=nx>T</span>	<span class=nx>值的类型的Go语法表示</span>
</span></span><span class=line><span class=cl><span class=o>%%</span>	<span class=nx>百分号</span>
</span></span></code></pre></div><p>布尔值：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=o>%</span><span class=nx>t</span>	<span class=nx>单词true或false</span>
</span></span></code></pre></div><p>整数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=o>%</span><span class=nx>b</span>	<span class=nx>表示为二进制</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=nx>c</span>	<span class=nx>该值对应的unicode码值</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=nx>d</span>	<span class=nx>表示为十进制</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=nx>o</span>	<span class=nx>表示为八进制</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=nx>q</span>	<span class=nx>该值对应的单引号括起来的go语法字符字面值</span><span class=err>，</span><span class=nx>必要时会采用安全的转义表示</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=nx>x</span>	<span class=nx>表示为十六进制</span><span class=err>，</span><span class=nx>使用a</span><span class=o>-</span><span class=nx>f</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=nx>X</span>	<span class=nx>表示为十六进制</span><span class=err>，</span><span class=nx>使用A</span><span class=o>-</span><span class=nx>F</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=nx>U</span>	<span class=nx>表示为Unicode格式</span><span class=err>：</span><span class=nx>U</span><span class=o>+</span><span class=mi>1234</span><span class=err>，</span><span class=nx>等价于</span><span class=s>&#34;U+%04X&#34;</span>
</span></span></code></pre></div><p>浮点数与复数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=o>%</span><span class=nx>b</span>	<span class=nx>无小数部分</span><span class=err>、</span><span class=nx>二进制指数的科学计数法</span><span class=err>，</span><span class=nx>如</span><span class=o>-</span><span class=mi>123456</span><span class=nx>p</span><span class=o>-</span><span class=mi>78</span><span class=err>；</span><span class=nx>参见strconv</span><span class=p>.</span><span class=nx>FormatFloat</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=nx>e</span>	<span class=nx>科学计数法</span><span class=err>，</span><span class=nx>如</span><span class=o>-</span><span class=mf>1234.456e+78</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=nx>E</span>	<span class=nx>科学计数法</span><span class=err>，</span><span class=nx>如</span><span class=o>-</span><span class=mf>1234.456E+78</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=nx>f</span>	<span class=nx>有小数部分但无指数部分</span><span class=err>，</span><span class=nx>如123</span><span class=mf>.456</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=nx>F</span>	<span class=nx>等价于</span><span class=o>%</span><span class=nx>f</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=nx>g</span>	<span class=nx>根据实际情况采用</span><span class=o>%</span><span class=nx>e或</span><span class=o>%</span><span class=nx>f格式</span><span class=err>（</span><span class=nx>以获得更简洁</span><span class=err>、</span><span class=nx>准确的输出</span><span class=err>）</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=nx>G</span>	<span class=nx>根据实际情况采用</span><span class=o>%</span><span class=nx>E或</span><span class=o>%</span><span class=nx>F格式</span><span class=err>（</span><span class=nx>以获得更简洁</span><span class=err>、</span><span class=nx>准确的输出</span><span class=err>）</span>
</span></span></code></pre></div><p>字符串和字节串：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=o>%</span><span class=nx>s</span>	<span class=nx>直接输出字符串或者</span><span class=p>[]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=nx>q</span>	<span class=nx>该值对应的双引号括起来的go语法字符串字面值</span><span class=err>，</span><span class=nx>必要时会采用安全的转义表示</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=nx>x</span>	<span class=nx>每个字节用两字符十六进制数表示</span><span class=err>（</span><span class=nx>使用a</span><span class=o>-</span><span class=nx>f</span><span class=err>）</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=nx>X</span>	<span class=nx>每个字节用两字符十六进制数表示</span><span class=err>（</span><span class=nx>使用A</span><span class=o>-</span><span class=nx>F</span><span class=err>）</span>
</span></span></code></pre></div><blockquote><p>对字符串采用 <code>%x</code> 或 <code>%X</code> 时，会给各打印的字节之间加空格。</p></blockquote><p>指针：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=o>%</span><span class=nx>p</span>	<span class=nx>表示为十六进制</span><span class=err>，</span><span class=nx>并加上前导的0x</span>
</span></span></code></pre></div><p>宽度与精度：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=o>%</span><span class=nx>f</span><span class=p>:</span>    <span class=nx>默认宽度</span><span class=err>，</span><span class=nx>默认精度</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=mi>9</span><span class=nx>f</span>    <span class=nx>宽度9</span><span class=err>，</span><span class=nx>默认精度</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=mf>.2</span><span class=nx>f</span>   <span class=nx>默认宽度</span><span class=err>，</span><span class=nx>精度2</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=mf>9.2</span><span class=nx>f</span>  <span class=nx>宽度9</span><span class=err>，</span><span class=nx>精度2</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=mf>9.</span><span class=nx>f</span>   <span class=nx>宽度9</span><span class=err>，</span><span class=nx>精度0</span>
</span></span></code></pre></div><p>宽度和精度格式化控制的是<strong>Unicode 码值</strong>的数量，而不是像 C 语言中的字节数量。因此即使 Go 语言字符串中的中文占据 3 个字节，也被当做一个<strong>Unicode 码值</strong>。</p><p>对于<strong class=chinese>字符串</strong>，精度是输出字符数目的最大数量，如果必要会截断字符串。</p><p>对于<strong class=chinese>整数</strong>，宽度和精度都设置输出总长度。采用精度时表示右对齐并用 0 填充，而宽度默认表示用空格填充。</p><p>对于<strong class=chinese>浮点数</strong>，宽度设置输出总长度；精度设置小数部分长度（如果有的话），除了%g 和%G，此时精度设置总的数字个数。例如，对数字 <code>123.45</code>，格式 <code>%6.2f</code> 输出 <code>123.45</code>；格式 <code>%.4g</code> 输出 <code>123.5</code>。<code>%e</code> 和 <code>%f</code> 的默认精度是 <code>6</code>，<code>%g</code> 的默认精度是可以将该值区分出来需要的最小数字个数。</p><p>对<strong class=chinese>复数</strong>，宽度和精度会分别用于实部和虚部，结果用小括号包裹。因此 <code>%f</code> 用于 <code>1.2+3.4i</code> 输出 <code>(1.200000+3.400000i)</code>。</p><p>其他 flag：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=sc>&#39;+&#39;</span>	<span class=nx>总是输出数值的正负号</span><span class=err>；</span><span class=nx>对</span><span class=o>%</span><span class=nx>q</span><span class=err>（</span><span class=o>%+</span><span class=nx>q</span><span class=err>）</span><span class=nx>会生成全部是ASCII字符的输出</span><span class=err>（</span><span class=nx>通过转义</span><span class=err>）；</span>
</span></span><span class=line><span class=cl><span class=sc>&#39; &#39;</span>	<span class=nx>对数值</span><span class=err>，</span><span class=nx>正数前加空格而负数前加负号</span><span class=err>；</span>
</span></span><span class=line><span class=cl><span class=sc>&#39;-&#39;</span>	<span class=nx>在输出右边填充空白而不是默认的左边</span><span class=err>（</span><span class=nx>即从默认的右对齐切换为左对齐</span><span class=err>）；</span>
</span></span><span class=line><span class=cl><span class=sc>&#39;#&#39;</span>	<span class=nx>切换格式</span>
</span></span><span class=line><span class=cl><span class=sc>&#39;0&#39;</span>	<span class=nx>使用0而不是空格填充</span><span class=err>，</span><span class=nx>对于数值类型会把填充的0放在正负号后面</span><span class=err>；</span>
</span></span></code></pre></div><p>对于 <code>#</code>，切换格式。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=o>%</span><span class=err>#</span><span class=nx>o</span>  <span class=nx>八进制数前加0</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=err>#</span><span class=nx>x</span>  <span class=nx>十六进制数前加0x</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=err>#</span><span class=nx>X</span>  <span class=nx>十六进制数前加0X</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=err>#</span><span class=nx>p</span>  <span class=nx>指针去掉前面的0x</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=err>#</span><span class=nx>q</span>  <span class=nx>如果strconv</span><span class=p>.</span><span class=nx>CanBackquote返回</span><span class=sc>&#39;真&#39;</span><span class=nx>会输出反引号括起来的未转义字符串</span><span class=p>(</span><span class=o>%</span><span class=nx>q</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=err>#</span><span class=nx>U</span>  <span class=nx>输出Unicode格式后</span><span class=err>，</span><span class=nx>如字符可打印</span><span class=err>，</span><span class=nx>还会输出空格和单引号括起来的go字面值</span><span class=p>(</span><span class=o>%</span><span class=nx>U</span><span class=p>)</span>
</span></span></code></pre></div><p>Go 语言格式化字符串会忽略不支持的 flag</p><p>如果操作数是一个接口值，那么会使用接口内部保管的值，而不是接口，因此：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>i</span> <span class=kd>interface</span><span class=p>{}</span> <span class=p>=</span> <span class=mi>23</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%v\n&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
</span></span></code></pre></div><p>显式指定参数索引，通过 <code>[]</code> 包括数字表示第几个索引。如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;%[2]d %[1]d\n&#34;</span><span class=p>,</span> <span class=mi>11</span><span class=p>,</span> <span class=mi>22</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// 22 11
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;%[3]*.[2]*[1]f&#34;</span><span class=p>,</span> <span class=mf>12.0</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>6</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// 等价于
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;%6.2f&#34;</span><span class=p>,</span> <span class=mf>12.0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// 12.00
</span></span></span></code></pre></div><p>可以通过重设索引用于多次打印同一个值：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;%d %d %#[1]x %#x&#34;</span><span class=p>,</span> <span class=mi>16</span><span class=p>,</span> <span class=mi>17</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// 16 17 0x10 0x11
</span></span></span></code></pre></div><p><strong>Scanning</strong></p><ul><li>Scan、Scanf 和 Scanln 从标准输入 os. Stdin 读取文本；</li><li>Fscan、Fscanf、Fscanln 从指定的 io. Reader 接口读取文本；</li><li>Sscan、Sscanf、Sscanln 从一个参数字符串读取文本。</li></ul><p>Scanln、Fscanln、Sscanln 会在读取到<strong class=chinese>换行</strong>时停止，并要求一次提供一行所有条目；</p><p>Scanf、Fscanf、Sscanf 只有在格式化文本末端有换行时会读取到换行为止；</p><p>其他函数会将换行视为空白。</p><p>Scanf、Fscanf、Sscanf 会根据格式字符串解析参数，类似 Printf。例如 <code>%x</code> 会读取一个十六进制的整数，<code>%v</code> 会按对应值的默认格式读取。</p><p>格式规则类似 Printf，有如下区别：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=o>%</span><span class=nx>p</span> <span class=nx>未实现</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=nx>T</span> <span class=nx>未实现</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=nx>e</span> <span class=o>%</span><span class=nx>E</span> <span class=o>%</span><span class=nx>f</span> <span class=o>%</span><span class=nx>F</span> <span class=o>%</span><span class=nx>g</span> <span class=o>%</span><span class=nx>G</span> <span class=nx>效果相同</span><span class=err>，</span><span class=nx>用于读取浮点数或复数类型</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=nx>s</span> <span class=o>%</span><span class=nx>v</span> <span class=nx>用在字符串时会读取空白分隔的一个片段</span>
</span></span><span class=line><span class=cl><span class=nx>flag</span> <span class=sc>&#39;#&#39;</span><span class=nx>和</span><span class=sc>&#39;+&#39;</span> <span class=nx>未实现</span>
</span></span></code></pre></div><p>在<strong>无格式化 verb</strong> 或 <code>%v</code> 下扫描整数时可以接受常用的进制设置前缀 <code>0</code>（八进制）和 <code>0x</code>（十六进制）。</p><p>当使用格式字符串进行扫描时，多个连续的空白字符（除了换行符）在输出和输出中都被等价于一个空白符。</p><p>在所有的扫描函数里，<code>\r\n</code> 都被视为 <code>\n</code>。</p><hr><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Printf</span><span class=p>(</span><span class=nx>format</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>a</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>Printf 根据 format 参数生成格式化的字符串并写入标准输出。返回写入的字节数和遇到的任何错误。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Fprintf</span><span class=p>(</span><span class=nx>w</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Writer</span><span class=p>,</span> <span class=nx>format</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>a</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>Fprintf 根据 format 参数生成格式化的字符串并写入 w。返回写入的字节数和遇到的任何错误。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Sprintf</span><span class=p>(</span><span class=nx>format</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>a</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=kt>string</span>
</span></span></code></pre></div><p>Sprintf 根据 format 参数生成格式化的字符串并返回该字符串。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Print</span><span class=p>(</span><span class=nx>a</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>Print 采用默认格式将其参数格式化并写入标准输出。如果两个相邻的参数都不是字符串，会在它们的输出之间添加空格。返回写入的字节数和遇到的任何错误。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Fprint</span><span class=p>(</span><span class=nx>w</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Writer</span><span class=p>,</span> <span class=nx>a</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>Fprint 采用默认格式将其参数格式化并写入 w。如果两个相邻的参数都不是字符串，会在它们的输出之间添加空格。返回写入的字节数和遇到的任何错误。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Sprint</span><span class=p>(</span><span class=nx>a</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=kt>string</span>
</span></span></code></pre></div><p>Sprint 采用默认格式将其参数格式化，串联所有输出生成并返回一个字符串。如果两个相邻的参数都不是字符串，会在它们的输出之间添加空格。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Println</span><span class=p>(</span><span class=nx>a</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>Println 采用默认格式将其参数格式化并写入标准输出。总是会在相邻参数的输出之间添加空格并在输出结束后添加换行符。返回写入的字节数和遇到的任何错误。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Fprintln</span><span class=p>(</span><span class=nx>w</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Writer</span><span class=p>,</span> <span class=nx>a</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>Fprintln 采用默认格式将其参数格式化并写入 w。总是会在相邻参数的输出之间添加空格并在输出结束后添加换行符。返回写入的字节数和遇到的任何错误。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Sprintln</span><span class=p>(</span><span class=nx>a</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=kt>string</span>
</span></span></code></pre></div><p>Sprintln 采用默认格式将其参数格式化，串联所有输出生成并返回一个字符串。总是会在相邻参数的输出之间添加空格并在输出结束后添加换行符。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Errorf</span><span class=p>(</span><span class=nx>format</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>a</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=kt>error</span>
</span></span></code></pre></div><p>Errorf 根据 format 参数生成格式化字符串并返回一个包含该字符串的错误。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Scanf</span><span class=p>(</span><span class=nx>format</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>a</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>Scanf 从标准输入扫描文本，根据 format 参数指定的格式将成功读取的空白分隔的值保存进成功传递给本函数的参数。返回成功扫描的条目个数和遇到的任何错误。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Fscanf</span><span class=p>(</span><span class=nx>r</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Reader</span><span class=p>,</span> <span class=nx>format</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>a</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>Fscanf 从 r 扫描文本，根据 format 参数指定的格式将成功读取的空白分隔的值保存进成功传递给本函数的参数。返回成功扫描的条目个数和遇到的任何错误。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Sscanf</span><span class=p>(</span><span class=nx>str</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>format</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>a</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>Sscanf 从字符串 str 扫描文本，根据 format 参数指定的格式将成功读取的空白分隔的值保存进成功传递给本函数的参数。返回成功扫描的条目个数和遇到的任何错误。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Scan</span><span class=p>(</span><span class=nx>a</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>Scan 从标准输入扫描文本，将成功读取的空白分隔的值保存进成功传递给本函数的参数。换行视为空白。返回成功扫描的条目个数和遇到的任何错误。如果读取的条目比提供的参数少，会返回一个错误报告原因。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Fscan</span><span class=p>(</span><span class=nx>r</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Reader</span><span class=p>,</span> <span class=nx>a</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>Fscan 从 r 扫描文本，将成功读取的空白分隔的值保存进成功传递给本函数的参数。换行视为空白。返回成功扫描的条目个数和遇到的任何错误。如果读取的条目比提供的参数少，会返回一个错误报告原因。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Sscan</span><span class=p>(</span><span class=nx>str</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>a</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>Sscan 从字符串 str 扫描文本，将成功读取的空白分隔的值保存进成功传递给本函数的参数。换行视为空白。返回成功扫描的条目个数和遇到的任何错误。如果读取的条目比提供的参数少，会返回一个错误报告原因。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Scanln</span><span class=p>(</span><span class=nx>a</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>Scanln 类似 Scan，但会在换行时才停止扫描。最后一个条目后必须有换行或者到达结束位置。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Fscanln</span><span class=p>(</span><span class=nx>r</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Reader</span><span class=p>,</span> <span class=nx>a</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>Fscanln 类似 Fscan，但会在换行时才停止扫描。最后一个条目后必须有换行或者到达结束位置。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Sscanln</span><span class=p>(</span><span class=nx>str</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>a</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>Sscanln 类似 Sscan，但会在换行时才停止扫描。最后一个条目后必须有换行或者到达结束位置。</p><h2 id=nethttp>net/http</h2><p>http 包提供了 HTTP 客户端和服务端的实现。</p><p>Get、Head、Post 和 PostForm 函数发出 HTTP/HTTPS 请求。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>resp</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>http</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=s>&#34;http://example.com/&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>resp</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>http</span><span class=p>.</span><span class=nf>Post</span><span class=p>(</span><span class=s>&#34;http://example.com/upload&#34;</span><span class=p>,</span> <span class=s>&#34;image/jpeg&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>buf</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>resp</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>http</span><span class=p>.</span><span class=nf>PostForm</span><span class=p>(</span><span class=s>&#34;http://example.com/form&#34;</span><span class=p>,</span> <span class=nx>url</span><span class=p>.</span><span class=nx>Values</span><span class=p>{</span><span class=s>&#34;key&#34;</span><span class=p>:</span> <span class=p>{</span><span class=s>&#34;Value&#34;</span><span class=p>},</span> <span class=s>&#34;id&#34;</span><span class=p>:</span> <span class=p>{</span><span class=s>&#34;123&#34;</span><span class=p>}})</span>
</span></span></code></pre></div><p>程序在使用完回复后必须关闭回复的主体。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>resp</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>http</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=s>&#34;http://example.com/&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// handle error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>defer</span> <span class=nx>resp</span><span class=p>.</span><span class=nx>Body</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nx>body</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>ioutil</span><span class=p>.</span><span class=nf>ReadAll</span><span class=p>(</span><span class=nx>resp</span><span class=p>.</span><span class=nx>Body</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span></code></pre></div><p>要管理 HTTP 客户端的头域、重定向策略和其他设置，创建一个 Client：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>client</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>http</span><span class=p>.</span><span class=nx>Client</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>CheckRedirect</span><span class=p>:</span> <span class=nx>redirectPolicyFunc</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>resp</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>client</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=s>&#34;http://example.com&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>req</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>http</span><span class=p>.</span><span class=nf>NewRequest</span><span class=p>(</span><span class=s>&#34;GET&#34;</span><span class=p>,</span> <span class=s>&#34;http://example.com&#34;</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>req</span><span class=p>.</span><span class=nx>Header</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=s>&#34;If-None-Match&#34;</span><span class=p>,</span> <span class=s>`W/&#34;wyzzy&#34;`</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>resp</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>client</span><span class=p>.</span><span class=nf>Do</span><span class=p>(</span><span class=nx>req</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span></code></pre></div><p>要管理代理、TLS 配置、keep-alive、压缩和其他设置，创建一个 Transport：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>tr</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>http</span><span class=p>.</span><span class=nx>Transport</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>TLSClientConfig</span><span class=p>:</span> <span class=o>&amp;</span><span class=nx>tls</span><span class=p>.</span><span class=nx>Config</span><span class=p>{</span><span class=nx>RootCAs</span><span class=p>:</span> <span class=nx>pool</span><span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=nx>DisableCompression</span><span class=p>:</span> <span class=kc>true</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>client</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>http</span><span class=p>.</span><span class=nx>Client</span><span class=p>{</span><span class=nx>Transport</span><span class=p>:</span> <span class=nx>tr</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>resp</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>client</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=s>&#34;https://example.com&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>Client 和 Transport 类型都可以安全的被多个 go 程同时使用。出于效率考虑，应该一次建立、尽量重用。</p><p>ListenAndServe 使用指定的监听地址和处理器启动一个 HTTP 服务端。处理器参数通常是 nil，这表示采用包变量 DefaultServeMux 作为处理器。Handle 和 HandleFunc 函数可以向 DefaultServeMux 添加处理器。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>http</span><span class=p>.</span><span class=nf>Handle</span><span class=p>(</span><span class=s>&#34;/foo&#34;</span><span class=p>,</span> <span class=nx>fooHandler</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>http</span><span class=p>.</span><span class=nf>HandleFunc</span><span class=p>(</span><span class=s>&#34;/bar&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Fprintf</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=s>&#34;Hello, %q&#34;</span><span class=p>,</span> <span class=nx>html</span><span class=p>.</span><span class=nf>EscapeString</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>URL</span><span class=p>.</span><span class=nx>Path</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span><span class=line><span class=cl><span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>http</span><span class=p>.</span><span class=nf>ListenAndServe</span><span class=p>(</span><span class=s>&#34;:8080&#34;</span><span class=p>,</span> <span class=kc>nil</span><span class=p>))</span>
</span></span></code></pre></div><p>要管理服务端的行为，可以创建一个自定义的 Server：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>s</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>http</span><span class=p>.</span><span class=nx>Server</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Addr</span><span class=p>:</span>           <span class=s>&#34;:8080&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>Handler</span><span class=p>:</span>        <span class=nx>myHandler</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>ReadTimeout</span><span class=p>:</span>    <span class=mi>10</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>WriteTimeout</span><span class=p>:</span>   <span class=mi>10</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>MaxHeaderBytes</span><span class=p>:</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=mi>20</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>s</span><span class=p>.</span><span class=nf>ListenAndServe</span><span class=p>())</span>
</span></span></code></pre></div><h2 id=os>os</h2><p>os 包提供了操作系统函数的不依赖平台的接口。设计为 Unix 风格的，虽然错误处理是 go 风格的；失败的调用会返回错误值而非错误码。通常错误值里包含更多信息。例如，如果某个使用一个文件名的调用（如 Open、Stat）失败了，打印错误时会包含该文件名，错误类型将为 <code>*PathError</code>，其内部可以解包获得更多信息。</p><p>os 包的接口规定为在所有操作系统中都是一致的。非公用的属性可以从操作系统特定的 <a href=http://godoc.org/syscall>syscall</a> 包获取。</p><p>下面是一个简单的例子，打开一个文件并从中读取一些数据：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>file</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Open</span> <span class=p>(</span><span class=s>&#34;file. go&#34;</span><span class=p>)</span> <span class=c1>// For read access.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span> <span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>如果打开失败，错误字符串是自解释的，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>open</span> <span class=nx>file</span><span class=p>.</span> <span class=k>go</span><span class=p>:</span> <span class=nx>no</span> <span class=nx>such</span> <span class=nx>file</span> <span class=nx>or</span> <span class=nx>directory</span>
</span></span></code></pre></div><p>文件的信息可以读取进一个 <code>[]byte</code> 切片。Read 和 Write 方法从切片参数获取其内的字节数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>data</span> <span class=o>:=</span> <span class=nf>make</span> <span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=mi>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>count</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>file</span><span class=p>.</span><span class=nf>Read</span> <span class=p>(</span><span class=nx>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span> <span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span> <span class=p>(</span><span class=s>&#34;read %d bytes: %q\n&#34;</span><span class=p>,</span> <span class=nx>count</span><span class=p>,</span> <span class=nx>data</span><span class=p>[:</span> <span class=nx>count</span><span class=p>])</span>
</span></span></code></pre></div><p>如果读取的文件特别大，以上代码只能一次读取 128 字节，因此需要循环读取。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>data</span> <span class=o>:=</span> <span class=nf>make</span> <span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=mi>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>count</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>file</span><span class=p>.</span><span class=nf>Read</span> <span class=p>(</span><span class=nx>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=nx>io</span><span class=p>.</span> <span class=nx>EOF</span> <span class=p>{</span> <span class=c1>// End Of File
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=nx>data</span><span class=p>[:</span> <span class=nx>count</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span> <span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span> <span class=p>(</span><span class=s>&#34;read %d bytes: %q\n&#34;</span><span class=p>,</span> <span class=nx>count</span><span class=p>,</span> <span class=nx>data</span><span class=p>[:</span> <span class=nx>count</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>用 append 函数就可以将每次循环读出的字节添加到一个数组中去。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>File</span><span class=p>)</span> <span class=nf>Read</span> <span class=p>(</span><span class=nx>b</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>Read 方法从 f 中读取最多 len (b) 字节数据并写入 b。它返回读取的字节数和可能遇到的任何错误。文件终止标志是读取 0 个字节且返回值 err 为 <code>io. EOF</code>。</p><p>Go 1.16 版本后，新增 <code>os. ReadFile</code>，与 <code>ioutil. ReadFile</code> 功能类似。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>ReadFile</span> <span class=p>(</span><span class=nx>name</span> <span class=kt>string</span><span class=p>)([]</span><span class=kt>byte</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>如果需要写入文件，则最好通过 <code>os. OpenFile</code> 通过指定模式和权限的方式去打开文件。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>OpenFile</span> <span class=p>(</span><span class=nx>name</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>flag</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>perm</span> <span class=nx>FileMode</span><span class=p>)</span> <span class=p>(</span><span class=nx>file</span> <span class=o>*</span><span class=nx>File</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>OpenFile 是一个更一般性的文件打开函数，大多数调用者都应用 Open 或 Create 代替本函数。它会使用指定的选项（如 O_RDONLY 等）、指定的模式（如 0666 等）打开指定名称的文件。如果操作成功，返回的文件对象可用于 I/O。如果出错，错误底层类型是 <code>*PathError</code>。</p><p><img src=assets/img-20250109140002.png alt></p><p>需要指定多个文件模式，可以使用 <code>|</code> 来连接。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>File</span><span class=p>)</span> <span class=nf>Write</span> <span class=p>(</span><span class=nx>b</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>Write 向文件中写入 len (b) 字节数据。它返回写入的字节数和可能遇到的任何错误。如果返回值<code>n!=len (b)</code>，本方法会返回一个非 nil 的错误。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>File</span><span class=p>)</span> <span class=nf>WriteString</span> <span class=p>(</span><span class=nx>s</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>ret</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>WriteString 类似 Write，但接受一个字符串参数。</p><h2 id=io>io</h2><p>io 包提供了对 I/O 原语的基本接口。本包的基本任务是包装这些原语已有的实现（如 os 包里的原语），使之成为共享的公共接口，这些公共接口抽象出了泛用的函数并附加了一些相关的原语的操作。</p><p>因为这些接口和原语是对底层实现完全不同的低水平操作的包装，除非得到其它方面的通知，客户端不应假设它们是并发执行安全的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>ReadAll</span> <span class=p>(</span><span class=nx>r</span> <span class=nx>io</span><span class=p>.</span> <span class=nx>Reader</span><span class=p>)</span> <span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>ReadAll 从 r 读取直到出现错误或 EOF，然后返回读取的数据。成功地调用返回 <code>err == nil</code>，而不是 <code>err == EOF</code>。因为 ReadAll 被定义为从 src 读取直到 EOF，所以它不会将 Read 中的 EOF 视为要报告的错误。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>WriteString</span> <span class=p>(</span><span class=nx>w</span> <span class=nx>io</span><span class=p>.</span> <span class=nx>Writer</span><span class=p>,</span> <span class=nx>s</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>配合 os 库打开文件， io 库也可以实现文件的读取写入。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>file</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Open</span> <span class=p>(</span><span class=s>&#34;test. txt&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>file</span><span class=p>.</span><span class=nf>Close</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>data</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>io</span><span class=p>.</span><span class=nf>ReadAll</span> <span class=p>(</span><span class=nx>file</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=kt>string</span> <span class=p>(</span><span class=nx>data</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>file</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>OpenFile</span> <span class=p>(</span><span class=s>&#34;test. txt&#34;</span><span class=p>,</span> <span class=nx>os</span><span class=p>.</span> <span class=nx>O_APPEND</span><span class=p>|</span><span class=nx>os</span><span class=p>.</span> <span class=nx>O_CREATE</span><span class=p>,</span> <span class=mo>0755</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>file</span><span class=p>.</span><span class=nf>Close</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>io</span><span class=p>.</span><span class=nf>WriteString</span> <span class=p>(</span><span class=nx>file</span><span class=p>,</span> <span class=s>&#34;io write string\n&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=ioioutil>io/ioutil</h2><p>ioutil 在 io 包的基础上实现了一些工具函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>ReadAll</span> <span class=p>(</span><span class=nx>r</span> <span class=nx>io</span><span class=p>.</span> <span class=nx>Reader</span><span class=p>)</span> <span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>ReadAll 从 r 读取数据直到 EOF 或遇到 error，返回读取的数据和遇到的错误。成功的调用返回的 err 为 nil 而非 EOF。因为本函数定义为读取 r 直到 EOF，它不会将读取返回的 EOF 视为应报告的错误。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>ReadFile</span> <span class=p>(</span><span class=nx>filename</span> <span class=kt>string</span><span class=p>)</span> <span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>ReadFile 从 filename 指定的文件中读取数据并返回文件的内容。成功的调用返回的 err 为 nil 而非 EOF。因为本函数定义为读取整个文件，它不会将读取返回的 EOF 视为应报告的错误。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>WriteFile</span> <span class=p>(</span><span class=nx>filename</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>data</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>perm</span> <span class=nx>os</span><span class=p>.</span> <span class=nx>FileMode</span><span class=p>)</span> <span class=kt>error</span>
</span></span></code></pre></div><p>函数向 filename 指定的文件中写入数据。如果文件不存在将按给出的权限创建文件，否则在写入数据之前清空文件。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>ReadDir</span> <span class=p>(</span><span class=nx>dirname</span> <span class=kt>string</span><span class=p>)</span> <span class=p>([]</span><span class=nx>os</span><span class=p>.</span> <span class=nx>FileInfo</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>返回 dirname 指定的目录的目录信息的有序列表。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TempDir</span> <span class=p>(</span><span class=nx>dir</span><span class=p>,</span> <span class=nx>prefix</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>name</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>在 dir 目录里创建一个新的、使用 prfix 作为前缀的临时文件夹，并返回文件夹的路径。如果 dir 是空字符串，TempDir 使用默认用于临时文件的目录（参见 os. TempDir 函数）。不同程序同时调用该函数会创建不同的临时目录，调用本函数的程序有责任在不需要临时文件夹时摧毁它。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TempFile</span> <span class=p>(</span><span class=nx>dir</span><span class=p>,</span> <span class=nx>prefix</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>os</span><span class=p>.</span> <span class=nx>File</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>在 dir 目录下创建一个新的、使用 prefix 为前缀的临时文件，以读写模式打开该文件并返回 os. File 指针。如果 dir 是空字符串，TempFile 使用默认用于临时文件的目录（参见 os. TempDir 函数）。不同程序同时调用该函数会创建不同的临时文件，调用本函数的程序有责任在不需要临时文件时摧毁它。</p><h2 id=bufio>bufio</h2><p>bufio 包实现了有缓冲的 I/O。它包装一个 io. Reader 或 io. Writer 接口对象，创建另一个也实现了该接口，且同时还提供了缓冲和一些文本 I/O 的帮助函数的对象。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>Reader</span><span class=p>)</span> <span class=nf>Read</span> <span class=p>(</span><span class=nx>p</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>Read 读取数据写入 p。本方法返回写入 p 的字节数。本方法一次调用最多会调用下层 Reader 接口一次 Read 方法，因此返回值 n 可能小于 len (p)。读取到达结尾时，返回值 n 将为 0 而 err 将为 io. EOF。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>Reader</span><span class=p>)</span> <span class=nf>ReadByte</span> <span class=p>()</span> <span class=p>(</span><span class=nx>c</span> <span class=kt>byte</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>ReadByte 读取并返回一个字节。如果没有可用的数据，会返回错误。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>Reader</span><span class=p>)</span> <span class=nf>ReadBytes</span> <span class=p>(</span><span class=nx>delim</span> <span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>line</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>ReadBytes 读取直到第一次遇到 delim 字节，返回一个包含已读取的数据和 delim 字节的切片。如果 ReadBytes 方法在读取到 delim 之前遇到了错误，它会返回在错误之前读取的数据以及该错误（一般是 io. EOF）。当且仅当 ReadBytes 方法返回的切片不以 delim 结尾时，会返回一个非 nil 的错误。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>Reader</span><span class=p>)</span> <span class=nf>ReadString</span> <span class=p>(</span><span class=nx>delim</span> <span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>line</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>ReadString 读取直到第一次遇到 delim 字节，返回一个包含已读取的数据和 delim 字节的字符串。如果 ReadString 方法在读取到 delim 之前遇到了错误，它会返回在错误之前读取的数据以及该错误（一般是 io. EOF）。当且仅当 ReadString 方法返回的切片不以 delim 结尾时，会返回一个非 nil 的错误。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>Reader</span><span class=p>)</span> <span class=nf>ReadLine</span> <span class=p>()</span> <span class=p>(</span><span class=nx>line</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>isPrefix</span> <span class=kt>bool</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>ReadLine 是一个低水平的行数据读取原语。大多数调用者应使用 <code>ReadBytes ('\n')</code> 或 <code>ReadString ('\n')</code> 代替，或者使用 Scanner。</p><p>ReadLine 尝试返回一行数据，不包括行尾标志的字节。如果行太长超过了缓冲，返回值 isPrefix 会被设为 true，并返回行的前面一部分。该行剩下的部分将在之后的调用中返回。返回值 isPrefix 会在返回该行最后一个片段时才设为 false。返回切片是缓冲的子切片，只在下一次读取操作之前有效。ReadLine 要么返回一个非 nil 的 line，要么返回一个非 nil 的 err，两个返回值至少一个非 nil。</p><p>返回的文本不包含行尾的标志字节（"\r\n"或"\n"）。如果输入流结束时没有行尾标志字节，方法不会出错，也不会指出这一情况。在调用 ReadLine 之后调用 UnreadByte 会总是吐出最后一个读取的字节（很可能是该行的行尾标志字节），即使该字节不是 ReadLine 返回值的一部分。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>Writer</span><span class=p>)</span> <span class=nf>Write</span> <span class=p>(</span><span class=nx>p</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>nn</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>Write 将 p 的内容写入缓冲。返回写入的字节数。如果返回值 nn &lt; len (p)，还会返回一个错误说明原因。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>Writer</span><span class=p>)</span> <span class=nf>WriteString</span> <span class=p>(</span><span class=nx>s</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>WriteString 写入一个字符串。返回写入的字节数。如果返回值 nn &lt; len (s)，还会返回一个错误说明原因。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>Writer</span><span class=p>)</span> <span class=nf>WriteByte</span> <span class=p>(</span><span class=nx>c</span> <span class=kt>byte</span><span class=p>)</span> <span class=kt>error</span>
</span></span></code></pre></div><p>WriteByte 写入单个字节。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>Writer</span><span class=p>)</span> <span class=nf>Flush</span> <span class=p>()</span> <span class=kt>error</span>
</span></span></code></pre></div><p>Flush 方法将缓冲中的数据写入下层的 io. Writer 接口。</p><h2 id=encodingjson>encoding/json</h2><p>将 Go 数据结构编码为 JSON 字符串：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Person</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Name</span> <span class=kt>string</span> <span class=s>`json: &#34;name&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=nx>Age</span>  <span class=kt>int</span>    <span class=s>`json: &#34;age&#34;`</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>person</span> <span class=o>:=</span> <span class=nx>Person</span><span class=p>{</span><span class=nx>Name</span><span class=p>:</span> <span class=s>&#34;John&#34;</span><span class=p>,</span> <span class=nx>Age</span><span class=p>:</span> <span class=mi>30</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>jsonData</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Marshal</span> <span class=p>(</span><span class=nx>person</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=kt>string</span> <span class=p>(</span><span class=nx>jsonData</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>将 JSON 字符串解码为 Go 数据结构：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Person</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Name</span> <span class=kt>string</span> <span class=s>`json: &#34;name&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=nx>Age</span>  <span class=kt>int</span>    <span class=s>`json: &#34;age&#34;`</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>jsonData</span> <span class=o>:=</span> <span class=s>`{&#34;name&#34;: &#34;John&#34;,&#34;age&#34;: 30}`</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>person</span> <span class=nx>Person</span>
</span></span><span class=line><span class=cl>    <span class=nx>json</span><span class=p>.</span><span class=nf>Unmarshal</span> <span class=p>([]</span><span class=kt>byte</span> <span class=p>(</span><span class=nx>jsonData</span><span class=p>),</span> <span class=o>&amp;</span><span class=nx>person</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=nx>person</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>使用<code>json: "-"</code>忽略字段的编码和解码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Person</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Name</span>      <span class=kt>string</span> <span class=s>`json: &#34;name&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=nx>Age</span>       <span class=kt>int</span>    <span class=s>`json: &#34;age&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=nx>Password</span>  <span class=kt>string</span> <span class=s>`json: &#34;-&#34;`</span>
</span></span><span class=line><span class=cl>    <span class=nx>ExtraInfo</span> <span class=kt>string</span> <span class=s>`json: &#34;extra_info, omitempty&#34;`</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>person</span> <span class=o>:=</span> <span class=nx>Person</span><span class=p>{</span><span class=nx>Name</span><span class=p>:</span> <span class=s>&#34;John&#34;</span><span class=p>,</span> <span class=nx>Age</span><span class=p>:</span> <span class=mi>30</span><span class=p>,</span> <span class=nx>Password</span><span class=p>:</span> <span class=s>&#34;secret&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>jsonData</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Marshal</span> <span class=p>(</span><span class=nx>person</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=kt>string</span> <span class=p>(</span><span class=nx>jsonData</span><span class=p>))</span> 
</span></span><span class=line><span class=cl>    <span class=c1>// 输出：{&#34;name&#34;: &#34;John&#34;,&#34;age&#34;: 30,&#34;extra_info&#34;: &#34;&#34;}
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h2 id=time>time</h2><p>time 包提供了时间的显示和测量用的函数。日历的计算采用的是公历。</p><p><code>time. Time</code> 类型表示时间。我们可以通过 <code>time.Now ()</code> 函数获取当前的时间对象，然后获取时间对象的年月日时分秒等信息。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>now</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span> <span class=p>()</span> <span class=c1>//获取当前时间
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span> <span class=p>(</span><span class=s>&#34;current time:%v\n&#34;</span><span class=p>,</span> <span class=nx>now</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>year</span> <span class=o>:=</span> <span class=nx>now</span><span class=p>.</span><span class=nf>Year</span> <span class=p>()</span>     <span class=c1>//年
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>month</span> <span class=o>:=</span> <span class=nx>now</span><span class=p>.</span><span class=nf>Month</span> <span class=p>()</span>   <span class=c1>//月
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>day</span> <span class=o>:=</span> <span class=nx>now</span><span class=p>.</span><span class=nf>Day</span> <span class=p>()</span>       <span class=c1>//日
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>hour</span> <span class=o>:=</span> <span class=nx>now</span><span class=p>.</span><span class=nf>Hour</span> <span class=p>()</span>     <span class=c1>//小时
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>minute</span> <span class=o>:=</span> <span class=nx>now</span><span class=p>.</span><span class=nf>Minute</span> <span class=p>()</span> <span class=c1>//分钟
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>second</span> <span class=o>:=</span> <span class=nx>now</span><span class=p>.</span><span class=nf>Second</span> <span class=p>()</span> <span class=c1>//秒
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>nanosecond</span> <span class=o>:=</span> <span class=nx>now</span><span class=p>.</span><span class=nf>Nanosecond</span> <span class=p>()</span> <span class=c1>// 纳秒
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>weekday</span> <span class=err>：</span><span class=p>=</span> <span class=nx>now</span><span class=p>.</span><span class=nf>Weekday</span> <span class=p>()</span> <span class=c1>// 星期
</span></span></span></code></pre></div><p>时间戳是自 1970 年 1 月 1 日（08:00:00GMT）至当前时间的总毫秒数。它也被称为 Unix 时间戳（UnixTimestamp）。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>now</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span> <span class=p>()</span>            <span class=c1>//获取当前时间
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>timestamp</span> <span class=mi>1</span> <span class=o>:=</span> <span class=nx>now</span><span class=p>.</span><span class=nf>Unix</span> <span class=p>()</span>     <span class=c1>//时间戳
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>timestamp</span> <span class=mi>2</span> <span class=o>:=</span> <span class=nx>now</span><span class=p>.</span><span class=nf>UnixNano</span> <span class=p>()</span> <span class=c1>//纳秒时间戳
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span> <span class=p>(</span><span class=s>&#34;current timestamp 1:%v\n&#34;</span><span class=p>,</span> <span class=nx>timestamp</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span> <span class=p>(</span><span class=s>&#34;current timestamp 2:%v\n&#34;</span><span class=p>,</span> <span class=nx>timestamp</span> <span class=mi>2</span><span class=p>)</span>
</span></span></code></pre></div><p>使用 time.Unix () 函数可以将时间戳转为时间格式。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>timeObj</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Unix</span> <span class=p>(</span><span class=nx>timestamp</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=c1>//将时间戳转为时间格式
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=nx>timeObj</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>year</span> <span class=o>:=</span> <span class=nx>timeObj</span><span class=p>.</span><span class=nf>Year</span> <span class=p>()</span>     <span class=c1>//年
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>month</span> <span class=o>:=</span> <span class=nx>timeObj</span><span class=p>.</span><span class=nf>Month</span> <span class=p>()</span>   <span class=c1>//月
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>day</span> <span class=o>:=</span> <span class=nx>timeObj</span><span class=p>.</span><span class=nf>Day</span> <span class=p>()</span>       <span class=c1>//日
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>hour</span> <span class=o>:=</span> <span class=nx>timeObj</span><span class=p>.</span><span class=nf>Hour</span> <span class=p>()</span>     <span class=c1>//小时
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>minute</span> <span class=o>:=</span> <span class=nx>timeObj</span><span class=p>.</span><span class=nf>Minute</span> <span class=p>()</span> <span class=c1>//分钟
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>second</span> <span class=o>:=</span> <span class=nx>timeObj</span><span class=p>.</span><span class=nf>Second</span> <span class=p>()</span> <span class=c1>//秒
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span> <span class=p>(</span><span class=s>&#34;%d-%02 d-%02 d %02 d:%02 d:%02 d\n&#34;</span><span class=p>,</span> <span class=nx>year</span><span class=p>,</span> <span class=nx>month</span><span class=p>,</span> <span class=nx>day</span><span class=p>,</span> <span class=nx>hour</span><span class=p>,</span> <span class=nx>minute</span><span class=p>,</span> <span class=nx>second</span><span class=p>)</span>
</span></span></code></pre></div><p>时间类型有一个自带的方法 Format 进行格式化，需要注意的是 Go 语言中格式化时间模板不是常见的 Y-m-d H:M: S 而是使用 Go 的诞生时间 2006 年 1 月 2 号 15 点 04 分。</p><p>如果想格式化为 12 小时方式，需指定 PM。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>now</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span> <span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1>// 格式化的模板为 Go 的出生时间 2006 年 1 月 2 号 15 点 04 分 Mon Jan
</span></span></span><span class=line><span class=cl><span class=c1>// 24 小时制
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=nx>now</span><span class=p>.</span><span class=nf>Format</span> <span class=p>(</span><span class=s>&#34;2006-01-02 15:04:05.000 Mon Jan&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=c1>// 12 小时制
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=nx>now</span><span class=p>.</span><span class=nf>Format</span> <span class=p>(</span><span class=s>&#34;2006-01-02 03:04:05.000 PM Mon Jan&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=nx>now</span><span class=p>.</span><span class=nf>Format</span> <span class=p>(</span><span class=s>&#34;2006/01/02 15:04&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=nx>now</span><span class=p>.</span><span class=nf>Format</span> <span class=p>(</span><span class=s>&#34;15:04 2006/01/02&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=nx>now</span><span class=p>.</span><span class=nf>Format</span> <span class=p>(</span><span class=s>&#34;2006/01/02&#34;</span><span class=p>))</span>
</span></span></code></pre></div><p><code>time.Parse ()</code> 方法可以将一个字符串解析为 <code>time. Time</code> 对象，解析时你需要提供相应的布局字符串来匹配时间格式。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>timeStr</span> <span class=o>:=</span> <span class=s>&#34;2024-10-01 14:45:02&#34;</span>
</span></span><span class=line><span class=cl><span class=nx>parsedTime</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span> <span class=nf>Parse</span> <span class=p>(</span><span class=s>&#34;2006-01-02 15:04:05&#34;</span><span class=p>,</span> <span class=nx>timeStr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span> <span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;解析时间出错: &#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span> <span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;解析后的时间: &#34;</span><span class=p>,</span> <span class=nx>parsedTime</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>输出结果为解析后的 time. Time 对象：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>解析后的时间</span><span class=p>:</span> <span class=mi>2024</span><span class=o>-</span><span class=mi>10</span><span class=o>-</span><span class=mi>11</span> <span class=mi>14</span><span class=p>:</span><span class=mi>45</span><span class=p>:</span><span class=mo>02</span> <span class=o>+</span><span class=mo>0000</span> <span class=nx>UTC</span>
</span></span></code></pre></div><p>在 Go 语言中，<code>time. Duration</code> 用于表示两个时间点之间的时间间隔。<code>Duration</code> 的单位是纳秒，可以用来表示从纳秒到小时之间的时间段。</p><p>通过 <code>time.Since ()</code> 可以计算某个时间点距离当前的时间间隔，返回的是一个 <code>time. Duration</code> 对象。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>startTime</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span> <span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span> <span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span> <span class=nx>Second</span><span class=p>)</span> <span class=c1>// 模拟耗时操作
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>elapsed</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Since</span> <span class=p>(</span><span class=nx>startTime</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;操作耗时: &#34;</span><span class=p>,</span> <span class=nx>elapsed</span><span class=p>)</span>
</span></span></code></pre></div><p>可以通过 <code>Add ()</code> 方法对时间进行加减操作，例如加上或减去一定的时间间隔。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>nextWeek</span> <span class=o>:=</span> <span class=nx>currentTime</span><span class=p>.</span><span class=nf>Add</span> <span class=p>(</span><span class=mi>7</span> <span class=o>*</span> <span class=mi>24</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span> <span class=nx>Hour</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;一周后的时间: &#34;</span><span class=p>,</span> <span class=nx>nextWeek</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>yesterday</span> <span class=o>:=</span> <span class=nx>currentTime</span><span class=p>.</span><span class=nf>Add</span> <span class=p>(</span><span class=o>-</span><span class=mi>24</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span> <span class=nx>Hour</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;昨天的时间: &#34;</span><span class=p>,</span> <span class=nx>yesterday</span><span class=p>)</span>
</span></span></code></pre></div><p>通过 <code>Sub ()</code> 方法，可以计算两个时间点之间的时间差。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>startTime</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Date</span> <span class=p>(</span><span class=mi>2024</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>9</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>time</span><span class=p>.</span> <span class=nx>Local</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=nx>duration</span> <span class=o>:=</span> <span class=nx>currentTime</span><span class=p>.</span><span class=nf>Sub</span> <span class=p>(</span><span class=nx>startTime</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;时间差: &#34;</span><span class=p>,</span> <span class=nx>duration</span><span class=p>)</span>
</span></span></code></pre></div><p>该方法返回两个 <code>time. Time</code> 对象之间的 <code>Duration</code>，可以进一步转换为天数、小时数等。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;时间差（小时）: &#34;</span><span class=p>,</span> <span class=nx>duration</span><span class=p>.</span><span class=nf>Hours</span> <span class=p>())</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;时间差（分钟）: &#34;</span><span class=p>,</span> <span class=nx>duration</span><span class=p>.</span><span class=nf>Minutes</span> <span class=p>())</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;时间差（秒）: &#34;</span><span class=p>,</span> <span class=nx>duration</span><span class=p>.</span><span class=nf>Seconds</span> <span class=p>())</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;时间差（纳秒）: &#34;</span><span class=p>,</span> <span class=nx>duration</span><span class=p>.</span><span class=nf>Nanoseconds</span> <span class=p>())</span>
</span></span></code></pre></div><p>time 包提供了两种常用的定时功能：Ticker 和 Timer。</p><p>最简单的定时操作是 <code>time.Sleep ()</code>，它会让当前 goroutine 暂停指定的时间。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;延时 3 秒执行&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span> <span class=p>(</span><span class=mi>3</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span> <span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;延时结束&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p><code>time.After ()</code> 返回一个通道，指定时间之后会向该通道发送当前时间。常用于超时控制。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=o>&lt;-</span><span class=nx>time</span><span class=p>.</span><span class=nf>After</span> <span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span> <span class=nx>Second</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;2 秒后执行&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Ticker 是一种定时器，它会按照指定的时间间隔周期性地触发事件。Ticker 通过 <code>NewTicker ()</code> 创建，返回一个通道，通道会定期发送时间信号。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>ticker</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>NewTicker</span> <span class=p>(</span><span class=mi>1</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span> <span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>go</span> <span class=kd>func</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>t</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>ticker</span><span class=p>.</span> <span class=nx>C</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;每秒触发一次，当前时间: &#34;</span><span class=p>,</span> <span class=nx>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}()</span>
</span></span><span class=line><span class=cl><span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span> <span class=p>(</span><span class=mi>5</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span> <span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>ticker</span><span class=p>.</span><span class=nf>Stop</span> <span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;Ticker 已停止&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>Timer 是一种一次性触发的定时器，指定时间后触发一次。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>timer</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>NewTimer</span> <span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span> <span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;当前时间：&#34;</span><span class=p>,</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span> <span class=p>())</span>
</span></span><span class=line><span class=cl><span class=nx>expirationTime</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>timer</span><span class=p>.</span> <span class=nx>C</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;触发时间：&#34;</span><span class=p>,</span> <span class=nx>expirationTime</span><span class=p>)</span>
</span></span></code></pre></div><p>time 包支持不同的时区处理，通过 <code>time.LoadLocation ()</code> 可以加载不同的时区，并将时间转换为该时区的时间。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>loc</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>LoadLocation</span> <span class=p>(</span><span class=s>&#34;America/New_York&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>nyTime</span> <span class=o>:=</span> <span class=nx>currentTime</span><span class=p>.</span><span class=nf>In</span> <span class=p>(</span><span class=nx>loc</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span> <span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;纽约时间: &#34;</span><span class=p>,</span> <span class=nx>nyTime</span><span class=p>)</span>
</span></span></code></pre></div><p>通过记录操作开始和结束时间，可以很方便地计算代码执行时间。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>start</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span> <span class=p>()</span> 
</span></span><span class=line><span class=cl><span class=c1>// 执行一些代码 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>elapsed</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Since</span> <span class=p>(</span><span class=nx>start</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;代码执行时间: &#34;</span><span class=p>,</span> <span class=nx>elapsed</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=testing>testing</h2><p>testing 提供对 Go 包的自动化测试的支持。通过 <code>go test</code> 命令，能够自动执行如下形式的任何函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TestXxx</span> <span class=p>(</span><span class=o>*</span><span class=nx>testing</span><span class=p>.</span> <span class=nx>T</span><span class=p>)</span>
</span></span></code></pre></div><p>其中 Xxx 可以是任何字母数字字符串（但第一个字母需要大写），用于识别测试例程。</p><p>在这些函数中，使用 Error, Fail 或相关方法来发出失败信号。</p><p>要编写一个新的测试套件，需要创建一个名称以 <code>_test. go</code> 结尾的文件，该文件包含<code>TestXxx </code>函数，如上所述。将该文件放在与被测试的包相同的包中。该文件将被排除在正常的程序包之外，但在运行 “go test” 命令时将被包含。有关详细信息，请运行 “go help test” 和 “go help testflag” 了解。</p><p>如果有需要，可以调用 <code>*T</code> 和 <code>*B</code> 的 Skip 方法，跳过该测试或基准测试：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TestTimeConsuming</span> <span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span> <span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>testing</span><span class=p>.</span> <span class=nf>Short</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>t</span><span class=p>.</span><span class=nf>Skip</span> <span class=p>(</span><span class=s>&#34;skipping test in short mode.&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>BenchmarkXxx</span> <span class=p>(</span><span class=o>*</span><span class=nx>testing</span><span class=p>.</span> <span class=nx>B</span><span class=p>)</span>
</span></span></code></pre></div><p>被认为是基准测试，通过 &ldquo;go test&rdquo; 命令，加上 -bench flag 来执行。多个基准测试按照顺序运行。</p><p>testing flags 的详细描述, 参见 <a href=https://github.com/golang/go/blob/master/cmd/go/#hdr-Description_of_testing_flags>githun源码</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>BenchmarkHello</span> <span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span> <span class=nx>B</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span> <span class=nf>Sprintf</span> <span class=p>(</span><span class=s>&#34;hello&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>基准函数会运行目标代码 <code>b.N</code> 次。在基准执行期间，会调整 <code>b.N</code> 直到基准测试函数持续足够长的时间。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>BenchmarkHello</span>    <span class=mi>10000000</span>    <span class=mi>282</span> <span class=nx>ns</span><span class=o>/</span><span class=nx>op</span>
</span></span></code></pre></div><p>意味着循环执行了 10000000 次，每次循环花费 282 纳秒 (ns)。</p><p>如果在运行前基准测试需要一些耗时的配置，则可以先重置定时器：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>BenchmarkBigLen</span> <span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span> <span class=nx>B</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>big</span> <span class=o>:=</span> <span class=nf>NewBig</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>b</span><span class=p>.</span><span class=nf>ResetTimer</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>big</span><span class=p>.</span> <span class=nf>Len</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>如果基准测试需要在并行设置中测试性能，则可以使用 RunParallel 辅助函数; 这样的基准测试一般与 go test -cpu 标志一起使用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>BenchmarkTemplateParallel</span> <span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span> <span class=nx>B</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>templ</span> <span class=o>:=</span> <span class=nx>template</span><span class=p>.</span> <span class=nf>Must</span> <span class=p>(</span><span class=nx>template</span><span class=p>.</span> <span class=nf>New</span> <span class=p>(</span><span class=s>&#34;test&#34;</span><span class=p>).</span> <span class=nf>Parse</span> <span class=p>(</span><span class=s>&#34;Hello, {{.}} !&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=nx>b</span><span class=p>.</span><span class=nf>RunParallel</span> <span class=p>(</span><span class=kd>func</span> <span class=p>(</span><span class=nx>pb</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span> <span class=nx>PB</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>var</span> <span class=nx>buf</span> <span class=nx>bytes</span><span class=p>.</span> <span class=nx>Buffer</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>pb</span><span class=p>.</span> <span class=nf>Next</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>buf</span><span class=p>.</span> <span class=nf>Reset</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=nx>templ</span><span class=p>.</span> <span class=nf>Execute</span> <span class=p>(</span><span class=o>&amp;</span><span class=nx>buf</span><span class=p>,</span> <span class=s>&#34;World&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>该包还可以运行并验证示例代码。示例函数可以包括以 &ldquo;Output：&rdquo; 开头的行注释，并在运行测试时与函数的标准输出进行比较。 （比较时会忽略前导和尾随空格。）这些是一个 example 的例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>ExampleHello</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span> <span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;hello&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Output: hello
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>ExampleSalutations</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span> <span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;hello, and&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span> <span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;goodbye&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Output:
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// hello, and
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// goodbye
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p><code>Unordered output: </code>形式的注释，和 <code>Output:</code> 类似，但是能够以任意顺序匹配行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>ExamplePerm</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>value</span> <span class=o>:=</span> <span class=k>range</span> <span class=nf>Perm</span> <span class=p>(</span><span class=mi>4</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span> <span class=nf>Println</span> <span class=p>(</span><span class=nx>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Unordered output: 4
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 2
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 3
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>没有输出注释的示例函数被编译但不执行。</p><p>example 声明的命名约定：包，函数 F，类型 T，类型 T 上的方法 M 依次是：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Example</span> <span class=p>()</span> <span class=p>{</span> <span class=o>...</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>ExampleF</span> <span class=p>()</span> <span class=p>{</span> <span class=o>...</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>ExampleT</span> <span class=p>()</span> <span class=p>{</span> <span class=o>...</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>ExampleT_M</span> <span class=p>()</span> <span class=p>{</span> <span class=o>...</span> <span class=p>}</span>
</span></span></code></pre></div><p>可以为包/类型/函数/方法提供多个 example 函数，这通过在名称上附加一个不同的后缀来实现。后缀必须是以小写字母开头。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Example_suffix</span> <span class=p>()</span> <span class=p>{</span> <span class=o>...</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>ExampleF_suffix</span> <span class=p>()</span> <span class=p>{</span> <span class=o>...</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>ExampleT_suffix</span> <span class=p>()</span> <span class=p>{</span> <span class=o>...</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>ExampleT_M_suffix</span> <span class=p>()</span> <span class=p>{</span> <span class=o>...</span> <span class=p>}</span>
</span></span></code></pre></div><p>当一个文件包含一个示例函数，同时至少一个其他函数，类型，变量或常量声明，或没有测试或基准函数时，这个测试文件作为示例存在，通常命名为 example_test. go</p><p>T 和 B 的 Run 方法允许定义子单元测试和子基准测试，而不必为每个子测试和子基准定义单独的函数。这使得可以使用 Table-Driven 的基准测试和创建层级测试。它还提供了一种共享通用 setup 和 tear-down 代码的方法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TestFoo</span> <span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span> <span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// &lt;setup code&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>t</span><span class=p>.</span><span class=nf>Run</span> <span class=p>(</span><span class=s>&#34;A=1&#34;</span><span class=p>,</span> <span class=kd>func</span> <span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span> <span class=nx>T</span><span class=p>)</span> <span class=p>{</span> <span class=o>...</span> <span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=nx>t</span><span class=p>.</span><span class=nf>Run</span> <span class=p>(</span><span class=s>&#34;A=2&#34;</span><span class=p>,</span> <span class=kd>func</span> <span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span> <span class=nx>T</span><span class=p>)</span> <span class=p>{</span> <span class=o>...</span> <span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=nx>t</span><span class=p>.</span><span class=nf>Run</span> <span class=p>(</span><span class=s>&#34;B=1&#34;</span><span class=p>,</span> <span class=kd>func</span> <span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span> <span class=nx>T</span><span class=p>)</span> <span class=p>{</span> <span class=o>...</span> <span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=c1>// &lt;tear-down code&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>每个子测试和子基准测试都有一个唯一的名称：顶级测试的名称和传递给 Run 的名称的组合，以斜杠分隔，并具有用于消歧的可选尾随序列号。</p><p>-run 和 -bench 命令行标志的参数是与测试名称相匹配的非固定的正则表达式。对于具有多个斜杠分隔元素（例如子测试）的测试，该参数本身是斜杠分隔的，其中表达式依次匹配每个名称元素。因为它是非固定的，一个空的表达式匹配任何字符串。例如，使用 &ldquo;匹配&rdquo; 表示 &ldquo;其名称包含&rdquo;：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>go <span class=nb>test</span> -run <span class=s1>&#39;&#39;</span>      <span class=c1># Run 所有测试。</span>
</span></span><span class=line><span class=cl>go <span class=nb>test</span> -run Foo     <span class=c1># Run 匹配 &#34;Foo&#34; 的顶层测试，例如 &#34;TestFooBar&#34;。</span>
</span></span><span class=line><span class=cl>go <span class=nb>test</span> -run Foo/A<span class=o>=</span>  <span class=c1># 匹配顶层测试 &#34;Foo&#34;，运行其匹配 &#34;A=&#34; 的子测试。</span>
</span></span><span class=line><span class=cl>go <span class=nb>test</span> -run /A<span class=o>=</span><span class=m>1</span>    <span class=c1># 运行所有匹配 &#34;A=1&#34; 的子测试。</span>
</span></span></code></pre></div><p>子测试也可用于控制并行性。所有的子测试完成后，父测试才会完成。在这个例子中，所有的测试是相互并行运行的，当然也只是彼此之间，不包括定义在其他顶层测试的子测试：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TestGroupedParallel</span> <span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span> <span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>tc</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>tests</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>tc</span> <span class=o>:=</span> <span class=nx>tc</span> <span class=c1>// capture range variable
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>t</span><span class=p>.</span><span class=nf>Run</span> <span class=p>(</span><span class=nx>tc</span><span class=p>.</span> <span class=nx>Name</span><span class=p>,</span> <span class=kd>func</span> <span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span> <span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>t</span><span class=p>.</span><span class=nf>Parallel</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=o>...</span>
</span></span><span class=line><span class=cl>        <span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在并行子测试完成之前，Run 方法不会返回，这提供了一种测试后清理的方法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TestTeardownParallel</span> <span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span> <span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// This Run will not return until the parallel tests finish.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>t</span><span class=p>.</span><span class=nf>Run</span> <span class=p>(</span><span class=s>&#34;group&#34;</span><span class=p>,</span> <span class=kd>func</span> <span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span> <span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>t</span><span class=p>.</span><span class=nf>Run</span> <span class=p>(</span><span class=s>&#34;Test 1&#34;</span><span class=p>,</span> <span class=nx>parallelTest</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>t</span><span class=p>.</span><span class=nf>Run</span> <span class=p>(</span><span class=s>&#34;Test 2&#34;</span><span class=p>,</span> <span class=nx>parallelTest</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>t</span><span class=p>.</span><span class=nf>Run</span> <span class=p>(</span><span class=s>&#34;Test 3&#34;</span><span class=p>,</span> <span class=nx>parallelTest</span> <span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=c1>// &lt;tear-down code&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>测试程序有时需要在测试之前或之后进行额外的设置（setup）或拆卸（teardown）。有时, 测试还需要控制在主线程上运行的代码。为了支持这些和其他一些情况, 如果测试文件包含函数:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TestMain</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span> <span class=nx>M</span><span class=p>)</span>
</span></span></code></pre></div><p>那么生成的测试将调用 TestMain (m)，而不是直接运行测试。TestMain 运行在主 goroutine 中, 可以在调用 m.Run 前后做任何设置和拆卸。应该使用 m.Run 的返回值作为参数调用 os. Exit。在调用 TestMain 时, flag. Parse 并没有被调用。所以，如果 TestMain 依赖于 command-line 标志 (包括 testing 包的标记), 则应该显示的调用 flag. Parse。</p><p>一个简单的 TestMain 的实现：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>TestMain</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span> <span class=nx>M</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// call flag. Parse () here if TestMain uses flags
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 如果 TestMain 使用了 flags，这里应该加上 flag. Parse ()
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>os</span><span class=p>.</span> <span class=nf>Exit</span> <span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nf>Run</span> <span class=p>())</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=sync>sync</h2><p>sync 包提供了基本的同步基元，如互斥锁。除了 Once 和 WaitGroup 类型，大部分都是适用于低水平程序线程，高水平的同步使用 channel 通信更好一些。</p><h3 id=mutex>Mutex</h3><p>sync. Mutex 可能是 sync 包中使用最广泛的原语。它允许在共享资源上互斥访问（不能同时访问）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>mutex</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>sync</span><span class=p>.</span> <span class=nx>Mutex</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=nx>mutex</span><span class=p>.</span> <span class=nf>Lock</span> <span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1>// Update 共享变量 (比如切片，结构体指针等)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>mutex</span><span class=p>.</span> <span class=nf>Unlock</span> <span class=p>()</span>
</span></span></code></pre></div><p>必须指出的是，在第一次被使用后，不能再对 sync. Mutex 进行复制。（sync 包的所有原语都一样）。如果结构体具有同步原语字段，则必须通过指针传递它。</p><h3 id=rwmutex>RWMutex</h3><p>sync. RWMutex 是一个读写互斥锁，它提供了我们上面的刚刚看到的 sync. Mutex 的 Lock 和 UnLock 方法（因为这两个结构都实现了 sync. Locker 接口）。但是，它还允许使用 RLock 和 RUnlock 方法进行并发读取：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>mutex</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>sync</span><span class=p>.</span> <span class=nx>RWMutex</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=nx>mutex</span><span class=p>.</span> <span class=nf>Lock</span> <span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1>// Update 共享变量
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>mutex</span><span class=p>.</span> <span class=nf>Unlock</span> <span class=p>()</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=nx>mutex</span><span class=p>.</span> <span class=nf>RLock</span> <span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1>// Read 共享变量
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>mutex</span><span class=p>.</span> <span class=nf>RUnlock</span> <span class=p>()</span>
</span></span></code></pre></div><p>sync. RWMutex 允许至少一个读锁或一个写锁存在，而 sync. Mutex 允许一个读锁或一个写锁存在。</p><p>锁定/解锁<code>sync. RWMutex</code>读锁的速度比锁定/解锁<code>sync. Mutex</code>更快，另一方面，在<code>sync. RWMutex</code>上调用<code>Lock ()</code>/ <code>Unlock ()</code>是最慢的操作。</p><p>因此，只有在频繁读取和不频繁写入的场景里，才应该使用 <code>sync. RWMutex</code>。</p><h3 id=waitgroup>WaitGroup</h3><p>sync. WaitGroup 也是一个经常会用到的同步原语，它的使用场景是在一个 goroutine 等待一组 goroutine 执行完成。</p><p>sync. WaitGroup 拥有一个内部计数器。当计数器等于 0 时，则 <code>Wait ()</code> 方法会立即返回。否则它将阻塞执行 <code>Wait ()</code> 方法的 goroutine 直到计数器等于 0 时为止。</p><p>要增加计数器，我们必须使用 <code>Add (int)</code> 方法。要减少它，我们可以使用 <code>Done ()</code>（将计数器减 1），也可以传递负数给 <code>Add </code>方法把计数器减少指定大小，<code>Done ()</code> 方法底层就是通过 <code>Add (-1)</code> 实现的。</p><p>在以下示例中，我们将启动 8 个 goroutine，并等待他们完成：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>wg</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>sync</span><span class=p>.</span> <span class=nx>WaitGroup</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>8</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>go</span> <span class=kd>func</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Do something
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=p>}()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span> <span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1>// 继续往下执行...
</span></span></span></code></pre></div><p>每次创建 goroutine 时，我们都会使用 <code>wg.Add (1)</code> 来增加 wg 的内部计数器。我们也可以在 for 循环之前调用 <code>wg.Add (8)</code>。</p><p>与此同时，每个 goroutine 完成时，都会使用 <code>wg.Done ()</code> 减少 wg 的内部计数器。</p><p>main goroutine 会在八个 goroutine 都执行 <code>wg.Done ()</code> 将计数器变为 0 后才能继续执行。</p><h3 id=map>Map</h3><p>sync. Map 是一个并发版本的 Go 语言的 map，我们可以：</p><ul><li>使用 <code>Store (interface {}，interface {})</code> 添加元素。</li><li>使用 <code>Load (interface {}) interface {}</code>检索元素。</li><li>使用 <code>Delete (interface {})</code> 删除元素。</li><li>使用 <code>LoadOrStore (interface {}，interface {}) (interface {}，bool)</code> 检索或添加之前不存在的元素。如果键之前在 map 中存在，则返回的布尔值为 true。</li><li>使用 Range 遍历元素。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>m</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>sync</span><span class=p>.</span> <span class=nx>Map</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=c1>// 添加元素
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>m</span><span class=p>.</span><span class=nf>Store</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=s>&#34;one&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>m</span><span class=p>.</span><span class=nf>Store</span> <span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=s>&#34;two&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// 获取元素 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>value</span><span class=p>,</span> <span class=nx>contains</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nf>Load</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>contains</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span> <span class=p>(</span><span class=s>&#34;%s\n&#34;</span><span class=p>,</span> <span class=nx>value</span><span class=p>.</span> <span class=p>(</span><span class=kt>string</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 返回已存 value，否则把指定的键值存储到 map 中
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>value</span><span class=p>,</span> <span class=nx>loaded</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nf>LoadOrStore</span> <span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=s>&#34;three&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>!</span><span class=nx>loaded</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span> <span class=p>(</span><span class=s>&#34;%s\n&#34;</span><span class=p>,</span> <span class=nx>value</span><span class=p>.</span> <span class=p>(</span><span class=kt>string</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>m</span><span class=p>.</span><span class=nf>Delete</span> <span class=p>(</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// 迭代所有元素
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>m</span><span class=p>.</span><span class=nf>Range</span> <span class=p>(</span><span class=kd>func</span> <span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nx>value</span> <span class=kd>interface</span><span class=p>{})</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span> <span class=p>(</span><span class=s>&#34;%d: %s\n&#34;</span><span class=p>,</span> <span class=nx>key</span><span class=p>.</span> <span class=p>(</span><span class=kt>int</span><span class=p>),</span> <span class=nx>value</span><span class=p>.</span> <span class=p>(</span><span class=kt>string</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></div><p>输出</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>one</span>
</span></span><span class=line><span class=cl><span class=nx>three</span>
</span></span><span class=line><span class=cl><span class=mi>1</span><span class=p>:</span> <span class=nx>one</span>
</span></span><span class=line><span class=cl><span class=mi>2</span><span class=p>:</span> <span class=nx>two</span>
</span></span></code></pre></div><p>如你所见，Range 方法接收一个类型为 <code>func (key，value interface {}) bool</code> 的函数参数。如果函数返回了 false，则停止迭代。有趣的事实是，即使我们在恒定时间后返回 false，最坏情况下的时间复杂度仍为 O (n)。</p><p>我们应该在什么时候使用 sync. Map 而不是在普通的 map 上使用 sync. Mutex？</p><p>当我们对 map 有频繁的读取和不频繁的写入时。当多个 goroutine 读取，写入和覆盖不相交的键时。具体是什么意思呢？</p><p>例如，如果我们有一个分片实现，其中包含一组 4 个 goroutine，每个 goroutine 负责 25％的键（每个负责的键不冲突）。在这种情况下，sync. Map 是首选。</p><h3 id=pool>Pool</h3><p><code>sync. Pool</code>是一个并发池，负责安全地保存一组对象。它有两个导出方法：</p><ul><li><code>Get () interface{}</code> 用来从并发池中取出元素。</li><li><code>Put (interface{})</code> 将一个对象加入并发池。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>pool</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>sync</span><span class=p>.</span> <span class=nx>Pool</span><span class=p>{}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=nx>pool</span><span class=p>.</span><span class=nf>Put</span> <span class=p>(</span><span class=nf>NewConnection</span> <span class=p>(</span><span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=nx>pool</span><span class=p>.</span><span class=nf>Put</span> <span class=p>(</span><span class=nf>NewConnection</span> <span class=p>(</span><span class=mi>2</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=nx>pool</span><span class=p>.</span><span class=nf>Put</span> <span class=p>(</span><span class=nf>NewConnection</span> <span class=p>(</span><span class=mi>3</span><span class=p>))</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=nx>connection</span> <span class=o>:=</span> <span class=nx>pool</span><span class=p>.</span><span class=nf>Get</span> <span class=p>().</span> <span class=p>(</span><span class=o>*</span><span class=nx>Connection</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span> <span class=p>(</span><span class=s>&#34;%d\n&#34;</span><span class=p>,</span> <span class=nx>connection</span><span class=p>.</span> <span class=nx>id</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>connection</span> <span class=p>=</span> <span class=nx>pool</span><span class=p>.</span><span class=nf>Get</span> <span class=p>().</span> <span class=p>(</span><span class=o>*</span><span class=nx>Connection</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span> <span class=p>(</span><span class=s>&#34;%d\n&#34;</span><span class=p>,</span> <span class=nx>connection</span><span class=p>.</span> <span class=nx>id</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>connection</span> <span class=p>=</span> <span class=nx>pool</span><span class=p>.</span><span class=nf>Get</span> <span class=p>().</span> <span class=p>(</span><span class=o>*</span><span class=nx>Connection</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span> <span class=p>(</span><span class=s>&#34;%d\n&#34;</span><span class=p>,</span> <span class=nx>connection</span><span class=p>.</span> <span class=nx>id</span><span class=p>)</span>
</span></span></code></pre></div><p>输出</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=mi>2</span>
</span></span></code></pre></div><p>需要注意的是<code>Get ()</code>方法会从并发池中随机取出对象，无法保证以固定的顺序获取并发池中存储的对象。</p><p>还可以为<code>sync. Pool</code>指定一个创建者方法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>pool</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>sync</span><span class=p>.</span> <span class=nx>Pool</span><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>New</span><span class=p>:</span> <span class=kd>func</span> <span class=p>()</span> <span class=kd>interface</span><span class=p>{}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>NewConnection</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>connection</span> <span class=o>:=</span> <span class=nx>pool</span><span class=p>.</span><span class=nf>Get</span> <span class=p>().</span> <span class=p>(</span><span class=o>*</span><span class=nx>Connection</span><span class=p>)</span>
</span></span></code></pre></div><p>这样每次调用 Get () 时，将返回由在 pool. New 中指定的函数创建的对象（在本例中为指针）。</p><p>那么什么时候使用 sync. Pool？有两个用例：</p><p>第一个是当我们必须重用共享的和长期存在的对象（例如，数据库连接）时。</p><p>第二个是用于优化内存分配。</p><p>让我们考虑一个写入缓冲区并将结果持久保存到文件中的函数示例。使用 sync. Pool，我们可以通过在不同的函数调用之间重用同一对象来重用为缓冲区分配的空间。
第一步是检索先前分配的缓冲区（如果是第一个调用，则创建一个缓冲区，但这是抽象的）。然后，defer 操作是将缓冲区放回 sync. Pool 中。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>writeFile</span> <span class=p>(</span><span class=nx>pool</span> <span class=o>*</span><span class=nx>sync</span><span class=p>.</span> <span class=nx>Pool</span><span class=p>,</span> <span class=nx>filename</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>buf</span> <span class=o>:=</span> <span class=nx>pool</span><span class=p>.</span><span class=nf>Get</span> <span class=p>().</span> <span class=p>(</span><span class=o>*</span><span class=nx>bytes</span><span class=p>.</span> <span class=nx>Buffer</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>pool</span><span class=p>.</span><span class=nf>Put</span> <span class=p>(</span><span class=nx>buf</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Reset 缓存区，不然会连接上次调用时保存在缓存区里的字符串 foo
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 编程 foofoo 以此类推
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>buf</span><span class=p>.</span><span class=nf>Reset</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>buf</span><span class=p>.</span><span class=nf>WriteString</span> <span class=p>(</span><span class=s>&#34;foo&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>ioutil</span><span class=p>.</span><span class=nf>WriteFile</span> <span class=p>(</span><span class=nx>filename</span><span class=p>,</span> <span class=nx>buf</span><span class=p>.</span><span class=nf>Bytes</span> <span class=p>(),</span> <span class=mo>0644</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=once>Once</h3><p><code>sync. Once</code>是一个简单而强大的原语，可确保一个函数仅执行一次。在下面的示例中，只有一个<code>goroutine</code>会显示输出消息：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>once</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>sync</span><span class=p>.</span> <span class=nx>Once</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>4</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>i</span> <span class=o>:=</span> <span class=nx>i</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=kd>func</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>once</span><span class=p>.</span><span class=nf>Do</span> <span class=p>(</span><span class=kd>func</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span> <span class=p>(</span><span class=s>&#34;first %d\n&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=p>}()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>使用<code>Do (func ())</code>方法来指定只能被调用一次的部分。</p><h3 id=cond>Cond</h3><p>sync. Cond 可能是 sync 包提供的同步原语中最不常用的一个，它用于发出信号（一对一）或广播信号（一对多）到 goroutine。让我们考虑一个场景，我们必须向一个 goroutine 指示共享切片的第一个元素已更新。创建 sync. Cond 需要 sync. Locker 对象（sync. Mutex 或 sync. RWMutex）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>cond</span> <span class=o>:=</span> <span class=nx>sync</span><span class=p>.</span><span class=nf>NewCond</span> <span class=p>(</span><span class=o>&amp;</span><span class=nx>sync</span><span class=p>.</span> <span class=nx>Mutex</span><span class=p>{})</span>
</span></span></code></pre></div><h2 id=context>context</h2><p>在 Go 语言并发编程中，context 包扮演着至关重要的角色。<strong>Golang context 提供了一种在 goroutine 之间传递信号、截止日期和值的机制，简化了并发程序的管理和错误处理。</strong> context 包在 Go 1.7 版本中引入，主要用于并发控制和超时处理。</p><p><strong>Context，中文译为"上下文"，在 Go 语言中代表 goroutine 的执行环境。</strong> 它可以携带截止日期、取消信号以及其他与请求相关的值，用于控制 goroutine 的生命周期和行为。</p><p>在并发程序中，经常会遇到以下情况：</p><ul><li><strong class=chinese>客户端取消请求</strong>： 例如，用户在浏览器中关闭页面或中断下载。</li><li><strong class=chinese>超时控制</strong>： 防止 goroutine 无限期地阻塞，例如等待网络请求或数据库查询。</li><li><strong>跨 goroutine 传递信息</strong>： 例如，传递请求 ID、用户身份等信息。</li></ul><p>如果没有 Context，处理这些情况会变得非常复杂。 Context 提供了一种优雅而统一的方式来管理这些挑战。</p><p>context 包提供了几个核心方法：</p><ul><li><code>context.Background ()</code>: 创建一个空的 Context，作为所有其他 Context 的根节点。</li><li><code>context.WithCancel (parent Context)</code>: 创建一个可取消的 Context。返回一个新的 Context 和一个取消函数 cancel ()。调用 cancel () 函数会向该 Context 及其子 Context 发送取消信号。</li><li><code>context.WithDeadline (parent Context, deadline time. Time)</code>: 创建一个带有截止日期的 Context。当到达截止日期时，Context 会自动取消。</li><li><code>context.WithTimeout (parent Context, timeout time. Duration)</code>: 创建一个带有超时的 Context。当超时时间到达时，Context 会自动取消。</li><li><code>context.WithValue (parent Context, key, value interface{})</code>: 创建一个携带键值对的 Context。用于在 goroutine 之间传递信息。</li></ul><h3 id=context-的使用场景>Context 的使用场景</h3><ol><li><strong>通过 Context 上下文取消 Goroutine</strong></li></ol><p>使用 context.WithCancel () 创建可取消的 Context，在需要时调用 cancel () 函数取消 goroutine 的执行。</p><p>什么场景下会需要取消 Goroutine？</p><p>HTTP 服务器调用数据库并将查询的数据返回给客户端是一个常见业务场景，但如果客户端在中途取消请求会怎样？例如，如果客户端在请求中途关闭浏览器。此时，我们应该立即取消后续的执行处理，以防止我们的系统做不必要的工作。</p><p>上下文取消有两个方面：一是监听取消事件，二是发出取消事件。</p><p><strong>监听 Context 取消事件</strong>。</p><p><code>Context</code> 类型提供了一个 <code>Done ()</code> 方法。每次上下文收到取消事件时，这个方法都会返回一个接收空 <code>struct{}</code> 类型的 channel。</p><p>因此，要监听取消事件，我们需要等待 <code>&lt;- ctx.Done ()</code>。</p><p>例如，假设一个 HTTP 服务器需要两秒钟来处理一个事件。如果请求在此之前被取消，我们希望立即返回：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 创建一个监听 8000 端口的 HTTP 服务器
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>http</span><span class=p>.</span><span class=nf>ListenAndServe</span> <span class=p>(</span><span class=s>&#34;: 8000&#34;</span><span class=p>,</span> <span class=nx>http</span><span class=p>.</span><span class=nf>HandlerFunc</span> <span class=p>(</span><span class=kd>func</span> <span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span> <span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span> <span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>ctx</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nf>Context</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 这会打印到 STDOUT 以表明处理已经开始
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Fprint</span> <span class=p>(</span><span class=nx>os</span><span class=p>.</span> <span class=nx>Stdout</span><span class=p>,</span> <span class=s>&#34;processing request\n&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 我们使用 select 来处理事件，事件取决于哪个通道先接收到消息
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>time</span><span class=p>.</span><span class=nf>After</span> <span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span> <span class=nx>Second</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 如果我们在 2 秒后收到消息，表示请求已经被处理
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>w</span><span class=p>.</span><span class=nf>Write</span> <span class=p>([]</span><span class=kt>byte</span> <span class=p>(</span><span class=s>&#34;request processed&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>ctx</span><span class=p>.</span><span class=nf>Done</span> <span class=p>():</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 如果请求被取消，将其记录到 STDERR
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Fprint</span> <span class=p>(</span><span class=nx>os</span><span class=p>.</span> <span class=nx>Stderr</span><span class=p>,</span> <span class=s>&#34;request cancelled\n&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>你可以通过运行服务器并在浏览器上打开 <a href=https://localhost:8000/>https://localhost:8000</a> 来对此进行测试。如果你在 2 秒之前关闭浏览器，你应该会在终端窗口上看到“request cancelled”字样。</p><p><strong>发出 Context 取消事件</strong>。</p><p>可以通过上下文发出取消事件完成取消操作，这可以通过使用 context 包中的 <code>WithCancel</code> 函数来完成，它返回一个上下文对象和一个函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>ctx</span><span class=p>,</span> <span class=nx>fn</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithCancel</span> <span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span></code></pre></div><p>返回的这个函数不接受任何参数，也不返回任何内容，当你需要取消上下文时就调用它。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nx>operation</span> <span class=mi>1</span> <span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span> <span class=nx>Context</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 假设这个操作由于某种原因失败了返回 error
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 我们使用 time. Sleep 来模拟资源密集型操作
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span> <span class=p>(</span><span class=mi>100</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span> <span class=nx>Millisecond</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span> <span class=p>(</span><span class=s>&#34;failed&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nx>operation</span> <span class=mi>2</span> <span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span> <span class=nx>Context</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 我们使用与前面示例中看到的 HTTP 服务器类似的模式
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>time</span><span class=p>.</span><span class=nf>After</span> <span class=p>(</span><span class=mi>500</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span> <span class=nx>Millisecond</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;done&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>ctx</span><span class=p>.</span><span class=nf>Done</span> <span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;halted operation 2&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 创建一个新的上下文
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>ctx</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>Background</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 创建一个新的上下文，它的取消函数来自于原来的上下文
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>ctx</span><span class=p>,</span> <span class=nx>cancel</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithCancel</span> <span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 运行两个操作：一个在不同的 goroutine 中
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>go</span> <span class=kd>func</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>err</span> <span class=o>:=</span> <span class=nx>operation</span> <span class=mi>1</span> <span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 如果此操作返回错误，则取消使用此上下文的所有操作
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>cancel</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}()</span>
</span></span><span class=line><span class=cl>    <span class=c1>// operation 2 使用与 operation 1 相同的上下文
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>operation</span> <span class=mi>2</span> <span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><a href=https://go.dev/play/p/ApO5g1MspX9>运行代码</a>，输出结果：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>halted operation <span class=m>2</span>
</span></span></code></pre></div><ol start=2><li><strong>设置 Context 上下文超时</strong></li></ol><p>使用 context.WithTimeout () 为 HTTP 请求或数据库查询设置超时时间，防止 goroutine 无限期地阻塞。</p><p>API 与前面的示例几乎相同，只是增加了一些内容：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 该上下文将在 3 秒后取消
</span></span></span><span class=line><span class=cl><span class=c1>// 如果需要提前取消，可以像前面一样使用&#39; cancel &#39;函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>cancel</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithTimeout</span> <span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=mi>3</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span> <span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 设置上下文 Deadline 与设置超时类似，只是指定了希望上下文取消的具体时间点，而不是指定时长。
</span></span></span><span class=line><span class=cl><span class=c1>// 此处，上下文将在 2009-11-10 23:00:00被取消
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>cancel</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithDeadline</span> <span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Date</span> <span class=p>(</span><span class=mi>2009</span><span class=p>,</span> <span class=nx>time</span><span class=p>.</span> <span class=nx>November</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>23</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>time</span><span class=p>.</span> <span class=nx>UTC</span><span class=p>))</span>
</span></span></code></pre></div><p>例如，对外部的 HTTP API 进行调用时，如果耗时太长，最好提前失败并取消请求：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 创建一个新的上下文
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 截止时间为 100 毫秒
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>ctx</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>Background</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>ctx</span><span class=p>,</span> <span class=nx>cancel</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithTimeout</span> <span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=mi>100</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span> <span class=nx>Millisecond</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nf>cancel</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 发出请求，调用 blog. pi 3. fun 博客主页
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>req</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>http</span><span class=p>.</span><span class=nf>NewRequest</span> <span class=p>(</span><span class=nx>http</span><span class=p>.</span> <span class=nx>MethodGet</span><span class=p>,</span> <span class=s>&#34;https://blog.pi3.fun&#34;</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 将我们刚刚创建的可取消上下文关联到请求
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>req</span> <span class=p>=</span> <span class=nx>req</span><span class=p>.</span><span class=nf>WithContext</span> <span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 创建一个新的 HTTP 客户端并执行请求
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>client</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>http</span><span class=p>.</span> <span class=nx>Client</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=nx>res</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>client</span><span class=p>.</span><span class=nf>Do</span> <span class=p>(</span><span class=nx>req</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 如果请求失败，记录到 STDOUT
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;Request failed: &#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 请求成功打印状态码
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;Response received, status code: &#34;</span><span class=p>,</span> <span class=nx>res</span><span class=p>.</span> <span class=nx>StatusCode</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>根据博客主页对你请求的响应速度，你将收到：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>Response received, status code: <span class=m>200</span>
</span></span></code></pre></div><p>或</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>Request failed: Get https://blog.axiaoxin.com: context deadline exceeded
</span></span></code></pre></div><ol start=3><li><strong>使用 Context 上下文传值</strong></li></ol><p>使用 context.WithValue () 传递请求 ID、用户身份等信息，方便在不同的 goroutine 中访问。</p><p>你可以使用上下文变量来传递通用的值。这是比在所有函数调用中将它们作为变量传递的更惯用方法。</p><p>例如，考虑一个具有多个函数调用的操作，使用一个公共 ID 来标识它以进行日志记录和监控。</p><p>实现这个的最简单的方法是为每个函数调用传递 ID：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 创建一个随机整数作为 ID
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>rand</span><span class=p>.</span><span class=nf>Seed</span> <span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Now</span> <span class=p>().</span> <span class=nf>Unix</span> <span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=nx>id</span> <span class=o>:=</span> <span class=nx>rand</span><span class=p>.</span> <span class=nx>Int</span> <span class=mi>63</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>operation</span> <span class=mi>1</span> <span class=p>(</span><span class=nx>id</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nx>operation</span> <span class=mi>1</span> <span class=p>(</span><span class=nx>id</span> <span class=kt>int</span> <span class=mi>64</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// do some work
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;operation 1 for id: &#34;</span><span class=p>,</span> <span class=nx>id</span><span class=p>,</span> <span class=s>&#34; completed&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>operation</span> <span class=mi>2</span> <span class=p>(</span><span class=nx>id</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nx>operation</span> <span class=mi>2</span> <span class=p>(</span><span class=nx>id</span> <span class=kt>int</span> <span class=mi>64</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// do some work
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;operation 2 for id: &#34;</span><span class=p>,</span> <span class=nx>id</span><span class=p>,</span> <span class=s>&#34; completed&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><a href=https://go.dev/play/p/VJELQkIlK5S>运行代码</a>，输出：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>2009/11/10 23:00:00 operation 1 for id: 767100843235198854  completed
</span></span><span class=line><span class=cl>2009/11/10 23:00:00 operation 2 for id: 767100843235198854  completed
</span></span></code></pre></div><blockquote><p>为什么 Go 的 rand 包中返回一个 64 位整数时称为 <code>Int 63</code>？</p><p><code>Int 63</code> 方法从默认 Source 返回一个非负伪随机 63 位整数作为 int 64。</p><p><code>int 64</code> 是 64 位有符号整数类型。它包含 1 个符号位和 63 个有效位。</p><p>因此任何返回非负 <code>int 64</code> 都会产生 63 位数据（第 64 位，符号位，将始终具有相同的值）。</p></blockquote><p>当你想要传递更多信息时，参数很快就会变得臃肿。</p><p>我们可以使用上下文实现相同的功能：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 我们需要设置一个键来告诉我们数据存储在哪里
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>const</span> <span class=nx>keyID</span> <span class=p>=</span> <span class=s>&#34;id&#34;</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>rand</span><span class=p>.</span><span class=nf>Seed</span> <span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Now</span> <span class=p>().</span> <span class=nf>Unix</span> <span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=nx>ctx</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithValue</span> <span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span> <span class=p>(),</span> <span class=nx>keyID</span><span class=p>,</span> <span class=nx>rand</span><span class=p>.</span> <span class=nx>Int</span> <span class=mi>63</span> <span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=nx>operation</span> <span class=mi>1</span> <span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nx>operation</span> <span class=mi>1</span> <span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span> <span class=nx>Context</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// do some work
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 我们可以通过传入键从上下文中获取值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;operation 1 for id: &#34;</span><span class=p>,</span> <span class=nx>ctx</span><span class=p>.</span><span class=nf>Value</span> <span class=p>(</span><span class=nx>keyID</span><span class=p>),</span> <span class=s>&#34; completed&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>operation</span> <span class=mi>2</span> <span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nx>operation</span> <span class=mi>2</span> <span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span> <span class=nx>Context</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// do some work
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 相同的 ID 从一个函数调用传递到下一个函数调用
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;operation 2 for id: &#34;</span><span class=p>,</span> <span class=nx>ctx</span><span class=p>.</span><span class=nf>Value</span> <span class=p>(</span><span class=nx>keyID</span><span class=p>),</span> <span class=s>&#34; completed&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>使用上下文变量传递信息很有用，原因有很多：</p><ul><li>它是线程安全的：上下文键的值一旦设置就无法修改。为给定键设置另一个值的唯一方法是使用 context. WithValue 创建另一个上下文变量</li><li>它是传统手艺：context 包在整个 Go 的官方库和应用程序中使用，以传递操作范围的数据。其他开发人员和库通常可以很好地使用这种模式。</li></ul><h3 id=注意事项>注意事项</h3><p>使用 <code>WithTimeout</code> 或 <code>WithCancel</code> 包装一个_可取消的上下文_将会使代码中的多个位置可以取消上下文，应该避免这种情况。</p><h3 id=最佳实践>最佳实践</h3><ul><li><strong>Context 应该作为函数的第一个参数传递</strong>：这有助于确保 Context 在整个调用链中可用。</li><li><strong>不要将 Context 存储在结构体中</strong>：Context 应该作为参数传递，而不是存储在结构体中。</li><li><strong>使用 context.Background () 作为根 Context</strong>：所有其他 Context 都应该从 context.Background () 派生。</li><li><strong>不要使用 nil 作为 Context</strong>：如果函数需要 Context，则应始终传递一个有效的 Context。</li><li><strong>使用 context.WithValue () 时要注意键的类型</strong>：使用自定义类型作为键可以避免键冲突。</li><li><strong>避免在<code>context</code>中存储过多数据</strong>：只存储少量、请求范围的数据，如追踪 ID。</li><li><strong>优先使用常量作为 key</strong>：避免 key 冲突，确保代码的可读性。</li><li><strong>及时调用<code>cancel</code>函数</strong>：创建<code>context</code>后应及时调用<code>cancel</code>函数以释放资源。</li><li><strong class=chinese>传递给涉及外部资源的函数</strong>：仅在可能阻塞或长时间运行的操作中使用<code>context</code>。</li></ul><h3 id=常见问题>常见问题</h3><p>在 Golang 中，<code>context</code>包主要用于管理请求的生命周期，特别是在处理并发任务、控制超时和取消操作时，<code>context</code>非常重要。下面整理了开发者在使用<code>context</code>时常见的问题和解答。</p><ol><li>什么是 Golang 中的<code>context</code>，它的主要用途是什么？</li></ol><p><strong>回答：</strong> Golang 中的<code>context</code>包提供了一个<code>Context</code>类型，用于在多个 Go 协程之间传递截止时间、取消信号和请求范围的数据。其主要用途包括：</p><ul><li>控制请求的生命周期（尤其适合 HTTP 请求的处理）。</li><li>管理超时、取消操作，避免资源泄露。</li><li>在 API 之间传递请求范围的元数据，如身份验证信息、追踪 ID 等。</li></ul><p>2. <code>context</code>是如何避免 Goroutine 泄露的？</p><p><strong>回答：</strong> <code>context</code>通过在请求结束或超时时自动触发取消信号，从而终止所有使用该上下文的 Goroutine，避免了资源泄露。例如，在数据库查询或 API 请求中设置<code>context</code>，当请求超时或用户取消时，相关的协程也会随之终止。</p><ol start=3><li>如何创建一个带超时的<code>context</code>？</li></ol><p><strong>回答：</strong> 可以使用<code>context. WithTimeout</code>函数来创建一个带超时的上下文。例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>ctx</span><span class=p>,</span> <span class=nx>cancel</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithTimeout</span> <span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span> <span class=p>(),</span> <span class=mi>5</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span> <span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>defer</span> <span class=nf>cancel</span> <span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1>// 使用 ctx 来控制请求，5 秒后自动取消
</span></span></span></code></pre></div><p>在此例中，<code>ctx</code>将在 5 秒后自动取消，因此适用于一些耗时较长且需要控制的操作。</p><p>4. <code>context.Background ()</code>和<code>context.TODO ()</code>有什么区别？</p><p><strong>回答：</strong></p><ul><li><code>context.Background ()</code>：通常作为根<code>context</code>使用，用于整个应用的初始化和顶层的请求处理。</li><li><code>context.TODO ()</code>：多用于代码的占位符，表示开发者尚未确定具体的上下文或未来将添加适当的上下文。</li></ul><ol start=5><li>该如何选择<code>context. WithCancel</code>、<code>context. WithTimeout</code>和<code>context. WithDeadline</code>？</li></ol><p><strong>回答：</strong></p><ul><li><code>context. WithCancel</code>：适用于可以手动取消的操作，通常与 API 或服务请求协作，取消请求会传播到所有子<code>context</code>。</li><li><code>context. WithTimeout</code>：适合需要在一定时间内完成的任务，会在超时后自动取消。</li><li><code>context. WithDeadline</code>：设置一个具体的截止时间点，当时间到达后自动取消上下文，适合任务有精确截止时间的情况。</li></ul><ol start=6><li>在并发编程中如何使用<code>context</code>传递数据？</li></ol><p><strong>回答：</strong> <code>context</code>并不是为传递数据设计的，而是用来控制取消信号和超时。因此，<code>context</code>应仅用于传递少量、请求范围内的数据（如请求 ID），避免将大量数据放在<code>context</code>中。可以使用<code>context. WithValue</code>传递特定的值，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>ctx</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithValue</span> <span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span> <span class=p>(),</span> <span class=s>&#34;userID&#34;</span><span class=p>,</span> <span class=mi>1234</span><span class=p>)</span>
</span></span></code></pre></div><p>应避免频繁使用<code>context. WithValue</code>传递复杂数据，因为这会降低代码的可读性。</p><p>7. <code>context</code>在多线程环境中是否安全？</p><p><strong>回答：</strong> 是的，<code>context</code>是线程安全的。多个 Goroutine 可以安全地共享和传递同一个<code>context</code>。它的只读特性保证了在并发情况下不会发生竞态条件。</p><p>8. <code>context</code>是否支持嵌套？</p><p><strong>回答：</strong> 支持。一个<code>context</code>可以衍生出多个子<code>context</code>，子<code>context</code>会继承父<code>context</code>的取消、超时和截止日期。嵌套结构的设计使得可以在不同的协程中控制上下文的生命周期。例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>parentCtx</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>Background</span> <span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nx>childCtx</span><span class=p>,</span> <span class=nx>cancel</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithCancel</span> <span class=p>(</span><span class=nx>parentCtx</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>defer</span> <span class=nf>cancel</span> <span class=p>()</span>
</span></span></code></pre></div><p>在这个例子中，<code>childCtx</code>继承了<code>parentCtx</code>的属性。</p><ol start=9><li>如何从<code>context</code>中提取数据？</li></ol><p><strong>回答：</strong> 可以使用<code>ctx.Value (key)</code>提取数据，其中<code>key</code>可以是任意类型的值。需要注意的是，不建议将<code>context</code>当作全局变量或全局状态来使用，只应传递少量与请求相关的数据。例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>userID</span> <span class=o>:=</span> <span class=nx>ctx</span><span class=p>.</span><span class=nf>Value</span> <span class=p>(</span><span class=s>&#34;userID&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>如果<code>key</code>不存在，返回的值将为<code>nil</code>。</p><p>10. <code>context</code>是否应该传递到每一个函数？</p><p><strong>回答：</strong> 不一定。对于简单的函数或不涉及外部资源的函数，不需要传递<code>context</code>。<code>context</code>更适合传递给涉及外部资源（如数据库、网络请求等）的函数中，以便在需要时可以控制超时或取消操作。</p><ol start=11><li>如何检测一个<code>context</code>是否被取消？</li></ol><p><strong>回答：</strong> 使用 <code>context.Done ()</code> 通道可以检测是否取消。如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=o>&lt;-</span><span class=nx>ctx</span><span class=p>.</span><span class=nf>Done</span> <span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;Context cancelled&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;Context active&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>当<code>Done ()</code>通道被关闭时表示<code>context</code>已取消或超时，Goroutine 可以安全退出。</p><h2 id=errors>errors</h2><p>errors 包实现了创建错误值的函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>New</span> <span class=p>(</span><span class=nx>text</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span>
</span></span></code></pre></div><p>使用字符串创建一个错误, 请类比 fmt 包的 Errorf 方法，差不多可以认为是 New (fmt. Sprintf (&mldr;))。</p><p>Example</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>err</span> <span class=o>:=</span> <span class=nx>errors</span><span class=p>.</span> <span class=nf>New</span> <span class=p>(</span><span class=s>&#34;emit macho dwarf: elf header corrupted&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span> <span class=nf>Print</span> <span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Output:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>emit macho dwarf: elf header corrupted
</span></span></code></pre></div><p>Example (Errorf)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>const</span> <span class=nx>name</span><span class=p>,</span> <span class=nx>id</span> <span class=p>=</span> <span class=s>&#34;bimmler&#34;</span><span class=p>,</span> <span class=mi>17</span>
</span></span><span class=line><span class=cl><span class=nx>err</span> <span class=o>:=</span> <span class=nx>fmt</span><span class=p>.</span> <span class=nf>Errorf</span> <span class=p>(</span><span class=s>&#34;user %q (id %d) not found&#34;</span><span class=p>,</span> <span class=nx>name</span><span class=p>,</span> <span class=nx>id</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span> <span class=nf>Print</span> <span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Output:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>user</span> <span class=s>&#34;bimmler&#34;</span> <span class=p>(</span><span class=nx>id</span> <span class=mi>17</span><span class=p>)</span> <span class=nx>not</span> <span class=nx>found</span>
</span></span></code></pre></div><h2 id=log>log</h2><p>log 包实现了简单的日志服务。本包定义了 Logger 类型，该类型提供了一些格式化输出的方法。本包也提供了一个预定义的“标准”Logger，可以通过辅助函数<code>Print[f|ln]</code>、<code>Fatal[f|ln]</code>和<code>Panic[f|ln]</code>访问，比手工创建一个 Logger 对象更容易使用。Logger 会打印每条日志信息的日期、时间，默认输出到标准错误。Fatal 系列函数会在写入日志信息后调用<code>os.Exit (1)</code>。Panic 系列函数会在写入日志信息后 panic。</p><p>log 包的基本使用方法非常简单，主要通过以下几个函数来实现日志记录：</p><ul><li>log.Print ()</li><li>log.Printf ()</li><li>log.Println ()</li><li>log.Fatal ()</li><li>log.Fatalf ()</li><li>log.Fatalln ()</li><li>log.Panic ()</li><li>log.Panicf ()</li><li>log.Panicln ()</li></ul><p>这些函数分别提供了不同的日志记录方式，满足不同的需求。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>log</span><span class=p>.</span><span class=nf>Print</span> <span class=p>(</span><span class=s>&#34;This is a log message&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span> <span class=p>(</span><span class=s>&#34;This is a formatted log message: %d&#34;</span><span class=p>,</span> <span class=mi>42</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>log</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;This is a log message with a newline&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Fatal functions
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span> <span class=p>(</span><span class=s>&#34;This is a fatal log message&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>log</span><span class=p>.</span><span class=nf>Fatalf</span> <span class=p>(</span><span class=s>&#34;This is a formatted fatal log message: %d&#34;</span><span class=p>,</span> <span class=mi>42</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>log</span><span class=p>.</span><span class=nf>Fatalln</span> <span class=p>(</span><span class=s>&#34;This is a fatal log message with a newline&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Panic functions
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>log</span><span class=p>.</span><span class=nf>Panic</span> <span class=p>(</span><span class=s>&#34;This is a panic log message&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>log</span><span class=p>.</span><span class=nf>Panicf</span> <span class=p>(</span><span class=s>&#34;This is a formatted panic log message: %d&#34;</span><span class=p>,</span> <span class=mi>42</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>log</span><span class=p>.</span><span class=nf>Panicln</span> <span class=p>(</span><span class=s>&#34;This is a panic log message with a newline&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>默认情况下，<code>log</code>包的日志输出位置是标准错误输出（stderr）。我们可以通过<code>log.SetOutput ()</code>函数将日志输出重定向到其他位置，例如文件或自定义的日志处理器。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>file</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>OpenFile</span> <span class=p>(</span><span class=s>&#34;app. log&#34;</span><span class=p>,</span> <span class=nx>os</span><span class=p>.</span> <span class=nx>O_CREATE</span><span class=p>|</span><span class=nx>os</span><span class=p>.</span> <span class=nx>O_WRONLY</span><span class=p>|</span><span class=nx>os</span><span class=p>.</span> <span class=nx>O_APPEND</span><span class=p>,</span> <span class=mo>0666</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span> <span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>defer</span> <span class=nx>file</span><span class=p>.</span><span class=nf>Close</span> <span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nx>log</span><span class=p>.</span><span class=nf>SetOutput</span> <span class=p>(</span><span class=nx>file</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>log</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;This is a log message written to a file&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>log 包允许我们自定义日志消息的前缀和时间格式，通过 log.SetPrefix () 和 log.SetFlags () 函数实现。常见的时间格式标志包括：</p><ul><li>log. Ldate：日期（2009/01/23）</li><li>log. Ltime：时间（01:23:23）</li><li>log. Lmicroseconds：微秒级时间（01:23:23.123123）</li><li>log. Llongfile：完整文件名和行号</li><li>log. Lshortfile：短文件名和行号</li><li>log. LUTC：使用 UTC 时间</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>log</span><span class=p>.</span><span class=nf>SetPrefix</span> <span class=p>(</span><span class=s>&#34;INFO: &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>log</span><span class=p>.</span><span class=nf>SetFlags</span> <span class=p>(</span><span class=nx>log</span><span class=p>.</span> <span class=nx>Ldate</span> <span class=p>|</span> <span class=nx>log</span><span class=p>.</span> <span class=nx>Ltime</span> <span class=p>|</span> <span class=nx>log</span><span class=p>.</span> <span class=nx>Lshortfile</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>log</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;This is a log message with custom prefix and flags&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>输出</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>INFO: 2024/12/20 21:45:12 main. go:10: This is a log message with custom prefix and flags
</span></span></code></pre></div><p>除了基本功能外，<code>log</code>包还支持更高级的用法，如创建自定义 Logger、设置日志级别等。我们可以通过<code>log.New ()</code>函数创建自定义的 Logger，指定输出位置、前缀和日志格式。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>file</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>OpenFile</span> <span class=p>(</span><span class=s>&#34;custom. log&#34;</span><span class=p>,</span> <span class=nx>os</span><span class=p>.</span> <span class=nx>O_CREATE</span><span class=p>|</span><span class=nx>os</span><span class=p>.</span> <span class=nx>O_WRONLY</span><span class=p>|</span><span class=nx>os</span><span class=p>.</span> <span class=nx>O_APPEND</span><span class=p>,</span> <span class=mo>0666</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span> <span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>file</span><span class=p>.</span><span class=nf>Close</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>customLogger</span> <span class=o>:=</span> <span class=nx>log</span><span class=p>.</span><span class=nf>New</span> <span class=p>(</span><span class=nx>file</span><span class=p>,</span> <span class=s>&#34;CUSTOM: &#34;</span><span class=p>,</span> <span class=nx>log</span><span class=p>.</span> <span class=nx>Ldate</span><span class=p>|</span><span class=nx>log</span><span class=p>.</span> <span class=nx>Ltime</span><span class=p>|</span><span class=nx>log</span><span class=p>.</span> <span class=nx>Lshortfile</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>customLogger</span><span class=p>.</span><span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;This is a message from the custom logger&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>cat .\custom. log
</span></span><span class=line><span class=cl>CUSTOM: 2024/12/20 21:45:49 main. go:16: This is a message from the custom logger
</span></span></code></pre></div><p><code>log</code> 包本身没有内置日志级别管理，虽然我们可以通过封装实现简单的日志级别控制，但是更推荐直接使用 Go 1.21 版本新增的 log/slog 标准库。</p><ul><li><a href=https://cloud.tencent.com/developer/article/2336092>Go 1.21.0 中新增的结构化日志记录标准库 log/slog 详解-腾讯云开发者社区-腾讯云</a></li><li><a href=https://blog.csdn.net/qq_14829643/article/details/139076080>Go：log库的全面指南与使用技巧_go log库-CSDN博客</a></li></ul><h2 id=pathfilepath>path/filepath</h2><p>filepath 包实现了兼容各操作系统的文件路径的实用操作函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Split</span> <span class=p>(</span><span class=nx>path</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>dir</span><span class=p>,</span> <span class=nx>file</span> <span class=kt>string</span><span class=p>)</span>
</span></span></code></pre></div><p>Split 函数将路径从最后一个路径分隔符后面位置分隔为两个部分（dir 和 file）并返回。如果路径中没有路径分隔符，函数返回值 dir 会设为空字符串，file 会设为 path。两个返回值满足 path == dir+file。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Join</span> <span class=p>(</span><span class=nx>elem</span> <span class=o>...</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>string</span>
</span></span></code></pre></div><p>Join 函数可以将任意数量的路径元素放入一个单一路径里，会根据需要添加路径分隔符。结果是经过简化的，所有的空字符串元素会被忽略。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Dir</span> <span class=p>(</span><span class=nx>path</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>string</span>
</span></span></code></pre></div><p>Dir 返回路径除去最后一个路径元素的部分，即该路径最后一个元素所在的目录。在使用 Split 去掉最后一个元素后，会简化路径并去掉末尾的斜杠。如果路径是空字符串，会返回"."；如果路径由 1 到多个路径分隔符后跟 0 到多个非路径分隔符字符组成，会返回单个路径分隔符；其他任何情况下都不会返回以路径分隔符结尾的路径。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Base</span> <span class=p>(</span><span class=nx>path</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>string</span>
</span></span></code></pre></div><p>Base 函数返回路径的最后一个元素。在提取元素前会求掉末尾的路径分隔符。如果路径是""，会返回"."；如果路径是只有一个斜杆构成，会返回单个路径分隔符。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Ext</span> <span class=p>(</span><span class=nx>path</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>string</span>
</span></span></code></pre></div><p>Ext 函数返回 path 文件扩展名。返回值是路径最后一个路径元素的最后一个&rsquo;.&lsquo;起始的后缀（包括&rsquo;.&rsquo;）。如果该元素没有&rsquo;.&lsquo;会返回空字符串。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Clean</span> <span class=p>(</span><span class=nx>path</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>string</span>
</span></span></code></pre></div><p>Clean 函数通过单纯的词法操作返回和 path 代表同一地址的最短路径。</p><p>它会不断的依次应用如下的规则，直到不能再进行任何处理：</p><ol><li>将连续的多个路径分隔符替换为单个路径分隔符</li><li>剔除每一个<code>. </code>路径名元素（代表当前目录）</li><li>剔除每一个路径内的<code>..</code>路径名元素（代表父目录）和它前面的非<code>..</code>路径名元素</li><li>剔除开始一个根路径的<code>..</code>路径名元素，即将路径开始处的"/..&ldquo;替换为&rdquo;/"（假设路径分隔符是&rsquo;/&rsquo;）</li></ol><p>返回的路径只有其代表一个根地址时才以路径分隔符结尾，如 Unix 的"/&ldquo;或 Windows 的 <code>C:\</code>。</p><p>如果处理的结果是空字符串，Clean 会返回&rdquo;."。参见 <a href=http://plan9.bell-labs.com/sys/doc/lexnames.html>http://plan9.bell-labs.com/sys/doc/lexnames.html</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Match</span> <span class=p>(</span><span class=nx>pattern</span><span class=p>,</span> <span class=nx>name</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>matched</span> <span class=kt>bool</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></div><p>匹配路径是否符合模板。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>pattern</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=nx>term</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>term</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=sc>&#39;*&#39;</span>                                  <span class=nx>匹配</span> <span class=mi>0</span> <span class=nx>或多个非路径分隔符的字符</span>
</span></span><span class=line><span class=cl>    <span class=sc>&#39;?&#39;</span>                                  <span class=nx>匹配</span> <span class=mi>1</span> <span class=nx>个非路径分隔符的字符</span>
</span></span><span class=line><span class=cl>    <span class=sc>&#39;[&#39;</span> <span class=p>[</span> <span class=sc>&#39;^&#39;</span> <span class=p>]</span> <span class=p>{</span> <span class=nx>character</span><span class=o>-</span><span class=k>range</span> <span class=p>}</span> <span class=sc>&#39;]&#39;</span>  <span class=nx>字符组</span><span class=err>（</span><span class=nx>必须非空</span><span class=err>）</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span>                                    <span class=nx>匹配字符</span> <span class=nx>c</span><span class=err>（</span><span class=nx>c</span> <span class=o>!=</span> <span class=sc>&#39;*&#39;</span><span class=p>,</span> <span class=sc>&#39;?&#39;</span><span class=p>,</span> <span class=sc>&#39;\\&#39;</span><span class=p>,</span> <span class=sc>&#39;[&#39;</span><span class=err>）</span>
</span></span><span class=line><span class=cl>    <span class=sc>&#39;\\&#39;</span> <span class=nx>c</span>                               <span class=nx>匹配字符</span> <span class=nx>c</span>
</span></span><span class=line><span class=cl><span class=nx>character</span><span class=o>-</span><span class=k>range</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span>           <span class=nx>匹配字符</span> <span class=nx>c</span><span class=err>（</span><span class=nx>c</span> <span class=o>!=</span> <span class=sc>&#39;\\&#39;</span><span class=p>,</span> <span class=sc>&#39;-&#39;</span><span class=p>,</span> <span class=sc>&#39;]&#39;</span><span class=err>）</span>
</span></span><span class=line><span class=cl>    <span class=sc>&#39;\\&#39;</span> <span class=nx>c</span>      <span class=nx>匹配字符</span> <span class=nx>c</span>
</span></span><span class=line><span class=cl>    <span class=nx>lo</span> <span class=sc>&#39;-&#39;</span> <span class=nx>hi</span>   <span class=nx>匹配区间</span><span class=p>[</span><span class=nx>lo</span><span class=p>,</span> <span class=nx>hi</span><span class=p>]</span><span class=nx>内的字符</span>
</span></span></code></pre></div><p>Match 要求匹配整个 name 字符串，而不是它的一部分。只有 pattern 语法错误时，会返回 ErrBadPattern。</p><p>Windows 系统中，不能进行转义：<code>\\</code>被视为路径分隔符。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Walk</span> <span class=p>(</span><span class=nx>root</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>walkFn</span> <span class=nx>WalkFunc</span><span class=p>)</span> <span class=kt>error</span>
</span></span></code></pre></div><p>Walk 函数会遍历 root 指定的目录下的文件树，对每一个该文件树中的目录和文件都会调用 walkFn，包括 root 自身。所有访问文件/目录时遇到的错误都会传递给 walkFn 过滤。文件是按词法顺序遍历的，这让输出更漂亮，但也导致处理非常大的目录时效率会降低。Walk 函数不会遍历文件树中的符号链接（快捷方式）文件包含的路径。</p><h2 id=flag>flag</h2><p>flag 包实现了命令行参数的解析。</p><p>要求：</p><p>使用 flag. String (), Bool (), Int () 等函数注册 flag，下例声明了一个整数 flag，解析结果保存在<code>*int</code> 指针 ip 里：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;flag&#34;</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>ip</span> <span class=p>=</span> <span class=nx>flag</span><span class=p>.</span> <span class=nf>Int</span> <span class=p>(</span><span class=s>&#34;flagname&#34;</span><span class=p>,</span> <span class=mi>1234</span><span class=p>,</span> <span class=s>&#34;help message for flagname&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>如果你喜欢，也可以将 flag 绑定到一个变量，使用 Var 系列函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>flagvar</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>init</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>flag</span><span class=p>.</span> <span class=nf>IntVar</span> <span class=p>(</span><span class=o>&amp;</span><span class=nx>flagvar</span><span class=p>,</span> <span class=s>&#34;flagname&#34;</span><span class=p>,</span> <span class=mi>1234</span><span class=p>,</span> <span class=s>&#34;help message for flagname&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>或者你可以自定义一个用于 flag 的类型（满足 Value 接口）并将该类型用于 flag 解析，如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>flag</span><span class=p>.</span> <span class=nf>Var</span> <span class=p>(</span><span class=o>&amp;</span><span class=nx>flagVal</span><span class=p>,</span> <span class=s>&#34;name&#34;</span><span class=p>,</span> <span class=s>&#34;help message for flagname&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>对这种 flag，默认值就是该变量的初始值。</p><p>在所有 flag 都注册之后，调用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>flag</span><span class=p>.</span> <span class=nf>Parse</span> <span class=p>()</span>
</span></span></code></pre></div><p>来解析命令行参数写入注册的 flag 里。</p><p>解析之后，flag 的值可以直接使用。如果你使用的是 flag 自身，它们是指针；如果你绑定到了某个变量，它们是值。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span> <span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;ip has value &#34;</span><span class=p>,</span> <span class=o>*</span><span class=nx>ip</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span> <span class=nf>Println</span> <span class=p>(</span><span class=s>&#34;flagvar has value &#34;</span><span class=p>,</span> <span class=nx>flagvar</span><span class=p>)</span>
</span></span></code></pre></div><p>解析后，flag 后面的参数可以从 flag. Args () 里获取或用 flag. Arg (i) 单独获取。这些参数的索引为从 0 到 flag. NArg ()-1。</p><p>命令行 flag 语法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=o>-</span><span class=nx>flag</span>
</span></span><span class=line><span class=cl><span class=o>-</span><span class=nx>flag</span><span class=p>=</span><span class=nx>x</span>
</span></span><span class=line><span class=cl><span class=o>-</span><span class=nx>flag</span> <span class=nx>x</span>  <span class=c1>// 只有非 bool 类型的 flag 可以
</span></span></span></code></pre></div><p>可以使用 1 个或 2 个&rsquo;-&lsquo;号，效果是一样的。最后一种格式不能用于 bool 类型的 flag，因为如果有文件名为 0、false 等时, 如下命令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>cmd</span> <span class=o>-</span><span class=nx>x</span> <span class=o>*</span>
</span></span></code></pre></div><p>其含义会改变。你必须使用-flag=false 格式来关闭一个 bool 类型 flag。</p><p>Flag 解析在第一个非 flag 参数（单个"-&ldquo;不是 flag 参数）之前停止，或者在终止符&rdquo;&ndash;&ldquo;之后停止。</p><p>整数 flag 接受 1234、0664、0 x 1234 等类型，也可以是负数。bool 类型 flag 可以是：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>t</span><span class=p>,</span> <span class=nx>f</span><span class=p>,</span> <span class=nx>T</span><span class=p>,</span> <span class=nx>F</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=nx>TRUE</span><span class=p>,</span> <span class=nx>FALSE</span><span class=p>,</span> <span class=nx>True</span><span class=p>,</span> <span class=nx>False</span>
</span></span></code></pre></div><p>时间段 flag 接受任何合法的可提供给 time. ParseDuration 的输入。</p><p>默认的命令行 flag 集被包水平的函数控制。FlagSet 类型允许程序员定义独立的 flag 集，例如实现命令行界面下的子命令。FlagSet 的方法和包水平的函数是非常类似的。</p><p>例子</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>init</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>flag</span><span class=p>.</span><span class=nf>StringVar</span> <span class=p>(</span><span class=o>&amp;</span><span class=nx>UserName</span><span class=p>,</span> <span class=s>&#34;username&#34;</span><span class=p>,</span> <span class=s>&#34;admin&#34;</span><span class=p>,</span> <span class=s>&#34;QREcrypt 用户名&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>flag</span><span class=p>.</span><span class=nf>StringVar</span> <span class=p>(</span><span class=o>&amp;</span><span class=nx>Password</span><span class=p>,</span> <span class=s>&#34;password&#34;</span><span class=p>,</span> <span class=s>&#34;admin&#34;</span><span class=p>,</span> <span class=s>&#34;QREcrypt 主密钥&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>flag</span><span class=p>.</span><span class=nf>StringVar</span> <span class=p>(</span><span class=o>&amp;</span><span class=nx>Port</span><span class=p>,</span> <span class=s>&#34;port&#34;</span><span class=p>,</span> <span class=s>&#34;51122&#34;</span><span class=p>,</span> <span class=s>&#34;服务运行端口&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>flag</span><span class=p>.</span><span class=nf>Parse</span> <span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=err>……</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=slices-maps>slices maps</h2><p>Go 1.18 新增了泛型，Go 1.21 新增了 slices 和 maps 这两个泛型库，其中大多数函数接口都使用了泛型实现。</p><p><a href=https://pkg.go.dev/slices@go1.23.4>slices package - slices - Go Packages</a></p><p><a href=https://pkg.go.dev/maps@go1.23.4>maps package - maps - Go Packages</a></p></article><div class=paginator><a class=link href=https://blog.pi3.fun/post/2024/12/2024-summary/>← prev</a>
<a class=link href=https://blog.pi3.fun/post/2025/01/nanchang-trip/>next →</a></div><div class=comment><div id=tcomment></div><script src=https://registry.npmmirror.com/twikoo/1.6.39/files/dist/twikoo.min.js></script><script async>twikoo.init({envId:"https://twikoo.pi3.fun/.netlify/functions/twikoo",el:"#tcomment",lang:"zh-CN"})</script></div></main><footer id=footer><div><span style=display:flex;align-items:center><span style=margin-right:.5rem>© 2021 - 2025</span><img src=https://cdn.pi3.fun/static/rainbow.gif loading=lazy width=20 alt=rainbow><span style=margin-left:.5rem>By Liu Chao</span></span></div><div class=footnote><span><a href=https://foreverblog.cn/go.html target=_blank><img src=https://img.foreverblog.cn/logo_en_default.png style=width:auto;height:16px></a> |
<a href=https://www.boyouquan.com/planet-shuttle style="font-size:16px;background-image:linear-gradient(to right,#d55b5b,#4d14e6);background-clip:text;color:transparent;target=" _blank"">博友圈·星球穿梭</a><br><a class=link href=/index.xml><span class="iconfont icon-RSS"></span></a> | <a class=link href=https://github.com/Pi3-l22 target=_ blank><span class="iconfont icon-GitHub"></span></a> | <a class=link href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank rel=noopener><span class="iconfont icon-creative-commons-fill"></span></a></span></div><div class=blog-icon></div></footer></div><script>document.addEventListener("DOMContentLoaded",function(){const n=localStorage.getItem("theme")||"light",e=document.querySelector('link[data-theme-style="light"]'),t=document.querySelector('link[data-theme-style="dark"]'),i=window.matchMedia("(prefers-color-scheme: dark)");i.addListener(function(n){if(!localStorage.getItem("theme")){const s=n.matches?"dark":"light";document.documentElement.setAttribute("data-theme",s),localStorage.setItem("theme",s),s==="light"?(e.media="all",t.media="not all"):(e.media="not all",t.media="all");const o=document.querySelector("iframe.giscus-frame");if(o){const e=s==="light"?"light_tritanopia":"dark_tritanopia";o.contentWindow.postMessage({giscus:{setConfig:{theme:e}}},"https://giscus.app")}}}),n==="light"?(e.media="all",t.media="not all"):(e.media="not all",t.media="all");function o(){const e=document.querySelector("iframe.giscus-frame");if(e){const t=n==="light"?"light_tritanopia":"dark_tritanopia";e.contentWindow.postMessage({giscus:{setConfig:{theme:t}}},"https://giscus.app")}else setTimeout(o,1e3)}o();const s=document.querySelector(".theme-toggle");s&&(s.textContent=n==="light"?"黑暗":"明亮",s.addEventListener("click",function(){const o=document.documentElement.getAttribute("data-theme"),n=o==="light"?"dark":"light";document.documentElement.setAttribute("data-theme",n),localStorage.setItem("theme",n),n==="light"?(e.media="all",t.media="not all"):(e.media="not all",t.media="all");const s=document.querySelector("iframe.giscus-frame");if(s){const e=n==="light"?"light_tritanopia":"dark_tritanopia";s.contentWindow.postMessage({giscus:{setConfig:{theme:e}}},"https://giscus.app")}this.textContent=n==="light"?"黑暗":"明亮"}))})</script><script src=https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){confetti({particleCount:150,spread:100})})</script></body></html>