<!DOCTYPE html>
<html lang="zh-cn">

<head>
  <meta charset="UTF-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">

  
  <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests" />

  
  <meta name="author" content="LiuChao">

  
  
  <meta name="description" content="Neovim 配置与学习">
  

  
  <link rel="icon" href="/favicon.ico">

  
  
  <meta name="keywords" content=" study  latex  life  academic ">
  

  
  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css"
  integrity="sha384-KiWOvVjnN8qwAZbuQyWDIbfCLFhLXNETzBQjA/92pIowpC0d2O3nppDGQVgwd2nB" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
  integrity="sha384-0fdwu/T/EQMsQlrHCCHoH10pkPLlKA1jL5dFyUOvB3lfeT2540/2g6YgSi2BL14p" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js"
  integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: '$$', right: '$$', display: true },
        { left: '\\[', right: '\\]', display: true },
        { left: '$', right: '$', display: false },
        { left: '\\(', right: '\\)', display: false }
      ],
      ignoredTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code', 'option'],
      throwOnError: false
    });
  });
</script>


  

  
  <meta property="og:url" content="/post/2024/10/neovim/">
  <meta property="og:site_name" content="Pi3&#39;s Notes">
  <meta property="og:title" content="Neovim 配置与学习">
  <meta property="og:description" content="Neovim 配置与学习">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-10-11T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-10-11T00:00:00+00:00">
    <meta property="article:tag" content="技术">
    <meta property="article:tag" content="Neovim">


  
  <link rel="canonical" href="/post/2024/10/neovim/">

  
  
  
  <meta itemprop="name" content="Neovim 配置与学习">
  <meta itemprop="description" content="Neovim 配置与学习">
  <meta itemprop="datePublished" content="2024-10-11T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-10-11T00:00:00+00:00">
  <meta itemprop="wordCount" content="9822">
  <meta itemprop="keywords" content="技术,Neovim">

  
  <link media="screen" rel="stylesheet" href='/css/common.css'>
  <link media="screen" rel="stylesheet" href='/css/content.css'>

  
  
  <title>Neovim 配置与学习 - Pi3&#39;s Notes</title>
  

  
  

  
<link rel="stylesheet" href='/css/single.css'>

</head>

<body>
  <div id="wrapper">
    <header id="header">
  <h1>
    <a href="/">Pi3&#39;s Notes</a>
  </h1>

  <nav>
    
    <span class="nav-bar-item">
      <a class="link" href="/">主页</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/album/">相册</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/post/">归档</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/about/">关于</a>
    </span>
    
  </nav>
</header>

    
<main id="main" class="post">
  
  
  <h1>Neovim 配置与学习</h1>
  
  <div>
    <b>Keywords: </b>
    
    <a class="link" href='/tags/%E6%8A%80%E6%9C%AF'>#技术</a>
    
    <a class="link" href='/tags/neovim'>#Neovim</a>
    
  </div>
  
  
  
  <details>
    <summary>
      <b>Table of Contents</b>
    </summary>
    <div class="toc"><nav id="TableOfContents">
  <ul>
    <li><a href="#setup">Setup</a>
      <ul>
        <li><a href="#安装-neovim">安装 Neovim</a></li>
        <li><a href="#配置-lazyvim">配置 LazyVim</a></li>
      </ul>
    </li>
    <li><a href="#mode--register">Mode &amp; Register</a>
      <ul>
        <li><a href="#mode-模式">Mode 模式</a></li>
        <li><a href="#register-寄存器">Register 寄存器</a></li>
        <li><a href="#练习题">练习题</a></li>
      </ul>
    </li>
    <li><a href="#philosophy">Philosophy</a>
      <ul>
        <li><a href="#修改的定义">修改的定义</a></li>
        <li><a href="#可重复修改的技巧">可重复修改的技巧</a></li>
        <li><a href="#练习题-1">练习题</a></li>
      </ul>
    </li>
    <li><a href="#plugins">Plugins</a>
      <ul>
        <li><a href="#配置目录">配置目录</a></li>
        <li><a href="#配置插件">配置插件</a></li>
        <li><a href="#卸载插件">卸载插件</a></li>
        <li><a href="#快捷键映射">快捷键映射</a></li>
        <li><a href="#练习题-2">练习题</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
  </details>
  
  
  <article class="content">
    
    <p>视频教程： <a href="https://www.bilibili.com/video/BV1vcWXe4Evf/?spm_id_from=333.788&amp;vd_source=30a68d7597f750b905825950d4412d50">从零开始构建个性化PDE：打造属于你的高效开发环境</a></p>
<p>习题仓库： <a href="https://github.com/zhangddjs/pde-tutorial">zhangddjs/pde-tutorial (github.com)</a></p>
<h2 id="setup">Setup</h2>
<h3 id="安装-neovim">安装 Neovim</h3>
<p><a href="https://neovim.io/">Home - Neovim</a> | <a href="https://github.com/Neovim/Neovim/blob/master/INSTALL.md">Neovim/Neovim (github.com)</a></p>
<p>打开 Neovim 官网或者 GitHub 主页，根据指引下载对应操作系统的最新版。可以下载安装包进行安装，也可以使用命令行进行安装。</p>
<p>安装完成后，将 Neovim 添加进系统的环境变量中。</p>
<p>在命令行中输入 <code>nvim</code> ，出现欢迎界面说明 Neovim 安装成功。</p>
<p><img src="http://cdn.pi3.fun/blog/20241011180326.png" alt="image.png"></p>
<h3 id="配置-lazyvim">配置 LazyVim</h3>
<p>LazyVim 是一个 Neovim 的一键 Setup 方案，它内置了一些基础的插件，配置了人性化的快捷键。同时 LazyVim 也是一个 Neovim 的包管理器，可以快捷方便地管理 Neovim 的各种插件。</p>
<p><a href="https://www.lazyvim.org/">🚀 Getting Started | LazyVim</a> | <a href="https://github.com/LazyVim/LazyVim">LazyVim(github.com)</a></p>
<p>打开 LazyVim 官网或者 GitHub 主页，进行 LazyVim 的安装。</p>
<p>在安装之前，LazyVim 还需要一些依赖配置，如 Neovim、Git、<a href="https://www.nerdfonts.com/">Nerd Font</a> 字符字体、C 语言编译器以及一个支持真颜色的终端等。</p>
<p><img src="http://cdn.pi3.fun/blog/20241011180413.png" alt="image.png"></p>
<p>安装好各种所需要的依赖环境，就可以进行 LazyVim 的安装</p>
<ul>
<li><strong>Linux 环境</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#177500"># required</span>
</span></span><span style="display:flex;"><span>mv ~/.config/nvim<span style="color:#000">{</span>,.bak<span style="color:#000">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#177500"># optional but recommended</span>
</span></span><span style="display:flex;"><span>mv ~/.local/share/nvim<span style="color:#000">{</span>,.bak<span style="color:#000">}</span>
</span></span><span style="display:flex;"><span>mv ~/.local/state/nvim<span style="color:#000">{</span>,.bak<span style="color:#000">}</span>
</span></span><span style="display:flex;"><span>mv ~/.cache/nvim<span style="color:#000">{</span>,.bak<span style="color:#000">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#177500"># Clone the starter</span>
</span></span><span style="display:flex;"><span>git clone https://github.com/LazyVim/starter ~/.config/nvim
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#177500"># Remove the `.git` folder, so you can add it to your own repo later</span>
</span></span><span style="display:flex;"><span>rm -rf ~/.config/nvim/.git
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#177500"># Start Neovim!</span>
</span></span><span style="display:flex;"><span>nvim
</span></span></code></pre></div><ul>
<li><strong>Windows 环境</strong></li>
</ul>
<p>Windows 下 Neovim 的配置文件应该存放在 <code>C:\Users\YOUR_USERNAME\AppData\Local\nvim</code> 中，如果该目录下不存在 <code>nvim</code> 文件夹，新建一个 <code>nvim</code> 文件夹即可。</p>
<p>在 <code>nvim</code> 文件夹中执行克隆仓库命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git clone https://github.com/LazyVim/starter
</span></span></code></pre></div><p>将其中的 <code>lua</code> 文件夹和 <code>init.lua</code> 移到 <code>nvim</code> 根目录中，其余文件删除即可。目录结构为：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>nvim
</span></span><span style="display:flex;"><span>│  init.lua
</span></span><span style="display:flex;"><span>│
</span></span><span style="display:flex;"><span>└─lua
</span></span><span style="display:flex;"><span>    ├─config
</span></span><span style="display:flex;"><span>    │      autocmds.lua
</span></span><span style="display:flex;"><span>    │      keymaps.lua
</span></span><span style="display:flex;"><span>    │      lazy.lua
</span></span><span style="display:flex;"><span>    │      options.lua
</span></span><span style="display:flex;"><span>    │
</span></span><span style="display:flex;"><span>    └─plugins
</span></span><span style="display:flex;"><span>            example.lua
</span></span></code></pre></div><p>重新打开 Neovim 会出现 LazyVim 的初始化界面，在初始化界面会自动下载一些基本插件，等待插件下载完成。如果因为网络问题导致插件下载失败，可以尝试重启 Neovim，或者按下字母 <code>I</code> 重新安装。完成后按 <code>q</code> 来到 LazyVim 的欢迎界面。如果出现图标乱码，请安装 <a href="https://www.nerdfonts.com/">Nerd 字体</a>。</p>
<p><img src="http://cdn.pi3.fun/blog/20241011180442.png" alt="image.png"></p>
<p>输入 <code>:</code> 打开命令行，输入 <code>LazyHealth</code> 检查插件是否工作正常。使用 <code>Ctrl + u / d</code> 可以上下快速浏览。</p>
<p><img src="http://cdn.pi3.fun/blog/20241011180453.png" alt="image.png"></p>
<p>可以看到有一些 <code>ERROR</code> 出现，比如 <code>Grugfar</code> ，这是因为没有安装 <code>live grep</code> ，后续会安装。</p>
<p>为了方便后续在 Windows 环境下使用 Neovim，可以在终端中新建一个 Neovim 配置，方便之后一键打开，也可以设置打开终端默认使用 Neovim。</p>
<p><img src="http://cdn.pi3.fun/blog/20241011180505.png" alt="image.png"></p>
<h2 id="mode--register">Mode &amp; Register</h2>
<blockquote>
<p>Neovim 的四大编辑模式与寄存器</p>
</blockquote>
<h3 id="mode-模式">Mode 模式</h3>
<p>Neovim 共有四大模式：</p>
<ol>
<li><em>Normal Mode</em></li>
<li><em>Insert Mode</em></li>
<li><em>Visual Mode</em></li>
<li><em>Ex Mode</em></li>
</ol>
<p><img src="http://cdn.pi3.fun/blog/20241011180518.png" alt="image.png"></p>
<p>其中 <strong>Normal Mode</strong> 是默认模式，光标为方块状显示在文本区，此时按下 <code>i</code> 等键进入 <strong>Insert Mode</strong>。在 <strong>Insert Mode</strong> 中光标为竖线，界面左下角会显示 <code>Insert</code> 字样。输入完文本后，按下 <code>ESC</code> 键可以返回 <strong>Normal Mode</strong>。</p>
<p>接下来可以按下 <code>v</code> 键进入 <strong>Visual Mode</strong>，等同于在记事本中框选一段文本的模式，此时可针对选中的文本进行删除拷贝等操作，操作完成后会自动返回 <strong>Normal Mode</strong>。</p>
<p>最后，按下 <code>:</code> 键就会进入 Ex Mode，光标会移动到左下角位置，此时可以输入批处理命令或者是保存退出查找替换等操作。</p>
<p><strong>Normal Mode</strong> 提供的关键键和操作很多，我们不需要全部记住。其中最常用的功能包括文档的浏览跳转、复制粘贴、撤销重做等。</p>
<hr>
<p><strong class=chinese>实际操作演示</strong>：</p>
<p>进入命令行使用 <code>nvim mode.md</code> 创建 <code>mode.md</code> 文件，默认打开文件进入 Normal Mode 。</p>
<p>按下 <code>i</code> 键进入 Insert Mode，可以在文本区输入文本。除此之外，还有多种方式从 Normal Mode 进入 Insert Mode，如按下 <code>o</code> 键，在光标下方另起一行进入 Insert Mode，按下 <code>O</code> 键，在光标上方另起一行进入 Insert Mode，可通过 <code>Open</code> 单词首字母辅助记忆。</p>
<p><img src="http://cdn.pi3.fun/blog/20241011180533.png" alt="image.png"></p>
<h4 id="insert-mode-操作">Insert Mode 操作</h4>
<p><strong>Insert Mode 中的常用快捷键</strong>：</p>
<ul>
<li>←↓↑→方向键：控制光标移动</li>
<li><code>Ctrl + ↑←↓→方向键</code> ：快速移动光标，即按单词移动</li>
<li><code>BS</code> 退格键：删除字符</li>
<li><code>Ctrl + w</code> ：删除单词</li>
<li><code>Ctrl + u</code> ：删除光标前的所有当前行的字符</li>
</ul>
<h4 id="normal-mode-操作">Normal Mode 操作</h4>
<p><strong>从 Normal Mode 到 Insert Mode 的主要快捷键</strong>：</p>
<ul>
<li><code>o</code>：在光标<strong class=chinese>下方</strong>另起一行进入 Insert Mode，<code>open</code></li>
<li><code>O</code>：在光标<strong class=chinese>上方</strong>另起一行进入 Insert Mode，<code>open</code></li>
<li><code>a</code>：在光标处字母的<strong class=chinese>右侧</strong>进入 Insert Mode，<code>append</code></li>
<li><code>A</code>：在光标处所在行<strong class=chinese>行尾</strong>进入 Insert Mode，<code>append</code></li>
<li><code>i</code>：在光标处字母的<strong class=chinese>左侧</strong>进入 Insert Mode</li>
<li><code>I</code>：在光标处所在行<strong class=chinese>行首</strong>进入 Insert Mode</li>
</ul>
<p><strong>Normal Mode 中的光标移动快捷键</strong>：</p>
<ul>
<li><code>h j k l</code>：代替方向键实现光标的<strong class=chinese>左下上右</strong>←↓↑→</li>
<li><code>w b</code>：按<strong class=chinese>下一个</strong>和<strong class=chinese>上一个</strong>单词<strong class=chinese>词首</strong>快速移动光标，<code>word before</code></li>
<li><code>e</code>：按<strong class=chinese>下一个</strong>单词<strong class=chinese>词尾</strong>快速移动光标，<code>end</code></li>
<li><code>数字 + 以上三种操作</code>：如向上移动 2 行按 <code>2k</code>，向右移动 5 个单词按 <code>5w</code>，向左移动 10 个字符按 <code>10h</code></li>
<li><code>0</code>：“硬”行首，即光标跳转到<strong>行首第 1 列</strong>，无论第 1 列有无字符</li>
<li><code>^</code>：“软”行首，即光标跳转到<strong class=chinese>行首首字符</strong>，不一定是第 1 列</li>
<li><code>$</code>：光标跳转到<strong class=chinese>行尾</strong></li>
<li><code>f + 字符</code>：对光标<strong class=chinese>后</strong>的所有字符进行查找，有多个字符可使用 <code>, ;</code> 进行<strong class=chinese>前后</strong>光标快速跳转，<code>find</code></li>
<li><code>F + 字符</code>：对光标<strong class=chinese>前</strong>的所有字符进行查找，有多个字符可使用 <code>, ;</code> 进行<strong class=chinese>前后</strong>光标快速跳转，<code>find</code></li>
<li><code>t + 字符 / T + 字符</code>：与 <code>f</code> 功能类似，找到指定字符的前一个字符，<code>till</code></li>
</ul>
<p><strong>Normal Mode 中的复制粘贴快捷键</strong>：</p>
<ul>
<li><code>y + 快捷键</code>：复制字符，根据操作符的不同，复制字符的范围不同，<code>yank</code></li>
<li><code>Y</code>：复制从光标处到所处行末尾的字符</li>
<li><code>yy</code>：复制光标所处当前行的所有字符，可组合数字向下复制多行，如 <code>6yy</code> 向下复制 6 行字符</li>
<li><code>p</code>：在光标所处行的下方新开一行粘贴复制的内容，可组合数字复制多次，如 <code>100p</code> 可粘贴 100 次</li>
<li><code>P</code>：在光标所处行前粘贴复制的内容，可组合数字复制多次，如 <code>100p</code> 可粘贴 100 次</li>
</ul>
<p><strong class=chinese>补充</strong>：Operator-pending Mode 操作符待处理模式。在 Normal Mode 下仅仅按下 <code>y</code> 键是不能进行字符的复制操作，此时只是进入了 Operator-pending Mode 中，想要完成复制操作，还需要按下其他有效按键，<code>y + ? = combo</code>。</p>
<p>Operator-pending Mode 操作符待处理模式的常用 <code>combo</code> 包括以上介绍的 Insert Mode 中的所有快捷键组合，<code>y + j/k/h/l/w/b/e/f/t/0/^/$/G/gg…… = combo</code></p>
<p>比如：</p>
<ul>
<li><code>y + l</code>：复制光标后的一个字符</li>
<li><code>y + k</code>：复制光标当前行和上一行字符</li>
<li><code>y + w / y + e</code>：复制光标所处位置到单词末尾的字符</li>
<li><code>y + aw / y + iw</code>：复制光标所处位置的单词，<code>iw</code> 不会包含周边的空格，而 <code>aw</code> 会包含单词末尾的空格</li>
<li><code>y + 2w / y + 2e</code>：复制光标所处位置到第 2 个单词末尾的字符</li>
<li><code>y + 2aw / 2y + aw</code>：复制光标所处位置往后的 2 个单词，会包含末尾的空格</li>
<li><code>y + 3j / 4yy</code>：复制包含光标所在行的下方 4 行字符</li>
<li><code>y + 10l</code>：复制光标右侧的 10 个字符</li>
<li><code>y + t + ,</code>：复制光标后方到第一个 <code>,</code> 字符前的所有字符，不包含 <code>,</code></li>
<li><code>y + f + ,</code>：复制光标后方到第一个 <code>,</code> 字符前的所有字符，包含 <code>,</code></li>
<li><code>y + $ / Y</code>：复制从光标处到所处行末尾的字符</li>
</ul>
<p>总结来说，<code>y + 光标移动快捷键</code> 实现光标移动到哪就复制到哪。这种操作模式就是 operator + motion = action 操作符+动作指令=操作，这也是 vim 强大的地方。</p>
<p><strong>Normal Mode 中的阅读浏览快捷键</strong>：</p>
<ul>
<li><code>G</code>：跳转到文本末尾</li>
<li><code>gg</code>：跳转到文本开头</li>
<li><code>行号 + G</code>：跳转到指定行号，可配合 <code>数字 + 方向键hjkl</code> 快速相对跳转</li>
<li><code>Ctrl + u</code>：向上跳转半个屏幕，<code>up</code>，十分接近鼠标滚动效果</li>
<li><code>Ctrl + d</code>：向下跳转半个屏幕，<code>down</code>，十分接近鼠标滚动效果</li>
<li><code>Ctrl + f</code>：向上跳转整个屏幕，<code>font</code></li>
<li><code>Ctrl + b</code>：向下跳转整个屏幕，<code>back</code></li>
</ul>
<p><strong>Normal Mode 中的文本编辑快捷键</strong>：</p>
<ul>
<li><code>d</code>：删除字符 <code>delete</code>，与 <code>y</code> 复制相同，可以和多种光标移动快捷键组成 <code>combo</code>
<ul>
<li><code>d + aw / d + iw</code>：删除光标所处位置的单词，<code>iw</code> 不会包含周边的空格，而 <code>aw</code> 会包含单词末尾的空格</li>
<li><strong>以上所有对于 <code>y</code> 的组合操作都可以用于 <code>d</code></strong></li>
</ul>
</li>
<li><code>D</code>：删除从光标处到所处行末尾的字符</li>
<li><code>dd</code>：删除光标所处当前行的所有字符，可组合数字向下复制多行，如 <code>6dd</code> 向下删除 6 行字符</li>
<li><code>c</code>：修改字符 <code>change</code>，与 <code>d</code> 删除类似，区别在于使用 <code>c</code> 键删除字符后会直接进入 Insert Mode，可少按一次 <code>i</code> 键</li>
<li><code>r</code>：替换当前光标所在的字符， <code>replace</code></li>
<li><code>R</code>：进入替换模式，可以像 Insert Mode 一样编辑文本，但是会替换当前光标所在的字符，<code>replace</code></li>
<li><code>&gt;&gt; / &lt;&lt;</code>：向右缩进或向左缩进，可以在前面加上数字，指定缩进的距离，如 <code>4&gt;&gt;</code> 向右缩进 4 格</li>
<li><code>g + u / g + U</code>：转成为小写或大写字符，与 <code>y</code> 复制相同，可以和多种光标移动快捷键组成 <code>combo</code>
<ul>
<li><code>g + u + aw / g + u + iw</code>：将光标所处位置的单词全部变为小写字符</li>
<li><code>g + U + aw / g + U + iw</code>：将光标所处位置的单词全部变为大写字符</li>
<li><strong>以上所有对于 <code>y</code> 的组合操作都可以用于 <code>gu / gU</code></strong></li>
</ul>
</li>
<li><code>~</code>：切换大小写字符，不能组合 <code>combo</code></li>
<li><code>x</code>：删除光标所处的单个字符</li>
</ul>
<p><strong>Normal Mode 中的撤销重做快捷键</strong>：</p>
<ul>
<li><code>u</code>：撤销之前的操作，<code>undo</code>
<ul>
<li>撤销以每个文本操作为一个单元，比如 <code>d + aw</code>、<code>p</code> 等等</li>
<li>从离开 Normal Mode 到重新进入 Normal Mode 之间的操作也作为一个撤销单元，比如在 Insert Mode 中进行文本编辑的操作</li>
<li>因此，我们可以通过特定的操作来控制撤销的范围，比如在 Insert Mode 中需要换行输入文本，此时使用 <code>Esc</code> 退出 Insert Mode 再利用 <code>o</code> 键新起一行来代替换行操作，可以缩小撤销的范围</li>
</ul>
</li>
<li><code>Ctrl + r</code>：重做之前的撤销操作，<code>redo</code></li>
</ul>
<h4 id="visual-mode-操作">Visual Mode 操作</h4>
<p>在 Normal Mode 中按下 <code>v</code> 键可以进入 Visual Mode。进入之后可以像在 Normal Mode 中一样移动光标或者像 Operator-pending Mode 输入动作指令，从而调整选择范围。调整好选取之后可以之间按下操作符进行文本操作，如<strong>Normal Mode 中的部分文本编辑快捷键</strong>。</p>
<p>除此之外，在 Normal Mode 中还可以按下 <code>V</code> 键进入 V-LINE 模式，即面向行的 Visual Mode。按 <code>Ctrl + v</code> 进入 V-BLOCK 模式，即面向列块的 Visual Mode，确定好选区之后可以按下 <code>i</code> 键，批量给每一行批量添加文本。</p>
<p><strong>Visual Mode 中的常用快捷键</strong>：</p>
<ul>
<li><code>v</code>：从 Normal Mode 进入 Visual Mode</li>
<li><code>V</code>：从 Normal Mode 进入面向行的 Visual Mode，V-LINE 模式</li>
<li><code>Ctrl + v</code>：从 Normal Mode 进入面向列块的 Visual Mode，V-BLOCK 模式</li>
<li><code>o</code>：切换选区的移动端，即选区开头和末尾切换</li>
<li><code>←↓↑→ / hjkl</code>：左下上右移动光标选择选区</li>
<li>常用的文本编辑操作符
<ul>
<li><code>d</code>：删除选区内容</li>
<li><code>c</code>：删除选区内容并进入 Insert Mode</li>
<li><code>y</code>：复制选区内容，操作完成后会返回 Normal Mode，此时按下 <code>g + v</code> 可以返回刚才的选区</li>
<li><code>p</code>：粘贴并覆盖选区内容</li>
</ul>
</li>
<li>……</li>
</ul>
<h4 id="ex-mode-操作">Ex Mode 操作</h4>
<p>在 Normal Mode 中可以按下 <code>:</code> 进入 Ex Mode，然后可以输入命令并按 <code>Enter</code> 执行。</p>
<p>按下 <code>:q</code> 可以打开 Ex 命令历史，在命令历史中，可以像 Normal Mode 中编辑文本一样编辑 Ex 命令。将光标移动到想执行的命令上，按 <code>Enter</code> 可直接执行。</p>
<p>也可以按下 <code>/</code> 或 <code>?</code> 进入 Ex Mode ，调出查找提示符，此时输入任何文本都会进行全文匹配，按下 <code>Enter</code> 开始跳转，按下 <code>n</code> 键跳转到下一个匹配项，按下 <code>N</code> 键跳转到上一个匹配项。</p>
<p><strong>Ex Mode 中的常用命令</strong>：</p>
<ul>
<li><code>:</code>：从 Normal Mode 进入 Ex Mode</li>
<li><code>:q</code>：打开 Ex 命令历史</li>
<li><code>/</code> 或 <code>?</code>：从 Normal Mode 进入 Ex Mode 并调出查找提示符</li>
<li><code>q</code>：退出指令，<code>quit</code></li>
<li><code>q!</code>：强制退出指令</li>
<li><code>w</code>：保存指令，<code>write</code></li>
<li><code>wq</code>：保存并退出</li>
<li>Shell 命令，用 <code>!</code> 开头，以下为 Linux 命令
<ul>
<li><code>!ls</code>：列出当前目录</li>
<li><code>!pwd</code>：列出当前路径</li>
<li><code>%!sort -r</code>：排序操作</li>
<li><code>r!date</code>：打印时间操作</li>
<li><code>r!date &quot;+\%s&quot;</code>：打印时间戳操作</li>
</ul>
</li>
<li>……</li>
</ul>
<h3 id="register-寄存器">Register 寄存器</h3>
<p>寄存器主要用于临时储存剪切和复制的文本，最常用的有：</p>
<ul>
<li>无名寄存器 Unnamed register，用 <code>&quot;</code> 表示</li>
<li>有名寄存器 Named register，用 <code>a - z</code> 表示</li>
<li>复制寄存器 Yank register，用 <code>0</code> 表示</li>
<li>表达式寄存器 Expression register，用 <code>=</code> 表示</li>
</ul>
<p><strong class=chinese>寄存器的规则</strong>：</p>
<p>调用寄存器前需要按下 <code>&quot;</code></p>
<p><strong class=chinese>无名寄存器</strong>：当我们使用 <strong><code>c</code> 修改</strong>或 <strong><code>d</code> 删除</strong>一段内容时，被取缔的内容会自动存放到<strong class=chinese>无名寄存器</strong>中，按下 <code>&quot;</code> 可查看，使用 <code>p</code> 进行粘贴时，会默认粘贴无名寄存器中最新的内容。</p>
<blockquote>
<p>在使用 <code>y</code> 复制一段内容时，复制的内容不仅会存放到<strong class=chinese>无名寄存器</strong>，也会存放在<strong class=chinese>复制寄存器</strong>中</p>
</blockquote>
<p><strong class=chinese>有名寄存器</strong>： <code>a - z</code> 一共 26 个，不会自动存储文本，如果想使用有名寄存器，可以在输入操作符之前加上双引号 <code>&quot;</code> 和 <code>a - z</code> 之一的有名寄存器代号，如 <code>&quot;a + yy</code> 会复制当前行内容并存放到 <code>a</code> 寄存器中，同样按下 <code>&quot;a + p</code> 会将 <code>a</code> 寄存器中的内容粘贴到文本中</p>
<p><strong class=chinese>复制寄存器</strong>：最常用的寄存器是<strong class=chinese>复制寄存器</strong><code>:0</code>，当我们进入 Visual Mode 进行多次粘贴时，会发现第二次粘贴的文本是第一次粘贴时被取缔的文本，原因是第一次粘贴时<strong class=chinese>无名寄存器</strong>中存的是我们最初复制的内容，但粘贴完成后<strong class=chinese>无名寄存器</strong>里的文本也会被覆盖的文本取缔，即 <code>p</code> 粘贴操作也会覆盖无名寄存器，内容为粘贴时被覆盖的文本。这时候我们需要使用 <code>:0</code> 即<strong class=chinese>复制寄存器</strong>，才可以继续粘贴我们复制的文本。</p>
<p><strong class=chinese>表达式寄存器</strong>：进入 Ex Mode，用于简单表达式的计算，或者调用一些函数，如 <code>strftime(&quot;%Y&quot;)</code> 会将年份打印在光标处并进入 Insert Mode。</p>
<blockquote>
<p>在 Insert Mode 下也可以使用寄存器，按下 <code>Ctrl + r + 寄存器符号</code> 即可，如 <code>Ctrl + r + 0</code> 可以粘贴 Normal Mode 下复制的文本，<code>Ctrl + r + =</code> 可唤起表达式寄存器。</p>
</blockquote>
<h3 id="练习题">练习题</h3>
<ul>
<li><a href="../../../../assets/Neovim%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%AD%A6%E4%B9%A0/2modenregister/keynotes_cn.md">总结笔记</a></li>
<li><a href="../../../../assets/Neovim%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%AD%A6%E4%B9%A0/2modenregister/practice_cn.md">练习说明</a></li>
<li><a href="../../../../assets/Neovim%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%AD%A6%E4%B9%A0/2modenregister/text">text</a></li>
<li><a href="../../../../assets/Neovim%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%AD%A6%E4%B9%A0/2modenregister/text2">text2</a></li>
</ul>
<h4 id="习题一">习题一</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#177500"># 克隆仓库</span>
</span></span><span style="display:flex;"><span>git clone https://github.com/zhangddjs/pde-tutorial.git
</span></span><span style="display:flex;"><span><span style="color:#177500"># 切换到习题目录</span>
</span></span><span style="display:flex;"><span><span style="color:#a90d91">cd</span> pde-tutorial/neovim/2modenregister/
</span></span><span style="display:flex;"><span><span style="color:#177500"># 打开练习说明</span>
</span></span><span style="display:flex;"><span>neovim practice_cn.md
</span></span><span style="display:flex;"><span><span style="color:#177500"># 使用垂直分屏</span>
</span></span><span style="display:flex;"><span>:vs
</span></span><span style="display:flex;"><span><span style="color:#177500"># 左右分屏切换</span>
</span></span><span style="display:flex;"><span><span style="color:#c41a16">`</span>Ctrl + h<span style="color:#c41a16">`</span> <span style="color:#c41a16">`</span>Ctrl + l<span style="color:#c41a16">`</span>
</span></span><span style="display:flex;"><span><span style="color:#177500"># 打开text文件</span>
</span></span><span style="display:flex;"><span>:e text
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>1. r + i + n
</span></span><span style="display:flex;"><span>2. diw + 5j + ve + p + 5k + p
</span></span><span style="display:flex;"><span>3. dl + e + p
</span></span><span style="display:flex;"><span>4. r7  /  v + l + c + <span style="color:#1c01ce">8</span>
</span></span><span style="display:flex;"><span>5. gu + iw
</span></span><span style="display:flex;"><span>6. yiw + ve + p
</span></span><span style="display:flex;"><span>7. d3j / 4dd
</span></span><span style="display:flex;"><span>8. line<span style="color:#000">(</span><span style="color:#c41a16">&#39;.&#39;</span><span style="color:#000">)</span> + G + p
</span></span></code></pre></div><p><strong class=chinese>讲解</strong>：</p>
<ol>
<li><code>xp</code> ：使用 <code>x</code> 删除 n，再使用 <code>p</code> 把 n 粘贴到 i 后面</li>
<li><code>dd + 光标移动 + p</code>：使用 <code>dd</code> 删除第 5 行，<code>4j</code> 将光标移动到第 9 行，<code>p</code> 粘贴到第 9 行。再用同样操作将原来第 10 行删除并粘贴到第 5 行。
<ol>
<li>使用 <code>V</code> 进入面向行的 Visual Mode 直接进行替换。</li>
<li>进入 Ex Mode，使用 <code>m10</code> 可以将第 5 行移动到第 10 行，使用 <code>m4</code> 将原先第 10 行移动到第 5 行</li>
</ol>
</li>
<li><code>x + e + p</code>：将开头的 6 删除，将光标移动到词尾并粘贴
<ol>
<li>使用 <code>v + e + d + P</code>，进入 Visual Mode 将 line 字符删除并粘贴到开头</li>
<li>使用 <code>x</code> 删除开头的 6，使用 <code>A</code> 从末尾进入 Insert Mode，按下 <code>Ctrl + r + &quot;</code> 使用无名寄存器粘贴 6 到末尾</li>
</ol>
</li>
<li>第 7 行使用 <code>x</code>：删除 - 号，也可以使用 <code>14 + Ctrl + a</code>，让末尾数字 -7 与 14 相加，得到 7；第 8 行也是类似操作 <code>92 + Ctrl + x</code> 让末尾数字与 92 相减</li>
<li><code>guaw</code>：转化单词变为小写
<ol>
<li>使用 <code>V</code> 进入 Visua Mode，按下 <code>~</code> 整行转化大小写</li>
</ol>
</li>
<li><code>ye + v + iq + &quot;0 + p</code>：复制 line，<code>v</code> 进入 Visual Mode 使用 <code>iq</code> 选择引号中的字符，使用 <code>&quot;0 + p</code> 复制寄存器中的内容粘贴替换，使用 <code>vib</code> 选中括号内的字符，同样使用 <code>&quot;0 + p</code> 复制寄存器中的内容粘贴替换，也可以使用 <code>vi{</code> 和 <code>vi&lt;</code> 来选择指定括号内的字符，使用复制寄存器粘贴</li>
<li><code>V + 3j + d</code>：使用 Visual Mode 选择 4 行并删除
<ol>
<li><code>4dd</code>：在 11 行删除 4 行</li>
<li><code>:11,14d</code>：在 Ex Mode 中使用命令删除</li>
</ol>
</li>
<li><code>G + A + Ctrl + R + = + line('.')</code>：跳转到最后一行从末尾进入 Insert Mode，使用表达式寄存器，使用 <code>line('.')</code> 获取当前行行号并粘贴</li>
</ol>
<h4 id="思考题">思考题</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#177500"># 创建水平分屏</span>
</span></span><span style="display:flex;"><span>:split
</span></span><span style="display:flex;"><span><span style="color:#177500"># 编辑text2</span>
</span></span><span style="display:flex;"><span>e text2
</span></span></code></pre></div><p><strong class=chinese>讲解</strong>：</p>
<p>按照直觉，我们应该进入 Visual Mode 进行批量编辑，但是无论是面向行还是面向列块的 Visual Mode 都不能满足题目要求。<code>Ctrl + v</code> 进入面向列块的模式，选中所有行按下 <code>A</code> 进入 Insert Mode，这时候的光标会按照最长那一行的末尾对齐排列，并不符合要求。</p>
<p>技巧，在 <code>Ctrl + v</code> 进入面向列块的 Visual Mode 中，可以按下 <code>$</code> 指选择的每一行都截止到行尾，此时 <code>A</code> 进入 Insert Mode 输入的字符就会出现在每一行的结尾。</p>
<h2 id="philosophy">Philosophy</h2>
<blockquote>
<p>Neovim 的使用哲学：使修改可重复</p>
<p>Neovim 中的“瑞士军刀” ：<code>.</code> 键的使用</p>
</blockquote>
<p>在平时我们处理文本时经常会遇到一些重复性的工作，例如多次删除/添加相同字符，重复执行相同的操作等，在传统的文本编辑器中，这需要手动重复操作，没有很好的办法，然而在 Neovim 中则提供了一种高效的解决方案—— <code>Dot .</code> 键。</p>
<p>Dot <code>.</code> 键可以重复上一次的操作，成倍提升效率，也使操作更加流畅。</p>
<h3 id="修改的定义">修改的定义</h3>
<p>Dot 键的官方描述是重复上一次<strong class=chinese>修改</strong> <code>Repeat last change</code>，需要注意的是 Neovim 中定义的<strong class=chinese>修改单位</strong>是什么。</p>
<p>正如在 <a href="#Mode%20&amp;%20Register">Mode &amp; Register</a> 中提到的操作符待处理模式 <code>Operator + Motion = Action</code> 的公式，在 <strong>Normal Mode</strong> 下，大部分的文本编辑操作，如 <code>daw yep</code> 等都算作是<strong class=chinese>一次修改</strong>，因此可以使用 Dot <code>.</code> 键进行重复。同样的，每次重复和修改操作都可以用 <code>u</code> 进行撤销。</p>
<p>然而，在 <strong>Insert Mode</strong> 下修改的定义有所不同，只有在<strong>进入 Insert Mode 开始到退出 Insert Mode</strong> 中的所有操作才算作是<strong class=chinese>一次修改</strong>，并且在 Insert Mode 编辑文本的过程中<strong class=chinese>移动了光标</strong>，修改的状态也会被<strong class=chinese>重置</strong>，即只有最后一次<strong class=chinese>光标移动之后</strong>的操作才算作<strong class=chinese>一次修改</strong>。</p>
<p>虽然以上的 Dot 键介绍很简单，在这只是开始。针对同一个文本操作，Neovim 可以通过多种不同的快捷键组合方式来实现，虽然这极具灵活性，但也要求我们在组合快捷键时掌握一些技巧，来充分实现<strong class=chinese>修改的可重复</strong>，真正发挥 Dot 键的威力，这便是 Neovim 的使用哲学</p>
<h3 id="可重复修改的技巧">可重复修改的技巧</h3>
<ol>
<li><strong>技巧 1</strong>：<strong>减少无关移动 <code>Reduce Unnecessary Movements</code></strong></li>
</ol>
<p>回忆上一节的<a href="#%E6%80%9D%E8%80%83%E9%A2%98">思考题</a>，我们需要给不同长短的各行末尾添加 <code>ok</code> 字符。</p>
<p>一种可行的方法是使用 <code>$</code> 到行尾，再按 <code>a</code> 插入 <code>ok</code>，然后使用 <code>j$.</code> 重复操作，但是这种方式仍显低效，因为每行都需要重复按 <code>$</code></p>
<p>但是如果使用的是 <code>A</code> 而不是 <code>$a</code>，就可以将移动操作记录到 <code>.</code> 中，使用 <code>.</code> 就可以重复操作，接下来就可以使用 <code>j.</code> 让每行末尾都添加相同的字符。这是因为 <code>A</code> 同时移动光标并进入 Insert Mode，这并不会重置 Neovim 定义的一次修改操作。</p>
<p>下面是常用<strong class=chinese>可重复快捷键</strong>的替换：</p>
<ul>
<li><code>$a ---&gt; A</code> 行尾插入</li>
<li><code>^i ---&gt; I</code> 行首插入</li>
<li><code>ko ---&gt; O</code> 向上新开一行插入</li>
<li><code>d$a / Da ---&gt; C</code> 删除光标后字符到行尾并插入</li>
<li>……</li>
</ul>
<ol start="2">
<li><strong>技巧 2</strong>：<strong>善用 <code>a</code> 和 <code>i</code>  <code>Use a and i Wisely</code></strong></li>
</ol>
<p>当我们光标在一个单词末尾，想删除这个单词时，可以使用 <code>dbx</code> 或者 <code>bdw</code>，虽然这两种操作都起作用但是却无法使用 <code>.</code> 键重复，因为在 <code>dbx</code> 中实际上有两个修改行为，<code>.</code> 只记录了最后一个 <code>x</code> 的修改行为，按下 <code>.</code> 只能删除单个字符。同样 <code>bdw</code> 中，开头的 <code>b</code> 只是单纯移动了光标，不能算作是一个修改，因此 <code>.</code> 键只记录了 <code>dw</code>，故只能删除单词在光标之后的部分。</p>
<p>为了实现操作的完整可重复性，这里推荐使用 <code>diw</code> 或者 <code>daw</code>，这样不论光标在单词的哪个位置都可以删除整个单词，并且可以使用 <code>.</code> 键重复。</p>
<p>类似的操作还有：</p>
<ul>
<li><code>diq</code>：删除引号内的字符 <code>delete inside quote</code></li>
<li><code>dab</code>： 删除括号周围（包括 <code>()[]{}</code> 括号）的字符 <code>delete around block</code></li>
<li>……</li>
</ul>
<ol start="3">
<li><strong>技巧 3</strong>：<strong>只在必要时使用可视命令 <code>Use Visual Mode Only When Necessary</code></strong></li>
</ol>
<p>我们在删除当前单词时，除了通过 <code>diw / daw</code>，还可以使用 <code>vawd</code>，但是这是使用 <code>.</code> 键在另一个单词上重复操作，效果往往不如预期，这是因为 <code>.</code> 在重复 Visual Mode 中的操作时会按照上次<strong class=chinese>高亮文本的长度</strong>产生作用，因此对不同长度的单词只能删除固定长度的字符。</p>
<blockquote>
<p>因此 <code>.</code> 键只有在处理<strong>面向行的 Visual Mode</strong> 时效果才更加</p>
</blockquote>
<p>所以在一般情况下，能用操作符完成的命令，就避免使用可视模式下的命令，如：</p>
<ul>
<li><code>vawd ---&gt; daw</code>：删除单词</li>
<li><code>viwc ---&gt; ciw</code>：删除单词并进入 Insert Mode</li>
<li><code>viqc ---&gt; ciq</code>：删除引号内的字符并进入 Insert Mode</li>
</ul>
<ol start="4">
<li><strong>技巧 4</strong>：<strong>以退为进 <code>Step Back to Move Forward</code></strong></li>
</ol>
<p>如果我们要给当前行的每个空格前后加上字母 <code>a</code>，进入插入模式后，在坐标插入 <code>a</code> 后避免不了要将光标移动到另一边，光标一旦移动，操作就变得不可重复。</p>
<p>这时可以借助“以退为进”的技巧，进入插入模式后，我们先删除空格，再输入 <code>a a</code>，这样就可以完成一个可重复的操作，接下来只需要 <code>f .;.;.;……</code> 就可以完成后续空格周围添加 <code>a</code> 的操作。</p>
<ol start="5">
<li><strong>技巧 5</strong>：<strong>让移动可重复 <code>Make Movements Repeatable</code></strong></li>
</ol>
<p>回顾前几个技巧可以发现，一个理想的 Dot 操作通常伴随着可重复的移动指令，比如 <code>j.j.j.j.</code> <code>w.w.w.w.</code> <code>;.;.;.;.</code> 等。除此之外，还可以在单词上按下 <code>*</code> 进入单词匹配模式，按下 <code>*</code> 或 <code>n</code> 在相同单词之间跳转，同样可以和 Dot 键组合成 <code>*.*.*.*.</code> 或者 <code>n.n.n.n.</code>。</p>
<p>像以上这种，一次按键用于移动，另一次按键执行的编辑模式，也被称为“<strong>Dot 范式</strong>” <code>. pardigm</code></p>
<h3 id="练习题-1">练习题</h3>
<ul>
<li><a href="../../../../assets/Neovim%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%AD%A6%E4%B9%A0/3philosophy/keynotes_cn.md">总结笔记</a></li>
<li><a href="../../../../assets/Neovim%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%AD%A6%E4%B9%A0/3philosophy/practice_cn.md">练习说明</a></li>
<li><a href="../../../../assets/Neovim%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%AD%A6%E4%B9%A0/3philosophy/text">text</a></li>
</ul>
<p><strong>practice 1</strong>：</p>
<ol>
<li>方法一：使用 <code>Ctrl + v</code> 加上方向键选中日期，按下 <code>3 Ctrl a</code></li>
<li>方法二：使用 Dot 键，在第一行的日期上执行 <code>3 Ctrl a</code> 后，按两次 <code>j.</code></li>
</ol>
<blockquote>
<p><code>3 Ctrl a</code> 是给当前数字加上 3；<code>3 Ctrl x</code> 是给当前数字减去 3</p>
<p>这样的操作在上一节中的练习题也有涉及</p>
</blockquote>
<p><strong>practice 2</strong>：</p>
<ol>
<li>方法一（<strong class=chinese>错误</strong>）：使用 <code>Ctrl v jj $</code> 选中三行末尾，使用 <code>Ctrl R = line('.')</code> 条件表达式寄存器，但是这样三行的行号都是 7，因此不对</li>
<li>方法二（<strong class=chinese>错误</strong>）：在第一行使用 <code>A Ctrl R = line('.')</code> 插入行号后，通过 Dot 键 <code>j.j.</code> 但是依旧是都是 7，效果不理想</li>
<li>方法三：常规方法，只能一行行手动输入行号</li>
</ol>
<p><strong>practice 3</strong>：</p>
<ol>
<li>方法一：以退为进的技巧，使用 <code>f +</code> 搜索加号，<code>a</code> 进入插入模式删除加号，输入 <code>空格+空格</code>，利用 Dot 键 <code>;.;.;.</code></li>
</ol>
<p><strong>practice 4</strong>：</p>
<ol>
<li>方法一：光标在长单词上，使用 <code>ciw</code> 删除单词并进入 Insert Mode ，输入 <code>(</code> 会自动补全右括号，调用无名寄存器并粘贴删除的单词 <code>Ctrl R &quot;</code> ，接着进入 Normal Mode 中使用 Dot 键 <code>*.*.*.</code> 或 <code>n.n.n.</code> 匹配相同的字符串并替换。</li>
</ol>
<p><strong>practice 5</strong>：</p>
<ol>
<li>方法一（<strong class=chinese>错误</strong>）：参考 practice 4 中的方法，使用 <code>ciw</code> 删除单词并进入插入模式，输入左右括号，再调用无名寄存器粘贴单词，最后使用 <code>w</code> 来到下一个单词按下 Dot 键 <code>.</code> 重复操作。这时会发现粘贴的依然是第一个单词，效果并不理想。</li>
<li>方法二：手动添加左右括号</li>
</ol>
<blockquote>
<p>结合 <strong>practice 2 和 5</strong> 的经验，我们发现 <strong>Dot 键</strong>并不会记录 Insert Mode 下的<strong class=chinese>寄存器命令</strong>，只会记录其<strong class=chinese>执行结果</strong></p>
</blockquote>
<p><strong>practice 6</strong>：</p>
<ol>
<li>方法一（<strong class=chinese>错误</strong>）：与上一节中的练习类似。先复制单词 <code>yiw</code>，使用 <code>viq</code> 选中引号内的单词，使用 <code>&quot;0 p</code> ，再使用 <code>w</code> 来下一个单词按下 Dot 键 <code>.</code> 效果并不理想。</li>
</ol>
<blockquote>
<p>这时候回想<a href="#%E5%8F%AF%E9%87%8D%E5%A4%8D%E4%BF%AE%E6%94%B9%E7%9A%84%E6%8A%80%E5%B7%A7">技巧三</a>，只在必要时使用可视模式。这里 Dot 键之所以失效，其实也是使用了 Visual Mode。</p>
</blockquote>
<ol start="2">
<li>方法二：类似于 practice 4。先复制单词 <code>yiw</code>，使用 <code>ciw</code> 删除引号内的单词并进入插入模式，按下 <code>Ctrl R 0</code> 粘贴复制寄存器中的字符，接着使用 <code>wl</code> 等光标移动快捷键（不能使用 Visual Mode 快捷键来选中）移动光标到下一个单词，使用 Dot 键 <code>.</code> 重复操作 <code>Wl.Wl.Wl.Wl.</code></li>
</ol>
<p>综上这些练习题，我们发现虽然 Dot 键十分强大，但是还是有一些局限的情况，正如 practice 2 和 5 以及最后一题的 Visual Mode 情况，我们依旧只能通过手动输入，而 Dot 键并不起作用。</p>
<p>然而，Neovim 还有一个更强大的操作可以用来解决这些常用的固定的而不能很好使用 Dot 键的操作，这就是<strong>宏 Macro</strong>。</p>
<h2 id="plugins">Plugins</h2>
<p>虽然 LazyVim 已经集成了很多使用的插件，但是我们仍然需要掌握 Neovim 的插件配置与使用，来实现插件的灵活管理。</p>
<p>本章节通过<strong class=chinese>文件管理插件</strong>的例子来讲解以下内容：</p>
<ol>
<li><code>leader</code> 键的作用</li>
<li>配置目录的结构</li>
<li>File Explorer 插件的使用</li>
<li>插件控制台</li>
<li>插件更新，回滚，安装，卸载</li>
<li>快捷键映射</li>
</ol>
<h3 id="配置目录">配置目录</h3>
<p>我们在命令行终端输入 <code>nvim</code> 进入 LazyVim 的欢迎界面，可以看到一些菜单项。</p>
<p><img src="http://cdn.pi3.fun/blog/202410241644484.png" alt="image.png"></p>
<p>按下 <code>c</code> 键可以打开 Neovim 的配置文件列表页面。</p>
<p><img src="http://cdn.pi3.fun/blog/202410241644407.png" alt="image.png"></p>
<p>打开入口文件 <code>init.lua</code>，此时就进入了配置文件目录。</p>
<p>我们需要借助文件树来查看和编辑目录下其他配置文件，可以按下 <code>leader</code> 键。<code>leader</code> 键在 Neovim 中是常用的功能键，可以调用<strong>文件树、Git、telescope</strong> 等多种插件提供的功能。</p>
<p><img src="http://cdn.pi3.fun/blog/202410241644991.png" alt="image.png"></p>
<p><code>leader</code> 键默认为<strong class=chinese>空格键</strong>，按下后进入<strong class=chinese>操作符待处理模式</strong>，然后再按 <code>e</code> 键打开文件树（NeoTree 插件）。</p>
<p>此时可以按 <code>?</code> 问号键<strong class=chinese>查看帮助</strong>，通过 <code>j k</code> 上下<strong class=chinese>选择文件</strong>，<code>Enter</code> 回车键<strong class=chinese>查看目录</strong>或者<strong class=chinese>打开文件</strong>，也可以按 <code>s</code> split 键<strong class=chinese>分屏打开文件</strong>。</p>
<p>NeoTree 左上角会显示<strong class=chinese>当前的工作目录</strong>，Linux 中 <code>~/.config/nvim</code> 和 Windows 中 <code>~\AppData\local\nvim</code> 是 Neovim 的<strong class=chinese>默认配置路径</strong>。</p>
<p>在配置目录中，<code>init.lua</code> 是入口文件，Neovim 启动时会首先运行它，加载并初始化 <code>lua</code> 目录下的配置。</p>
<p><code>lua</code> 目录包括两个子目录：<code>config</code> 用于存放<strong class=chinese>通用配置</strong>，比如快捷键映射等；<code>plugins</code> 则专门存放<strong class=chinese>插件相关的配置</strong>。</p>
<p><img src="http://cdn.pi3.fun/blog/202410241644754.png" alt="image.png"></p>
<h3 id="配置插件">配置插件</h3>
<p>了解了基本的配置结构后，我们将开始实践。首先，我们要将 LazyVim 内置的 NeoTree 插件替换成 MiniFiles 插件</p>
<p>首先我们按 <code>空格l</code> leader lazy 打开 LazyVim 的插件控制台，在这里可以查看和管理已经安装的插件。</p>
<p>控制台顶部有按键提示，这些<strong class=chinese>大写按键</strong>的操作都是针对<strong class=chinese>所有插件</strong>的。如果只想单独操作某个<strong class=chinese>指定插件</strong>，可以按对应的<strong class=chinese>小写按键</strong></p>
<p><img src="http://cdn.pi3.fun/blog/202410241645880.png" alt="image.png"></p>
<p>我们 <code>Ctrl d</code> 往下浏览，可以看到许多等待更新的插件，将光标移动到 NeoTree 上
按下 U 键后，NeoTree 的状态就变成 updated 了</p>
<blockquote>
<p>需要注意的是，每个插件的新版本都有可能存在 bug 或冲突，更新后严重的话会导致 Newvim 整个瘫痪，此时就需要回滚。</p>
<p>我们打开 <code>lazy-lock. json</code> 文件，将问题插件的 <code>commit</code> 哈希值改为更新前的，重启 Neovim 后，打开插件控制台，按 <code>r</code> restore 键，就可以将插件恢复到之前的版本。</p>
</blockquote>
<p>我们浏览控制台后会发现 MiniFiles 插件并不在其中，因此需要手动安装。进入 <a href="https://github.com/echasnovski/mini.files">MiniFiles 插件的仓库主页</a>，来到 installation 部分，点开 With folke/lazy. nvim，可以看到两种安装方式，一种是安装 Mini 插件机，一种是单独安装 MiniFiles 插件，我们选择单独安装。</p>
<p><img src="http://cdn.pi3.fun/blog/202410241645501.png" alt="image.png"></p>
<p>将 stable 版本的配置拷贝下来，回到 Neovim 配置目录，在 <code>plugins</code> 下创建 <code>minifiles.lua</code> 文件，粘贴刚才拷贝的配置，并参考 example 的格式，在开头加上 return，即 <code>return { &quot;echasnovski/mini.files&quot;, version = &quot;*&quot; }</code>。</p>
<p><img src="http://cdn.pi3.fun/blog/202410241645405.png" alt="image.png"></p>
<p>然后根据仓库中 important 的要求：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>Important: don&#39;t forget to call ` require(&#39;mini.files&#39;).setup() ` to enable its functionality
</span></span></code></pre></div><p>在 <code>init.lua</code> 文件中加上 <code>require('mini.files').setup()</code>，这样就完成了配置。</p>
<p><img src="http://cdn.pi3.fun/blog/202410241645160.png" alt="image.png"></p>
<p>我们重新打开 Neovim，这时 LazyVim 就会识别到 MiniFiles 的配置，并自动开始安装。安装结束后，我们进入 Ex Mode，输入 <code>:lua MiniFiles.open()</code> 命令，调用 MiniFiles open 方法即可打开 MiniFiles 文件树，这时我们就可以像操作文本一样操作文件树了。</p>
<ul>
<li><code>hjkl</code> 选择文件或进入目录</li>
<li><code>o</code> 键可以另起一行来创建文件或目录</li>
<li>双击 <code>y</code> 键可以复制文件</li>
<li><code>p</code> 键粘贴文件</li>
<li><code>ciw</code> 修改文件名</li>
<li>双击 <code>d</code> 键删除文件</li>
<li><code>q</code> 键退出</li>
<li>……</li>
</ul>
<p>操作完成后，记得按 <code>=</code> 等于号将修改同步到磁盘，接下来我们可以卸载 NeoTree 插件了。</p>
<h3 id="卸载插件">卸载插件</h3>
<p>在 LazyVim 中卸载插件，只需移除该插件相关的<strong class=chinese>配置文件</strong>即可。比如移除 <code>minifiles.md</code> 就可以卸载 MiniFiles 插件。</p>
<p>但由于 NeoTree 是 LazyVim 内置插件，没有相关配置可以移除，这就需要我们在 <code>plugins</code> 目录下，创建 <code>disabled.lua</code> 文件来管理禁用插件，将 NeoTree 插件设置为 <code>enabled = false</code></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#a90d91">return</span> {
</span></span><span style="display:flex;"><span>  { <span style="color:#c41a16">&#34;nvim-neo-tree/neo-tree.nvim&#34;</span>, <span style="color:#000">enabled</span> <span style="color:#000">=</span> <span style="color:#a90d91">false</span> },
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>再重启 Neovim，这时 NeoTree 插件就被禁用了。按下 <code>leader e</code> 也不会唤起文件树，我们再按下 <code>leader l</code> 打开控制台，找到 NeoTree，按插件 clean <code>x</code> 已完成卸载，这时 <code>leader e</code> 键就空闲出来了。</p>
<p><img src="http://cdn.pi3.fun/blog/202410241645957.png" alt="image.png"></p>
<h3 id="快捷键映射">快捷键映射</h3>
<p>我们并不想每次唤起文件树时都进入 Ex Mode，输入一长串命令 <code>:lua MiniFiles.open()</code>，就可以考虑将唤醒命令绑定到 <code>leader e</code> 上。</p>
<p>我们打开 <code>config</code> 目录下的 <code>keymaps.lua</code> 文件，这个文件是专门用于管理<strong class=chinese>快捷键映射</strong>的，可以从顶部注释中的链接里查看<a href="https://github.com/LazyVim/LazyVim/blob/main/lua/lazyvim/config/keymaps.lua">当前 LazyVim 的内置 keymap</a>。</p>
<p><img src="http://cdn.pi3.fun/blog/202410241645692.png" alt="image.png"></p>
<p>我们看到每一条 keymap 配置都是一个 map 方法。该方法共有<strong class=chinese>四个参数</strong>：</p>
<ul>
<li>第一个参数为<strong class=chinese>模式</strong>，首字母 <code>N</code> 代表 <strong>Normal Mode</strong>，<code>I</code> 代表 <strong>Insert Mode</strong></li>
<li>第二个参数代表<strong class=chinese>按键</strong>，普通按键用单个字符表示，特殊按键，比如 <code>Ctrl h</code> 则写作 <code>&lt;C-h&gt;</code></li>
<li>第三个参数代表<strong class=chinese>按键触发的效果</strong>，可以是一串<strong class=chinese>按键序列</strong>，也可以是一个<strong class=chinese>表达式</strong></li>
<li>第四个参数则是一些<strong class=chinese>附加选项</strong>，比如映射的<strong class=chinese>描述信息</strong>等</li>
</ul>
<p>这里要绑定 <code>leader e</code> 键，可以加一个 map。</p>
<ol>
<li>第一个参数填 <code>N</code> ，因为是在 Normal Mode 下触发</li>
<li>第二个参数填按键，也就是尖括号 <code>&lt;leader e&gt;</code></li>
<li>第三个参数填按键序列，即 <code>: lua MiniFiles.open()</code> 代表进入 Ex Mode 并启动 MiniFiles；</li>
<li>第四个参数填描述信息</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#a90d91">local</span> <span style="color:#000">map</span> <span style="color:#000">=</span> <span style="color:#000">vim.keymap</span>.<span style="color:#000">set</span>
</span></span><span style="display:flex;"><span><span style="color:#000">map</span>(<span style="color:#c41a16">&#34;n&#34;</span>, <span style="color:#c41a16">&#34;&lt;leader&gt;e&#34;</span>, <span style="color:#c41a16">&#34;:lua MiniFiles.open()&lt;cr&gt;&#34;</span>, { <span style="color:#000">desc</span> <span style="color:#000">=</span> <span style="color:#c41a16">&#34;Trigger Mini Files&#34;</span> })
</span></span></code></pre></div><p>重启 Neovim，按 <code>leader e</code> 就可以唤起 MiniFiles 文件树了，自此 NeoTree 和 MiniFiles 的替换工作就完成了。</p>
<h3 id="练习题-2">练习题</h3>
<ul>
<li><a href="../../../../assets/Neovim%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%AD%A6%E4%B9%A0/4plugins/keynotes_cn.md">总结笔记</a></li>
<li><a href="../../../../assets/Neovim%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%AD%A6%E4%B9%A0/4plugins/practice_cn.md">练习说明</a></li>
</ul>
    
  </article>
  <div class="paginator">
    
    <a class="link" href="/post/2024/10/%E4%BB%8Egit%E5%8E%86%E5%8F%B2%E4%B8%AD%E5%AE%8C%E5%85%A8%E5%88%A0%E9%99%A4%E6%9F%90%E4%B8%AA%E6%96%87%E4%BB%B6/">← prev</a>
    
    
    <a class="link" href="/post/2024/10/%E5%9C%A8html%E4%B8%AD%E6%8F%92%E5%85%A5pdf/">next →</a>
    
  </div>
  <div class="comment">
    
    
    
    
      <script src="https://giscus.app/client.js"
        data-repo="Pi3-l22/Pi3-l22.github.io"
        data-repo-id="R_kgDOMx7kWw"
        data-category="Announcements"
        data-category-id="DIC_kwDOMx7kW84CjHMe"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="light_tritanopia"
        data-lang="zh-CN"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>

    
    
    
  </div>
  
</main>

    <footer id="footer">
  <div>
    <span style="display: flex;align-items: center;">© 2021 - 2024<img src="https://p.sda1.dev/19/68796ec343c7a7eecbe99de4a9df6c66/rainbow.gif" width=20>By LiuChao</span>
  </div>
  
  

  

  <div class="footnote">
    <span><a class=link href=/index.xml><img src="https://p.sda1.dev/19/1e10e3069ca0e5e1bbc881b6a5fb2732/RSS.png" width=12></a>  |  <a class=link href=https://github.com/Pi3-l22 Target=_ blank><img src="https://p.sda1.dev/19/cfb4a6be80dfeb1851a07d065a83dbcc/GitHub.png" width=40></a>  |  <a class=link href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank rel=noopener><img src="https://p.sda1.dev/19/93838c15ff88af806c9fd7302cced9fa/Cc_by-nc-nd.svg.png" width=48></a>
</span>
  </div>
</footer>

  </div>

  
  

  
  

  
  
  
    
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-WE6L6RF96W"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-WE6L6RF96W');
        }
      </script>
    
  



</body>

</html>
