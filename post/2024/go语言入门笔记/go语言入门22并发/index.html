<!doctype html><html lang=zh-cn><head><script>(function(){const e=localStorage.getItem("theme")||"light";document.documentElement.setAttribute("data-theme",e)})()</script><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=author content="LiuChao"><meta name=description content="Go 语言入门基础学习笔记之 Go 语言的并发"><link rel=icon href=https://blog.pi3.fun/favicon.ico><meta name=keywords content=" study  latex  life  academic "><meta property="og:url" content="https://blog.pi3.fun/post/2024/go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A822%E5%B9%B6%E5%8F%91/"><meta property="og:site_name" content="Pi3's Notes"><meta property="og:title" content="Go语言入门22：并发"><meta property="og:description" content="Go 语言入门基础学习笔记之 Go 语言的并发"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-11-28T00:00:00+00:00"><meta property="article:modified_time" content="2024-11-28T00:00:00+00:00"><meta property="article:tag" content="技术"><meta property="article:tag" content="Golang"><meta property="article:tag" content="Go 入门笔记"><link rel=canonical href=https://blog.pi3.fun/post/2024/go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A822%E5%B9%B6%E5%8F%91/><meta itemprop=name content="Go语言入门22：并发"><meta itemprop=description content="Go 语言入门基础学习笔记之 Go 语言的并发"><meta itemprop=datePublished content="2024-11-28T00:00:00+00:00"><meta itemprop=dateModified content="2024-11-28T00:00:00+00:00"><meta itemprop=wordCount content="5583"><meta itemprop=keywords content="技术,Golang,Go 入门笔记"><link media=screen rel=stylesheet href=https://blog.pi3.fun/css/common.css><link media=screen rel=stylesheet href=https://blog.pi3.fun/css/content.css><link media=screen rel=stylesheet href=https://blog.pi3.fun/css/theme.css><link media=screen rel=stylesheet href=https://blog.pi3.fun/css/iconfont/iconfont.css><link rel=stylesheet href=https://blog.pi3.fun/css/syntax/xcode.css data-theme-style=light media="(prefers-color-scheme: light)"><link rel=stylesheet href=https://blog.pi3.fun/css/syntax/catppuccin-mocha.css data-theme-style=dark media="not all"><title>Go语言入门22：并发 - Pi3's Notes</title>
<link rel=stylesheet href=https://blog.pi3.fun/css/single.css><link href=https://lf3-cdn-tos.bytecdntp.com/cdn/expire-100-y/KaTeX/0.15.2/katex.min.css rel=stylesheet><script defer src=https://lf3-cdn-tos.bytecdntp.com/cdn/expire-100-y/KaTeX/0.15.2/katex.min.js></script><script defer src=https://lf3-cdn-tos.bytecdntp.com/cdn/expire-100-y/KaTeX/0.15.2/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}],ignoredTags:["script","noscript","style","textarea","pre","code","option"],throwOnError:!1})})</script></head><body><div id=wrapper><header id=header><h1><a href=https://blog.pi3.fun/>Pi3's Notes</a></h1><nav><span class=nav-bar-item><a class=link href=/>文章</a>
</span><span class=nav-bar-item><a class=link href=/post/>归档</a>
</span><span class=nav-bar-item><a class=link href=/about/>关于</a>
</span><span class=nav-bar-item><a class=link href=/links/>友链</a>
</span><span class=nav-bar-item><a class="link theme-toggle" href=javascript:void(0);>黑暗</a></span></nav></header><main id=main class=post><h1>Go语言入门22：并发</h1><div><b>Keywords: </b><a class=link href=https://blog.pi3.fun/tags/%E6%8A%80%E6%9C%AF>#技术</a>
<a class=link href=https://blog.pi3.fun/tags/golang>#Golang</a>
<a class=link href=https://blog.pi3.fun/tags/go-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0>#Go 入门笔记</a></div><details><summary><b>Table of Contents</b></summary><div class=toc><nav id=TableOfContents><ul><li><a href=#并发>并发</a><ul><li><a href=#进程线程协程>进程线程协程</a></li><li><a href=#goroutine>goroutine</a></li><li><a href=#通道-channel>通道 Channel</a></li><li><a href=#select-语句>Select 语句</a></li></ul></li></ul></nav></div></details><article class=content><p>Go 语言入门基础学习笔记之 Go 语言的并发</p><p><img src=https://image.pi3.fun/blog/golang.png alt=golang></p><h2 id=并发>并发</h2><p>Go 语言支持并发，通过 <strong>goroutines</strong> 和 <strong>channel</strong>s 提供了一种简洁且高效的方式来实现并发。</p><p>Go 语言的并发性能非常优异，它使用协程而不是线程来并发执行任务，协程比线程占用的内存空间更小，协程的创建、销毁、切换的成本也更低。</p><h3 id=进程线程协程>进程线程协程</h3><p>在早期的单进程时代有两个问题：</p><ol><li>单一执行流程、计算机只能一个任务一个任务处理。</li><li>进程阻塞所带来的 CPU 浪费时间。</li></ol><p><img src=https://image.pi3.fun/blog/202411292249190.png alt=image.png></p><p>那么能不能宏观的执行多个任务？这就出现了多进程/多线程操作系统。使用轮询策略，执行 A 后又执行 B，这时需要判断进程是否执行完成，因此也会有时间片的概念。这事实上就是<strong class=chinese>并发执行</strong>的效果，同一个时刻还是只有一个进程在执行，并不是<strong class=chinese>并行</strong>！</p><p><img src=https://image.pi3.fun/blog/202411292249604.png alt=image.png></p><p>多进程/多线程解决了阻塞的问题，但是又面临了一个新的问题：不停的切换进程所导致的上下文切换的成本增加。进程/线程的数量越多，切换成本就越大，也就越浪费。</p><p><img src=https://image.pi3.fun/blog/202411292249330.png alt=image.png></p><p>与此同时，多线程随着<strong class=chinese>同步竞争</strong>（如锁、竞争资源冲突等）开发设计变得越来越复杂。同时高内存占用也是多线程/多进程开发的壁垒。</p><p><img src=https://image.pi3.fun/blog/202411292250837.png alt=image.png></p><p>所以，工程师又会想：能不能将一个线程一分为二，即用户线程和内核线程，CPU 只能看到内核线程，而用户线程又和内核线程进行绑定，这样就巧妙地解决了 CPU 不断切换进程所带来地消耗。后来，<strong class=chinese>用户线程</strong>又叫做<strong>协程 co-routine</strong>，<strong class=chinese>内核进程</strong>叫做<strong>线程 thread</strong>。</p><p><img src=https://image.pi3.fun/blog/202411292250654.png alt=image.png></p><p>在实际操作中，通过协程调度器来调度每个程序的切换调度，在线程层面则没有切换，整个对于 CPU 来说就是透明的。</p><p><img src=https://image.pi3.fun/blog/202411292250191.png alt=image.png></p><p>这种 1：N 的方式也存在一定的弊端，想象一下当一个协程阻塞时，会耽误下一个程序的执行。如果是 1：1，则又回到了之前的局面，协程的创建、删除和切换的代价都由 CPUI 完成，代价有些昂贵。如果是 N：M 的形式，其决定开销的核心就在于<strong class=chinese>协程调度器</strong>了，因为此时有多个线程和多个协程，怎么切换和调度它们对于程序执行的效率有非常大的影响。</p><p><img src=https://image.pi3.fun/blog/202411292250770.png alt=image.png></p><p>Golang 对协程的处理和改进。它把<strong>协程 co-routine</strong> 改为 <strong>Goroutine</strong>，将内存改小为几 KB 并增强灵活调度，这样就使得 Goroutine 可以大量使用并切换协程。</p><p>在 Go 语言早期的调度器处理中，G 为协程 goroutine、M 为线程 thread。Go 将协程创建成一个队列，要执行一个协程时，先获取一个锁给队列，然后取出一个协程给线程执行，执行完成后再放回队列的队尾。</p><p><img src=https://image.pi3.fun/blog/202411292250094.png alt=image.png></p><p>这种调度器十分简单，但是也有很多弊端：</p><ol><li>创建、销毁、调度 G 都需要每个 M 获取锁，这就形成了激烈的锁竞争。</li><li>M 转移 G 会造成延迟和额外的系统负载。</li><li>系统调用（ CPU 在 M 之间的切换）导致频繁的线程阻塞和取消阻塞操作增加了系统开</li></ol><p>Go 语言优化后的调度器 GMP，其中 G 为协程 goroutine、P 为处理器 processor、M 为线程 thread。</p><p><img src=https://image.pi3.fun/blog/202411292250427.png alt=image.png></p><p>对于 Go 语言调度器的设计策略以下几个方面：</p><ol><li><strong class=chinese>复用线程</strong>：work stealing 机制、hand off 机制</li><li><strong class=chinese>利用并行</strong>：GOMAXPROCS 限定 P 的个数（比如=CPU/2）</li><li><strong class=chinese>抢占</strong>：以前的协程不允许抢占，现在允许抢占</li><li><strong>全局 G 队列</strong>：word stealing 的升级</li></ol><p>所谓 work stealing 机制，就是当一个 G 队列为空时，为了不浪费资源，此调度器会从旁边的队列中“偷取”一个程序进行执行。</p><p><img src=https://image.pi3.fun/blog/202411292250151.png alt=image.png></p><p>所有 hand off 机制，就是当一个协程阻塞时，会唤醒一个新的线程，将整个连同 P 处理器一同迁移到新的线程上执行，并且 CPU 也相应分配，而原先阻塞的协程依旧独占原来的那个线程等待完成。</p><p><img src=https://image.pi3.fun/blog/202411292251866.png alt=image.png></p><p>所谓全局 G 队列，就是 work stealing 机制的升级，当一个线程所对应的队列没有协程时，它会去旁边偷取一个协程，但是如果旁边的队列也没有，那么就是去全局队列中取一个协程执行。但是全局队列需要锁机制，因此优先级和效率较低。</p><h3 id=goroutine>goroutine</h3><p>goroutine 是轻量级线程，goroutine 的调度是由 Golang 运行时进行管理的。</p><p>goroutine 语法格式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>go</span> <span class=nx>函数名</span><span class=p>(</span> <span class=nx>参数列表</span> <span class=p>)</span>
</span></span></code></pre></div><p>比如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>go</span> <span class=nf>f</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span><span class=p>,</span> <span class=nx>z</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// 或者是匿名函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>arg</span> <span class=kt>string</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=c1>// do something
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}(</span><span class=s>&#34;abc&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>Go 允许使用 <code>go</code> 语句开启一个新的运行期线程，即 <strong>goroutine</strong>，以一个不同的、新创建的 goroutine 来执行一个函数。</p><p>同一个程序中的所有 goroutine 共享<strong class=chinese>同一个地址空间</strong>。当多个 goroutine 访问<strong class=chinese>共享资源</strong>时，确保使用<strong class=chinese>互斥锁</strong>（<code>sync.Mutex</code>）或<strong class=chinese>其他同步机制</strong>来防止数据竞争。</p><p>注意，goroutine 的执行不会阻塞主进程的执行，如果主进程先结束，则整个程序退出，此时 goroutine 也许还没执行完。因此需要有操作来等待所有 goroutine 完成，这可以使用 <strong>WaitGroup</strong> 或 <a href=#%E9%80%9A%E9%81%93%E4%BD%BF%E7%94%A8>Channel</a>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>say</span><span class=p>(</span><span class=nx>s</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>5</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>100</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>say</span><span class=p>(</span><span class=s>&#34;world&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>say</span><span class=p>(</span><span class=s>&#34;hello&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 可能的输出结果
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>world</span>
</span></span><span class=line><span class=cl><span class=nx>hello</span>
</span></span><span class=line><span class=cl><span class=nx>world</span>
</span></span><span class=line><span class=cl><span class=nx>hello</span>
</span></span><span class=line><span class=cl><span class=nx>world</span>
</span></span><span class=line><span class=cl><span class=nx>hello</span>
</span></span><span class=line><span class=cl><span class=nx>world</span>
</span></span><span class=line><span class=cl><span class=nx>hello</span>
</span></span><span class=line><span class=cl><span class=nx>world</span>
</span></span><span class=line><span class=cl><span class=nx>hello</span>
</span></span></code></pre></div><p><code>say("hello")</code> 函数并没有使用 <code>go</code> 关键字，因此它应该是以正常的顺序执行，而不是并行执行。然而，实际上程序的输出是并发的，这是因为 goroutine 的调度机制和主线程的执行顺序。</p><p>执行以上代码，你会看到输出的 hello 和 world 是没有固定先后顺序。因为它们是<strong>两个 goroutine 在执行</strong>。由于 <code>time.Sleep(100 * time.Millisecond)</code> 的存在，<code>say("world")</code> 和 <code>say("hello")</code> 的输出会交错。</p><p><strong class=chinese>执行流程</strong>：</p><ol><li><strong class=chinese>主函数启动</strong>：当 <code>main()</code> 函数被调用时，首先执行 <code>go say("world")</code>。这行代码启动了一个新的 goroutine，在这个 goroutine 中，<code>say("world")</code> 开始执行。</li><li><strong class=chinese>主线程执行</strong>：紧接着，主线程执行 <code>say("hello")</code>。由于 <code>say</code> 函数包含一个循环和 <code>time.Sleep(100 * time.Millisecond)</code>，它会依次打印 <code>"hello"</code>，每次打印之间有 100 毫秒的延迟。</li><li><strong class=chinese>并发执行</strong>：因为 <code>go say("world")</code> 是在一个单独的 goroutine 中执行的，所以 <code>"world"</code> 和 <code>"hello"</code> 的输出会交错出现。具体输出的顺序取决于 Go 运行时如何调度这两个 goroutine。</li></ol><hr><p>Go 语言等等一个协程正常结束会比较麻烦，主进程提前结束会直接中断协程的执行，因此需要用到 Channel 通道阻塞等待协程完成。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span> <span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>result</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=nx>ch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>  <span class=c1>// 启动子协程
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Go语言不能获得子协程的返回值，需要利用公共变量来传递结果
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>result</span> <span class=p>=</span> <span class=mi>5</span>  
</span></span><span class=line><span class=cl>        <span class=nx>ch</span> <span class=o>&lt;-</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=p>}()</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;-</span><span class=nx>ch</span> <span class=c1>// 阻塞等待协程发生true完成的信号，才会解除阻塞
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><blockquote><p>如果我们想直接中断某个 goroutine，可以使用 <code>runtime.Goexit()</code> 直接退出当前的 goroutine。</p></blockquote><h3 id=通道-channel>通道 Channel</h3><h4 id=通道定义>通道定义</h4><p><strong class=chinese>通道</strong>（channel）是用来传递数据的一个数据结构，也是一个引用数据类型。它引用的是一个环形队列，队列意为着先进先出。</p><p>通道可用于两个 goroutine 之间通过传递一个指定类型的值来<strong class=chinese>同步</strong>运行和通讯。</p><p>使用 <code>make</code> 函数创建一个 channel，使用 <code>&lt;-</code> 操作符发送和接收数据。如果未指定方向，则为双向通道。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>ch</span> <span class=o>&lt;-</span> <span class=nx>v</span>    <span class=c1>// 把 v 发送到通道 ch
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>&lt;-</span> <span class=nx>ch</span>      <span class=c1>// 接收并丢弃
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>v</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>ch</span>  <span class=c1>// 从 ch 接收数据 并把值赋给 v
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>v</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=o>&lt;-</span> <span class=nx>ch</span> <span class=c1>// 同时检查通道是否已经关闭或者是否为空
</span></span></span></code></pre></div><p><code>ch &lt;- v </code>如果这个队列满了，会一直阻塞直到元素被取走。 <code>v := &lt;-ch</code> 如果这个队列里的元素被取空了，则会一直阻塞，直到有元素进来。</p><p>声明一个通道很简单，我们使用 <code>chan</code> 关键字即可，通道在使用前必须先创建：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>ch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span>
</span></span></code></pre></div><h4 id=通道使用>通道使用</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 定义一个channel
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>c</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;goroutine 结束...&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;goroutine 正在运行...&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>c</span> <span class=o>&lt;-</span> <span class=mi>666</span> <span class=c1>// 将666发送给c
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>num</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>c</span> <span class=c1>// 从c中接收数据并赋值给num
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;num = &#34;</span><span class=p>,</span> <span class=nx>num</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;main goroutine 结束...&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 输出结果
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>goroutine</span> <span class=nx>正在运行</span><span class=o>...</span>
</span></span><span class=line><span class=cl><span class=nx>goroutine</span> <span class=nx>结束</span><span class=o>...</span>
</span></span><span class=line><span class=cl><span class=nx>num</span> <span class=p>=</span> <span class=mi>666</span>
</span></span><span class=line><span class=cl><span class=nx>main</span> <span class=nx>goroutine</span> <span class=nx>结束</span><span class=o>...</span>
</span></span></code></pre></div><p>按理说 goroutine 结束时间与 main 结束的时间是随机的，但是我们经过多次测试发现 <code>main goroutine 结束...</code> 这段话的打印总是在最后，这是为什么？这就归功于 channel 的阻塞功能，导致它能够同步两个进程之间的顺序。</p><p><img src=https://image.pi3.fun/blog/202411292252760.png alt=image.png></p><p>当 main 函数已经到了接收 channel 信息的步骤，而信息还未被子进程传递时，它会阻塞等待，直到接受到传递的参数。相似的，如果子进程先到了传递信息的步骤，而主进程还没有到，因为这个管道是<strong class=chinese>无缓冲</strong>的，因此它也会被阻塞，直到 main 来接收信息。因此 main 函数的结束一定是在最后的。这也就是为什么 channel 可以解决主进程先结束导致协程未完成的问题。</p><blockquote><p>goroutine 的函数常常要配合 <a href=#defer>defer</a> 关键字来标识协程的退出。</p></blockquote><p><strong class=chinese>注意</strong>：默认情况下，通道是<strong class=chinese>不带缓冲区</strong>的。发送端发送数据，<strong class=chinese>同时</strong>必须有接收端相应的接收数据。</p><p>以下实例通过两个 goroutine 来计算数字之和，在 goroutine 完成计算后，它会计算两个结果的和：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// sum 函数计算切片 s 的总和，并将结果发送到通道 c
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>sum</span><span class=p>(</span><span class=nx>s</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>c</span> <span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>sum</span> <span class=o>:=</span> <span class=mi>0</span> <span class=c1>// 初始化 sum 变量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>s</span> <span class=p>{</span> <span class=c1>// 遍历切片 s
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>sum</span> <span class=o>+=</span> <span class=nx>v</span> <span class=c1>// 累加切片中的每个元素
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span> <span class=o>&lt;-</span> <span class=nx>sum</span> <span class=c1>// 把计算得到的 sum 发送到通道 c
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 定义一个整数切片 s
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>s</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>7</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=o>-</span><span class=mi>9</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>0</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 创建一个整型通道 c
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>c</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 启动两个 goroutine，分别计算切片 s 的前半部分和后半部分的总和
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>go</span> <span class=nf>sum</span><span class=p>(</span><span class=nx>s</span><span class=p>[:</span><span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span><span class=o>/</span><span class=mi>2</span><span class=p>],</span> <span class=nx>c</span><span class=p>)</span> <span class=c1>// 计算切片前半部分 [7, 2, 8]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>go</span> <span class=nf>sum</span><span class=p>(</span><span class=nx>s</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span><span class=o>/</span><span class=mi>2</span><span class=p>:],</span> <span class=nx>c</span><span class=p>)</span> <span class=c1>// 计算切片后半部分 [-9, 4, 0]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 从通道 c 中接收两个结果
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>x</span><span class=p>,</span> <span class=nx>y</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>c</span><span class=p>,</span> <span class=o>&lt;-</span><span class=nx>c</span> <span class=c1>// 从通道 c 中接收两个 sum 结果
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span><span class=p>,</span> <span class=nx>x</span><span class=o>+</span><span class=nx>y</span><span class=p>)</span> <span class=c1>// 打印两个部分的总和和它们的总和
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 输出结果
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>-</span><span class=mi>5</span> <span class=mi>17</span> <span class=mi>12</span>
</span></span></code></pre></div><h4 id=通道缓存区>通道缓存区</h4><p><strong class=chinese>无缓冲的通道</strong>：</p><p><img src=https://image.pi3.fun/blog/202411292252871.png alt=image.png></p><ol><li>在第 1 步，两个 goroutine 都到达通道，但哪个都没有开始执⾏发送或者接收。</li><li>在第 2 步，左侧的 goroutine 将它的手伸进了了通道，这模拟了向通道发送数据的⾏为。这时，这个 goroutine 会在通道中被锁住，直到交换完成。</li><li>在第 3 步，右侧的 goroutine 将它的手放⼊=入通道，这模拟了了从通道⾥接收数据。这个 goroutine 一样也会在通道中被锁住，直到交换完成。</li><li>在第 4 步和第 5 步，进⾏交换，并最终，在第 6 步，两个 goroutine 都将它们的手从通道里拿出来，这模拟了了被锁住的 goroutine 得到释放。两个 goroutine 现在都可以去做其他事情了了。</li></ol><p>无缓冲的通道的特点：</p><ul><li>接收者，未接收到数据会被阻塞</li><li>发送者，没有人接收数据也会被阻塞</li></ul><p><strong class=chinese>有缓冲的通道</strong>：</p><p><img src=https://image.pi3.fun/blog/202411292252190.png alt=image.png></p><ol><li>在第 1 步，右侧的 goroutine 正在从通道接收一个值。</li><li>在第 2 步，右侧的这个 goroutine 独⽴完成了接收值的动作，而左侧的 goroutine 正在发送一个新值到通道⾥。</li><li>在第 3 步，左侧的 goroutine 还在向通道发送新值，⽽而右侧的 goroutine 正在从通道接收另外一个值。这个步骤⾥的两个操作既不是同步的，也不会互相阻塞。</li><li>最后，在第 4 步，所有的发送和接收都完成，而通道⾥还有几个值，也有一些空间可以存更多的值。</li></ol><p>有缓冲的通道的特点：</p><ul><li>当 channel 已经满，再向⾥⾯写数据，就会阻塞</li><li>当 channel 为空，从⾥面取数据也会阻塞</li></ul><hr><p>通道可以设置缓冲区（队列容量），通过 make 的<strong class=chinese>第二个参数</strong>指定缓冲区大小：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>ch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>,</span> <span class=mi>100</span><span class=p>)</span>
</span></span></code></pre></div><p>带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于<strong class=chinese>异步</strong>状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。</p><p>不过由于缓冲区的大小是<strong class=chinese>有限的</strong>，所以还是必须有接收端来接收数据的，否则缓冲区一满，数据发送端就无法再发送数据了。</p><p><strong class=chinese>注意</strong>：如果通道<strong class=chinese>不带缓冲</strong>，发送方会<strong class=chinese>阻塞</strong>直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区<strong class=chinese>已满</strong>，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直<strong class=chinese>阻塞</strong>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span> <span class=c1>// 带有缓冲的channel
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;len(c) = &#34;</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>c</span><span class=p>),</span> <span class=s>&#34;, cap(c)&#34;</span><span class=p>,</span> <span class=nb>cap</span><span class=p>(</span><span class=nx>c</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;子go程序结束&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>4</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>c</span> <span class=o>&lt;-</span> <span class=nx>i</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;&#39;子go程序正在运行&#39;, 发送的元素=&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>,</span> <span class=s>&#34; len(c)=&#34;</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>c</span><span class=p>),</span> <span class=s>&#34;cap(c)=&#34;</span><span class=p>,</span> <span class=nb>cap</span><span class=p>(</span><span class=nx>c</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>4</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>num</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>c</span> <span class=c1>// 从channel中接收数据并赋值
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;num = &#34;</span><span class=p>,</span> <span class=nx>num</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;main 结束&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 可能输出结果
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>len</span><span class=p>(</span><span class=nx>c</span><span class=p>)</span> <span class=p>=</span>  <span class=mi>0</span> <span class=p>,</span> <span class=nb>cap</span><span class=p>(</span><span class=nx>c</span><span class=p>)</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=err>&#39;</span><span class=nx>子go程序在运行</span><span class=err>&#39;</span><span class=p>,</span> <span class=nx>发送的元素</span><span class=p>=</span> <span class=mi>0</span>  <span class=nb>len</span><span class=p>(</span><span class=nx>c</span><span class=p>)=</span> <span class=mi>1</span> <span class=nb>cap</span><span class=p>(</span><span class=nx>c</span><span class=p>)=</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=err>&#39;</span><span class=nx>子go程序在运行</span><span class=err>&#39;</span><span class=p>,</span> <span class=nx>发送的元素</span><span class=p>=</span> <span class=mi>1</span>  <span class=nb>len</span><span class=p>(</span><span class=nx>c</span><span class=p>)=</span> <span class=mi>2</span> <span class=nb>cap</span><span class=p>(</span><span class=nx>c</span><span class=p>)=</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=err>&#39;</span><span class=nx>子go程序在运行</span><span class=err>&#39;</span><span class=p>,</span> <span class=nx>发送的元素</span><span class=p>=</span> <span class=mi>2</span>  <span class=nb>len</span><span class=p>(</span><span class=nx>c</span><span class=p>)=</span> <span class=mi>3</span> <span class=nb>cap</span><span class=p>(</span><span class=nx>c</span><span class=p>)=</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=nx>num</span> <span class=p>=</span>  <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=nx>num</span> <span class=p>=</span>  <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=err>&#39;</span><span class=nx>子go程序在运行</span><span class=err>&#39;</span><span class=p>,</span> <span class=nx>发送的元素</span><span class=p>=</span> <span class=mi>3</span>  <span class=nb>len</span><span class=p>(</span><span class=nx>c</span><span class=p>)=</span> <span class=mi>3</span> <span class=nb>cap</span><span class=p>(</span><span class=nx>c</span><span class=p>)=</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=nx>子go程序结束</span>
</span></span><span class=line><span class=cl><span class=nx>num</span> <span class=p>=</span>  <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=nx>num</span> <span class=p>=</span>  <span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=nx>main</span> <span class=nx>结束</span>
</span></span></code></pre></div><h4 id=关闭通道>关闭通道</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>v</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>ch</span>
</span></span></code></pre></div><p>如果通道接收不到数据后 <code>ok</code> 就为 <code>false</code>，这时通道就可以使用 <code>close()</code> 函数来关闭。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>5</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>c</span> <span class=o>&lt;-</span> <span class=nx>i</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>//close可以关闭一个channel
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nb>close</span><span class=p>(</span><span class=nx>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//ok如果为true表示channel没有关闭，如果为false表示channel已经关闭
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>data</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>c</span><span class=p>;</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Main Finished..&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 输出结果
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=mi>4</span>
</span></span></code></pre></div><p>如果将以上代码的 <code>close(c)</code> 去除，则程序在打印 5 次数据之后，就会报错，提示 goroutine 没有关闭造成阻塞死锁。</p><p>注意：</p><ul><li>channel 不像文件一样需要经常去关闭，只有当你确实没有任何发送数据了，或者你想显式的结束 range 循环之类的，才去关闭 channel；</li><li>关闭 channel 后，无法向 channel 再发送数据 (引发 panic 错误后导致接收立即返回零值)；</li><li>关闭 channel 后，可以继续从 channel 接收数据，比如<a href=#%E9%81%8D%E5%8E%86%E9%80%9A%E9%81%93>遍历通道</a>操作；</li><li>对于 nil channel，⽆无论收发都会被阻塞</li></ul><p>为什么要关闭通道？</p><ul><li><strong class=chinese>防止阻塞</strong>：如果不关闭通道，接收方在尝试接收数据时将会阻塞，导致程序无法正常退出。</li><li><strong class=chinese>清晰的信号</strong>：关闭通道提供了一种明确的信号，告诉接收方所有数据已经发送完毕。</li></ul><h4 id=遍历通道>遍历通道</h4><p>Go 通过 range 关键字来实现遍历读取到的数据，类似于与<strong class=chinese>数组</strong>或<strong class=chinese>切片</strong>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nb>close</span><span class=p>(</span><span class=nx>ch</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=nx>ele</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>ch</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>ele</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在遍历通道前，一定要先关闭通道，表示不允许再向队列里写入元素，否则可能会发生循环无法退出甚至是死锁情况。因为在循环遍历通道时会<strong class=chinese>阻塞</strong>取出通道内的元素，当元素取空时，自动跳出循环。</p><h3 id=select-语句>Select 语句</h3><p>单流程下一个 goroutine 只能监控一个 channel 的状态，而 select 可以完成监控多个 channel 的状态。select 具备多路 channel 的监控状态功能。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=o>&lt;-</span> <span class=nx>chan1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 如果chan1成功读到数据, 则进行该case处理语句
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>case</span> <span class=nx>chan2</span> <span class=o>&lt;-</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 如果成功向chan2写入数据, 则进行该case处理语句
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 如果上面都没有成功, 则进入default处理流程
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p><code>select</code> 语句使得一个 goroutine 可以等待多个通信操作。<code>select</code> 会<strong class=chinese>阻塞</strong>，直到其中的某个 case 可以继续执行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// fibonacci 函数计算 Fibonacci 数列，并通过通道 c 发送结果
</span></span></span><span class=line><span class=cl><span class=c1>// 当从 quit 通道接收到信号时，停止计算
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>fibonacci</span><span class=p>(</span><span class=nx>c</span><span class=p>,</span> <span class=nx>quit</span> <span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>x</span><span class=p>,</span> <span class=nx>y</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span> <span class=c1>// 初始化 Fibonacci 数列的前两个数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>select</span> <span class=p>{</span>  <span class=c1>// 同时监控两个channel
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>case</span> <span class=nx>c</span> <span class=o>&lt;-</span> <span class=nx>x</span><span class=p>:</span> <span class=c1>// 将当前 Fibonacci 数值发送到通道 c
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>x</span><span class=p>,</span> <span class=nx>y</span> <span class=p>=</span> <span class=nx>y</span><span class=p>,</span> <span class=nx>x</span><span class=o>+</span><span class=nx>y</span> <span class=c1>// 更新 x 和 y 为下一个 Fibonacci 数值
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>quit</span><span class=p>:</span> <span class=c1>// 等待 quit 通道的信号
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;quit&#34;</span><span class=p>)</span> <span class=c1>// 打印退出信息
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>return</span> <span class=c1>// 退出函数，结束 goroutine
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span> <span class=c1>// 创建一个用于发送 Fibonacci 数值的通道
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>quit</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span> <span class=c1>// 创建一个用于接收退出信号的通道
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// 启动一个新的 goroutine 用于接收 Fibonacci 数值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span> <span class=c1>// 循环接收 10 个 Fibonacci 数值
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=o>&lt;-</span><span class=nx>c</span><span class=p>)</span> <span class=c1>// 从通道 c 接收并打印 Fibonacci 数值
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>quit</span> <span class=o>&lt;-</span> <span class=mi>0</span> <span class=c1>// 发送退出信号到 quit 通道，通知主 goroutine 停止计算
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 调用 fibonacci 函数，开始计算 Fibonacci 数列
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>fibonacci</span><span class=p>(</span><span class=nx>c</span><span class=p>,</span> <span class=nx>quit</span><span class=p>)</span> <span class=c1>// 传入通道 c 和 quit
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 输出结果
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=mi>5</span>
</span></span><span class=line><span class=cl><span class=mi>8</span>
</span></span><span class=line><span class=cl><span class=mi>13</span>
</span></span><span class=line><span class=cl><span class=mi>21</span>
</span></span><span class=line><span class=cl><span class=mi>34</span>
</span></span><span class=line><span class=cl><span class=nx>quit</span>
</span></span></code></pre></div><hr><p>参考课程：</p><ol><li><a href=https://www.bilibili.com/video/BV1gf4y1r79E>8小时转职Golang工程师</a></li><li><a href=https://www.runoob.com/go/go-tutorial.html>Go语言教程 | 菜鸟教程</a></li></ol></article><div class=paginator><a class=link href=https://blog.pi3.fun/post/2024/go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A821%E5%8F%8D%E5%B0%84/>← prev</a>
<a class=link href=https://blog.pi3.fun/post/2024/11/gitignore%E5%B8%B8%E7%94%A8%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/>next →</a></div><div class=comment><div id=tcomment></div><script src=https://registry.npmmirror.com/twikoo/1.6.39/files/dist/twikoo.min.js></script><script async>twikoo.init({envId:"https://twikoo.pi3.fun/.netlify/functions/twikoo",el:"#tcomment",lang:"zh-CN"})</script></div></main><footer id=footer><div><span style=display:flex;align-items:center><span style=margin-right:.5rem>© 2021 - 2024</span><img src=https://image.pi3.fun/static/rainbow.gif loading=lazy width=20 alt=rainbow><span style=margin-left:.5rem>By Liu Chao</span></span></div><div class=footnote><span><a class=link href=/index.xml><span class="iconfont icon-RSS"></span></a> | <a class=link href=https://github.com/Pi3-l22 target=_ blank><span class="iconfont icon-GitHub"></span></a> | <a class=link href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank rel=noopener><span class="iconfont icon-creative-commons-fill"></span></a><br><a href=https://www.foreverblog.cn/ target=_blank><img src=https://img.foreverblog.cn/logo_en_default.png style=width:auto;height:16px> </a>| <a class=link href=https://blogscn.fun/ target=_blank><img src=https://photo.xiangming.site/img/blogscn.png style=width:auto;height:15px></a></span></div><div class=blog-icon></div></footer></div><script>document.addEventListener("DOMContentLoaded",function(){const n=localStorage.getItem("theme")||"light",e=document.querySelector('link[data-theme-style="light"]'),t=document.querySelector('link[data-theme-style="dark"]'),i=window.matchMedia("(prefers-color-scheme: dark)");i.addListener(function(n){if(!localStorage.getItem("theme")){const s=n.matches?"dark":"light";document.documentElement.setAttribute("data-theme",s),localStorage.setItem("theme",s),s==="light"?(e.media="all",t.media="not all"):(e.media="not all",t.media="all");const o=document.querySelector("iframe.giscus-frame");if(o){const e=s==="light"?"light_tritanopia":"dark_tritanopia";o.contentWindow.postMessage({giscus:{setConfig:{theme:e}}},"https://giscus.app")}}}),n==="light"?(e.media="all",t.media="not all"):(e.media="not all",t.media="all");function o(){const e=document.querySelector("iframe.giscus-frame");if(e){const t=n==="light"?"light_tritanopia":"dark_tritanopia";e.contentWindow.postMessage({giscus:{setConfig:{theme:t}}},"https://giscus.app")}else setTimeout(o,1e3)}o();const s=document.querySelector(".theme-toggle");s&&(s.textContent=n==="light"?"黑暗":"明亮",s.addEventListener("click",function(){const o=document.documentElement.getAttribute("data-theme"),n=o==="light"?"dark":"light";document.documentElement.setAttribute("data-theme",n),localStorage.setItem("theme",n),n==="light"?(e.media="all",t.media="not all"):(e.media="not all",t.media="all");const s=document.querySelector("iframe.giscus-frame");if(s){const e=n==="light"?"light_tritanopia":"dark_tritanopia";s.contentWindow.postMessage({giscus:{setConfig:{theme:e}}},"https://giscus.app")}this.textContent=n==="light"?"黑暗":"明亮"}))})</script></body></html>